<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>StealthChad</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="StealthChad (c) Bok Consulting Pty Ltd 2024" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="js/dexie.js"></script>
    <script src="js/noble-curves.js"></script>
    <script src="globals.js"></script>
    <script src="customNames.js"></script>
    <script src="deploymentData.js"></script>

    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/site.webmanifest">
    <link rel="mask-icon" href="images/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="images/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="images/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="https://bokkypoobah.github.io/StealthChad/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/LarvaChad_1532_zoomed_transparentbg.png" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">StealthChad</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'ERC-5564: Stealth Addresses Announcer Activity'">Activity</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings();" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'ERC-6538: Stealth Meta-Address Registry Activity'">Registry</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings();" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'List of Regular Addresses and Stealth Meta-Addresses'">Addresses</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 3; saveSettings();" :active="settings.tabIndex == 3" active-class="active" v-b-popover.hover="'ERC-20 and ERC-721 Tokens'">Tokens (WIP)</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 4; saveSettings();" :active="settings.tabIndex == 4" active-class="active" v-b-popover.hover="'Configuration'">Config</b-nav-item>
            <b-avatar v-if="coinbase && coinbase != ensNameOrAddress(coinbase)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensNameOrAddress(coinbase, 100)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar>
            <b-button size="sm" variant="outline-primary" class="ml-1" @click="connectToWeb3(); processNewBlock(0);" v-b-popover.hover.bottom="addressDescription(coinbase, 100)">{{ coinbase ? ensNameOrAddress(coinbase, 30) : 'Connect' }}</b-button>
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert v-if="false" size="sm" dismissible variant="warning" show class="m-1 my-0">
            Warning: This is experimental unaudited software. Please check your transaction data carefully before signing
          </b-alert>
          <b-card class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase || chainId != 11155111">
            <b-card-text>
              Please install the MetaMask extension and connect to the Ethereum Sepolia Testnet or an EVM compatible chain. Then refresh this page, and click the [Connect] button on the top right.
              <br />
              You can switch to the Ethereum Mainnet and click Sync your addresses with ENS names
            </b-card-text>
          </b-card>

          <!-- :MODALTRANSFER -->
          <b-modal id="modal-transfertostealthmetaaddress" hide-footer size="lg">
            <template #modal-title>
              Transfer To Stealth Meta-Address
            </template>

            <b-form-group label="From:" label-for="transfer-sender" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(coinbase)" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="transfer-sender" :href="chainInfo.explorerAddressPrefix + coinbase" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ coinbase }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(coinbase);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="coinbase != ensNameOrAddress(coinbase)" label="" label-for="transfer-senderensimage" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-avatar id="transfer-senderensimage" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensNameOrAddress(coinbase, 100)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
            </b-form-group>
            <b-form-group label="To:" label-for="transfer-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(modalTransfer.stealthMetaAddress)" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-textarea type="text" id="transfer-stealthmetaaddress" v-model.trim="modalTransfer.stealthMetaAddress" @input="saveSettings" rows="3"></b-form-textarea>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalTransfer.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group label="Amount:" label-for="transfer-amount" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="transfer-amount" v-model.trim="modalTransfer.amount" placeholder="e.g., 0.01 for 0.01 ETH" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="" label-for="transfer-transfer" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="transfer-transfer" @click="transferEthToStealthMetaAddress()" variant="warning">Transfer</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALACTIVITY -->
          <b-modal id="modal-activity" hide-footer size="lg">
            <template #modal-title>
              Activity
            </template>
            <b-form-group v-if="modalActivity.item" label="Transaction:" label-for="activity-txhash" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="activity-txhash" :href="chainInfo.explorerTxPrefix + modalActivity.item.txHash" variant="link" class="m-0 ml-2 p-0" v-b-popover.hover.bottom="modalActivity.item.txHash" target="_blank">{{ modalActivity.item.txHash.substring(0, (TXHASH_DISPLAY_LENGTH-2)/2) + '...' + modalActivity.item.txHash.slice(-TXHASH_DISPLAY_LENGTH/2) }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalActivity.item.txHash);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalActivity.item" label="Timestamp:" label-for="activity-timestamp" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="activity-timestamp" v-b-popover.hover.bottom="'Block #' + commify0(modalActivity.item.blockNumber)">{{ formatTimestamp(modalActivity.item.timestamp) }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalActivity.item && modalActivity.item.tx" label="Sender:" label-for="activity-sender" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(modalActivity.item.tx.from)" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="activity-registrant" :href="chainInfo.explorerAddressPrefix + modalActivity.item.tx.from" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ modalActivity.item.tx.from }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalActivity.item.tx.from);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalActivity.item && modalActivity.item.tx.from && (modalActivity.item.tx.from != ensNameOrAddress(modalActivity.item.tx.from))" label="" label-for="activity-senderensimage" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-avatar id="activity-senderensimage" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensNameOrAddress(modalActivity.item.tx.from, 100)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
            </b-form-group>
            <b-form-group v-if="modalActivity.item && modalActivity.item.stealthAddress" label="Receiver:" label-for="activity-receiver" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(modalActivity.item.stealthAddress) || 'Receiver Stealth Address'" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="activity-receiver" :href="chainInfo.explorerAddressPrefix + modalActivity.item.stealthAddress" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ modalActivity.item.stealthAddress }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalActivity.item.stealthAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalActivity.item && modalActivity.item.linkedTo && modalActivity.item.linkedTo.stealthMetaAddress" label="Receiver Private Key:" label-for="activity-spendingprivatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Sign message to reveal the Receiver Stealth Address private key" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input :type="modalActivity.stealthPrivateKey ? 'text' : 'password'" readonly size="sm" id="activity-spendingprivatekey" :value="modalActivity.stealthPrivateKey ? modalActivity.stealthPrivateKey : '*'.repeat(66)"></b-form-input>
                <b-input-group-append>
                  <b-button v-if="!modalActivity.stealthPrivateKey" :disabled="modalActivity.item.linkedTo.address != coinbase" @click="revealModalActivitySpendingPrivateKey();" variant="link" class="m-0 ml-2 p-0"><b-icon-eye shift-v="+1" font-scale="1.1"></b-icon-eye></b-button>
                  <b-button v-if="modalActivity.stealthPrivateKey" @click="copyToClipboard(modalActivity.stealthPrivateKey ? modalActivity.stealthPrivateKey : '*'.repeat(66));" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalActivity.item && modalActivity.item.linkedTo && modalActivity.item.linkedTo.stealthMetaAddress" label="linked to Stealth Meta-Address:" label-for="activity-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(modalActivity.item.stealthMetaAddress)" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-textarea readonly id="activity-stealthmetaaddress" :value="modalActivity.item.linkedTo.stealthMetaAddress" rows="3"></b-textarea>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalActivity.item.linkedTo.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalActivity.item && modalActivity.item.linkedTo && modalActivity.item.linkedTo.address" label="and Address:" label-for="activity-owner" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(modalActivity.item.linkedTo.address)" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="activity-owner" :href="chainInfo.explorerAddressPrefix + modalActivity.item.linkedTo.address" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ modalActivity.item.linkedTo.address }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalActivity.item.linkedTo.address);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalActivity.item && modalActivity.item.linkedTo && (modalActivity.item.linkedTo.address != ensNameOrAddress(modalActivity.item.linkedTo.address))" label="" label-for="address-ensnameimage" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-avatar rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensNameOrAddress(modalActivity.item.linkedTo.address, 100)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
            </b-form-group>
            <b-form-group v-if="modalActivity.item" label="Mine:" label-for="activity-mine" label-size="sm" label-cols-sm="3" label-align-sm="right" description="NOTE: Generate your Stealth Meta-Addresses for stealth keys to be linked" class="mx-0 my-1 p-0">
              <b-form-checkbox size="sm" disabled id="activity-mine" value="1" :checked="modalActivity.item.mine ? 1 : 0" class="mt-1 ml-2"></b-form-checkbox>
            </b-form-group>
            <b-form-group v-if="modalActivity.item && modalActivity.item.transfers" label="Transfers:" label-for="activity-transfers" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <font size="-1">
                <b-table small fixed striped responsive hover :fields="transfersFields" :items="modalActivity.item.transfers" head-variant="light" class="mx-0 my-1" thead-class="hidden_header">
                  <template #cell(tokens)="data">
                    <!-- TODO: Handle ERC-20/ERC-721 -->
                    {{ formatETH(data.item.tokens, 0) }}
                  </template>
                  <template #cell(tokenContractAddress)="data">
                    <!-- TODO: Handle ERC-20/ERC-721 -->
                    <!-- <b-link v-if="data.item.tx && data.item.tx.from" @click="viewAddress(data.item.tx.from)"> -->
                      <!-- <font size="-1" v-b-popover.hover="addressDescription(data.item.tokenContractAddress)">{{ nameOrAddress(data.item.tokenContractAddress, 28) }}</font> -->
                    <!-- </b-link> -->
                    ETH
                  </template>
                </b-table>
              </font>
            </b-form-group>
            <b-form-group v-if="modalActivity.item" label="Scheme Id:" label-for="activity-schemeid" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="activity-schemeid">{{ modalActivity.item.schemeId }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalActivity.item && modalActivity.item.ephemeralPublicKey" label="Ephemeral Public Key:" label-for="activity-ephemeralpublickey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input type="text" readonly size="sm" id="activity-ephemeralpublickey" :value="modalActivity.item.ephemeralPublicKey"></b-form-input>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalActivity.item.ephemeralPublicKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalActivity.item && modalActivity.item.caller" label="Caller:" label-for="activity-caller" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(modalActivity.item.caller)" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="activity-caller" :href="chainInfo.explorerAddressPrefix + modalActivity.item.caller" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ modalActivity.item.caller }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalActivity.item.caller);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
          </b-modal>

          <!-- :MODALREGISTRY -->
          <b-modal id="modal-registry" hide-footer size="lg">
            <template #modal-title>
              Registry Entry
            </template>
            <b-form-group v-if="modalRegistry.item" label="Transaction:" label-for="registry-txhash" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="registry-txhash" :href="chainInfo.explorerTxPrefix + modalRegistry.item.txHash" variant="link" class="m-0 ml-2 p-0" v-b-popover.hover.bottom="modalRegistry.item.txHash" target="_blank">{{ modalRegistry.item.txHash.substring(0, (TXHASH_DISPLAY_LENGTH-2)/2) + '...' + modalRegistry.item.txHash.slice(-TXHASH_DISPLAY_LENGTH/2) }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalRegistry.item.txHash);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalRegistry.item" label="Timestamp:" label-for="registry-timestamp" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="registry-timestamp" v-b-popover.hover.bottom="'Block #' + commify0(modalRegistry.item.blockNumber)">{{ formatTimestamp(modalRegistry.item.timestamp) }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalRegistry.item" label="Registrant:" label-for="registry-registrant" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(modalRegistry.item.registrant)" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="registry-registrant" :href="chainInfo.explorerAddressPrefix + modalRegistry.item.registrant" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ modalRegistry.item.registrant }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalRegistry.item.registrant);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalRegistry.item && modalRegistry.item.registrant && (modalRegistry.item.registrant != ensNameOrAddress(modalRegistry.item.registrant))" label="" label-for="address-ensnameimage" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-avatar rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensNameOrAddress(modalRegistry.item.registrant, 100)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
            </b-form-group>
            <b-form-group v-if="modalRegistry.item" label="Scheme Id:" label-for="registry-schemeid" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="registry-schemeid">{{ modalRegistry.item.schemeId }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalRegistry.item" label="Stealth Meta-Address:" label-for="registry-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(modalRegistry.item.stealthMetaAddress)" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="registry-stealthmetaaddress" variant="transparent" class="m-0 ml-2 p-0" v-b-popover.hover.bottom="modalRegistry.item.stealthMetaAddress" >{{ modalRegistry.item.stealthMetaAddress.substring(0, (STEALTHMETAADDRESS_DISPLAY_LENGTH-2)/2) + '...' + modalRegistry.item.stealthMetaAddress.slice(-STEALTHMETAADDRESS_DISPLAY_LENGTH/2) }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="transfer(modalRegistry.item.address);" variant="link" v-b-popover.hover="'Transfer to ' + modalRegistry.item.address" class="m-0 ml-2 p-0"><b-icon-caret-right shift-v="+1" font-scale="1.1"></b-icon-caret-right></b-button>
                  <b-button size="sm" @click="copyToClipboard(modalRegistry.item.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
          </b-modal>

          <!-- :MODALADDRESS -->
          <b-modal id="modal-address" hide-footer size="lg">
            <template #modal-title>
              {{ modalAddress.item.type == "address" ? "Address" : "Stealth Meta-Address" }}
            </template>
            <b-form-group v-if="modalAddress.item && modalAddress.item.type == 'address'" label="Address:" label-for="address-address" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(modalAddress.item.address)" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" :href="chainInfo.explorerAddressPrefix + modalAddress.item.address" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ modalAddress.item.address }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalAddress.item.address);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.type == 'address' && modalAddress.item.ensName" label="" label-for="address-ensnameimage" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-avatar v-if="modalAddress.item.address != ensNameOrAddress(modalAddress.item.address)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensNameOrAddress(modalAddress.item.address, 100)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.type == 'stealthMetaAddress'" label="Stealth Meta-Address:" label-for="address-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="address-stealthmetaaddress" variant="transparent" class="m-0 ml-2 p-0" v-b-popover.hover.bottom="modalAddress.item.address" >{{ modalAddress.item.address.substring(0, (STEALTHMETAADDRESS_DISPLAY_LENGTH-2)/2) + '...' + modalAddress.item.address.slice(-STEALTHMETAADDRESS_DISPLAY_LENGTH/2) }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="transfer(modalAddress.item.address);" variant="link" v-b-popover.hover="'Transfer to ' + modalAddress.item.address" class="m-0 ml-2 p-0"><b-icon-caret-right shift-v="+1" font-scale="1.1"></b-icon-caret-right></b-button>
                  <b-button size="sm" @click="copyToClipboard(modalAddress.item.address);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.linkedTo" label="Linked To:" label-for="address-linkedto" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(modalAddress.item.linkedTo)" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="address-linkedto" :href="chainInfo.explorerAddressPrefix + modalAddress.item.linkedTo" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ modalAddress.item.linkedTo }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalAddress.item.linkedTo);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.linkedTo" label="" label-for="address-linkedtoimage" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-avatar v-if="modalAddress.item.linkedTo != ensNameOrAddress(modalAddress.item.linkedTo)" id="address-linkedtoimage" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensNameOrAddress(modalAddress.item.linkedTo, 100)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.phrase" label="Phrase:" label-for="address-phrase" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-textarea size="sm" readonly id="address-phrase" v-model.trim="modalAddress.item.phrase" rows="3"></b-form-textarea>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalAddress.item.phrase);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalAddress.item" label="Name:" label-for="address-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input type="text" size="sm" id="address-name" v-model.trim="modalAddress.name"></b-form-input>
                <b-input-group-append>
                  <b-button :disabled="modalAddress.name == modalAddress.item.name" @click="saveModalAddressName();" variant="link" class="m-0 ml-2 p-0"><b-icon-pencil-square shift-v="+1" font-scale="1.1"></b-icon-pencil-square></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalAddress.item" label="Mine:" label-for="address-mine" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="modalAddress.item.type == 'address' ? null : 'NOTE: Generate your Stealth Meta-Addresses for stealth keys to be linked'" class="mx-0 my-1 p-0">
              <b-form-checkbox size="sm" id="address-mine" value="1" :checked="modalAddress.item.mine ? 1 : 0" @change="toggleModalAddressMine()" class="mt-1 ml-2"></b-form-checkbox>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.viewingPrivateKey" label="Spending Private Key:" label-for="address-spendingprivatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input :type="modalAddress.spendingPrivateKey ? 'text' : 'password'" readonly size="sm" id="address-spendingprivatekey" :value="modalAddress.spendingPrivateKey ? modalAddress.spendingPrivateKey : '*'.repeat(66)"></b-form-input>
                <b-input-group-append>
                  <b-button v-if="!modalAddress.spendingPrivateKey" :disabled="modalAddress.item.linkedTo != coinbase" @click="revealModalAddressSpendingPrivateKey();" variant="link" class="m-0 ml-2 p-0"><b-icon-eye shift-v="+1" font-scale="1.1"></b-icon-eye></b-button>
                  <b-button v-if="modalAddress.spendingPrivateKey" @click="copyToClipboard(modalAddress.spendingPrivateKey ? modalAddress.spendingPrivateKey : '*'.repeat(66));" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.viewingPrivateKey" label="Viewing Private Key:" label-for="address-viewingprivatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input type="text" readonly size="sm" id="address-viewingprivatekey" :value="modalAddress.item.viewingPrivateKey"></b-form-input>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalAddress.item.viewingPrivateKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.spendingPublicKey" label="Spending Public Key:" label-for="address-spendingpublickey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input type="text" readonly size="sm" id="address-spendingpublickey" :value="modalAddress.item.spendingPublicKey"></b-form-input>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalAddress.item.spendingPublicKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.viewingPublicKey" label="Spending Public Key:" label-for="address-viewingpublickey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input type="text" readonly size="sm" id="address-viewingpublickey" :value="modalAddress.item.viewingPublicKey"></b-form-input>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalAddress.item.viewingPublicKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
          </b-modal>

          <!-- :MODALNEWSTEALTHMETAADDRESS -->
          <b-modal id="modal-newstealthmetaaddress" hide-footer size="lg">
            <template #modal-title>
              Generate New Stealth Meta-Address
            </template>
            <b-form-group label="Attached Address:" label-for="newsma-attachedaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(coinbase)" class="mx-0 my-1 p-0">

              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="newsma-attachedaddress" :href="chainInfo.explorerAddressPrefix + coinbase" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ coinbase }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(coinbase);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="coinbase != ensNameOrAddress(coinbase)" label="" label-for="newsma-attachedaddressimage" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-avatar id="newsma-attachedaddressimage" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensNameOrAddress(coinbase)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
            </b-form-group>
            <b-form-group label="Name:" label-for="newsma-smaname" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newsma-smaname" v-model.trim="modalNewStealthMetaAddress.name" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="Phrase:" label-for="newsma-phrase" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0" description="This exact phrase with the attached address is required for the recovery of your stealth keys!">
              <b-input-group size="sm" class="w-100">
                <b-form-textarea size="sm" id="newsma-phrase" v-model.trim="modalNewStealthMetaAddress.phrase"></b-form-textarea>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalNewStealthMetaAddress.phrase);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group label="" label-for="newsma-generate" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Sign the phrase above with your web3 attached address" class="mx-0 my-1 p-0">
              <b-button size="sm" id="newsma-generate" @click="generateNewStealthMetaAddress()" variant="warning">Generate</b-button>
            </b-form-group>
            <b-form-group v-if="modalNewStealthMetaAddress.stealthMetaAddress" label="Stealth Meta-Address:" label-for="newsma-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-textarea size="sm" readonly id="newsma-stealthmetaaddress" :value="modalNewStealthMetaAddress.stealthMetaAddress" rows="3"></b-form-textarea>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalNewStealthMetaAddress.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalNewStealthMetaAddress.stealthMetaAddress" label="" label-for="newsma-addtoaddressbook" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="modalNewStealthMetaAddress.status == 'mine' ? 'Update address with stealth keys' : (modalNewStealthMetaAddress.status == 'notmine' ? 'Already in addresses, to be claimed' : 'Add new to addresses')" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!modalNewStealthMetaAddress.stealthMetaAddress" id="newsma-addtoaddressbook" @click="addStealthMetaAddressToAddresses()" variant="warning">{{ modalNewStealthMetaAddress.status == 'mine' ? 'Update' : (modalNewStealthMetaAddress.status == 'notmine' ? 'Claim' : 'Add') }}</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALCONTRACT -->
          <b-modal id="modal-contract" hide-footer size="lg">
            <template #modal-title>
              {{ contractTypeOptions.filter(e => e.value == modalContract.item.type)[0] && contractTypeOptions.filter(e => e.value == modalContract.item.type)[0].text || ("Unknown: " + modalContract.item.type) }}
            </template>
            <b-form-group v-if="modalContract.item && modalContract.item.chainId" label="Chain:" label-for="contract-chain" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="contract-chain">{{ settings.chains[modalContract.item.chainId] && settings.chains[modalContract.item.chainId].name || ("Unconfigured ChainId: " + modalContract.item.chainId) }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalContract.item && modalContract.item.contract" label="Address:" label-for="contract-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" :href="chainInfo.explorerAddressPrefix + modalContract.item.contract" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ modalContract.item.contract }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalContract.item.contract);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalContract.item && modalContract.item.type" label="Type:" label-for="contract-type" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="contract-type">{{ contractTypeOptions.filter(e => e.value == modalContract.item.type)[0] && contractTypeOptions.filter(e => e.value == modalContract.item.type)[0].text || ("Unknown: " + modalContract.item.type) }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalContract.item && modalContract.item.timestamp" label="First Event:" label-for="contract-timestamp" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="link" id="contract-timestamp" :href="chainInfo.explorerBlockPrefix + modalContract.item.blockNumber" v-b-popover.hover.bottom="'Block #' + commify0(modalContract.item.blockNumber)" target="_blank">{{ formatTimestamp(modalContract.item.timestamp) }}</b-button>
            </b-form-group>
            <b-form-group label="Name:" label-for="modalcontract-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input type="text" size="sm" id="modalcontract-name" v-model.trim="modalContract.name"></b-form-input>
                <b-input-group-append>
                  <b-button :disabled="modalContract.name == (modalContract.item && modalContract.item.name)" @click="saveModalContractName();" variant="link" class="m-0 ml-2 p-0"><b-icon-pencil-square shift-v="+1" font-scale="1.1"></b-icon-pencil-square></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group label="Read:" label-for="contract-read" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Read event logs involving this contract" class="mx-0 my-1 p-0">
              <b-form-checkbox size="sm" id="contract-read" value="1" :checked="modalContract.read ? 1 : 0" @change="toggleContractRead()" class="mt-1 ml-2"></b-form-checkbox>
            </b-form-group>
            <b-form-group label="Write:" label-for="contract-write" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Send transactions to contract, where supported" class="mx-0 my-1 p-0">
              <b-form-checkbox size="sm" id="contract-write" value="1" :checked="modalContract.write ? 1 : 0" @change="toggleContractWrite()" class="mt-1 ml-2"></b-form-checkbox>
            </b-form-group>
          </b-modal>

          <b-card class="m-0 p-0 border-0" body-class="m-1 p-0">
            <!-- :TOOLBAR -->
            <b-card-text v-if="coinbase" class="m-0 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div v-if="settings.tabIndex == 3" class="mt-1 pr-1">
                  <b-form-checkbox size="sm" v-model.trim="settings.tokenEventsTable.activeOnly" @input="saveSettings" v-b-popover.hover.bottom="'Only display Active items'">
                    Active Only
                  </b-form-checkbox>
                </div>
                <!-- <div v-if="false && (settings.tabIndex == 0 || settings.tabIndex == 1)" class="mt-1 pr-1">
                  <b-form-checkbox size="sm" :disabled="sync.section != null" v-model.trim="settings.searchAttachedAccount" @input="saveSettings" v-b-popover.hover.bottom="'Search for approval events emitted by your attached web3 account'">
                    Attached
                  </b-form-checkbox>
                </div> -->
                <!-- <div v-if="false && !settings.searchAttachedAccount" class="mt-0 pr-1" style="width: 25.0rem;">
                  <b-form-textarea :disabled="sync.section != null" size="sm" v-model.trim="settings.searchAccounts" @change="saveSettings" debounce="600" rows="3" max-rows="10" v-b-popover.hover.top="'Search for approval events emitted this list of owner addresses'" :placeholder="'0x12...34\n0x23...45 0x34...56'"></b-form-textarea>
                </div> -->
                <!-- <div v-if="false && settings.tabIndex == 0" class="mt-1 pr-1">
                  <b-form-checkbox size="sm" v-model.trim="settings.approvalsTable.includeInactive" @input="saveSettings" v-b-popover.hover.bottom="'Include inactive approvals'">
                    Inactive
                  </b-form-checkbox>
                </div> -->
                <!-- <div v-if="false && settings.tabIndex == 1" class="mt-1 pr-1">
                  <b-form-checkbox size="sm" v-model.trim="settings.eventsTable.includeFluff" @input="saveSettings" v-b-popover.hover.bottom="'Include less important events like ERC-721 Approval to Null:0x0000...0000'">
                    Fluff
                  </b-form-checkbox>
                </div> -->
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="settings.tabIndex != 5 && !sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="saveSettings(); syncIt(false);" variant="primary" v-b-popover.hover.bottom="'Sync stealth address announcement events'">Sync</b-button>
                </div>
                <div v-if="settings.tabIndex != 5 && !sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="saveSettings(); syncIt(true);" variant="outline-primary" v-b-popover.hover.bottom="'This will do dev things'">Dev</b-button>
                </div>
                <div v-if="sync.section" class="mt-1 p-0" style="width: 300px;">
                  <b-progress height="1.5rem" :max="sync.total" show-progress :animated="!sync.section" :variant="sync.section ? 'success' : 'secondary'" v-b-popover.hover.bottom="'Click the button on the right to stop this process'">
                    <b-progress-bar :value="sync.completed">
                      {{ sync.total == null || sync.total == 0 ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                    </b-progress-bar>
                  </b-progress>
                </div>
                <!-- <div class="ml-0 mt-1">
                  <b-link v-if="sync.section" size="sm" @click="halt" variant="link" v-b-popover.hover.bottom="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-link>
                </div> -->
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <b-button size="sm" @click="newStealthMetaAddress" variant="link" v-b-popover.hover.bottom="'Generate new Stealth Meta-Address'"><b-icon-plus shift-v="+1" font-scale="1.0"></b-icon-plus></b-button>
                </div>
                <div class="mt-0 pl-1">
                  <b-button size="sm" @click="transfer(null);" variant="link" v-b-popover.hover.bottom="'Transfer to Stealth Meta-Address'"><b-icon-caret-right shift-v="+1" font-scale="1.0"></b-icon-caret-right></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div class="mt-0 pl-1">
                  <b-button size="sm" :pressed.sync="settings.showInfo" @click="saveSettings" variant="link" v-b-popover.hover.bottom="'Show info'"><span v-if="settings.showInfo"><b-icon-info-circle-fill shift-v="+1" font-scale="1.0"></b-icon-info-circle-fill></span><span v-else><b-icon-info-circle shift-v="+1" font-scale="1.0"></b-icon-info-circle></span></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="settings.tabIndex == 0" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.activityTable.sortOption" @change="saveSettings" :options="activitySortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 1" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.registryActivityTable.sortOption" @change="saveSettings" :options="registryActivitySortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.addressesTable.sortOption" @change="saveSettings" :options="addressesSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.tokenEventsTable.sortOption" @change="saveSettings" :options="tokenEventsSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 0" class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.bottom="'# events'">{{ commify0(filteredActivity.length) + '/' + commify0(announcements.length) }}</font>
                </div>
                <div v-if="settings.tabIndex == 1" class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.bottom="'# registry events'">{{ commify0(filteredRegistryEntries.length) + '/' + commify0(registryEntries.length) }}</font>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <!-- TODO -->
                  <font size="-2" v-b-popover.hover.bottom="'# registry events'">{{ commify0(filteredAddresses.length) + '/' + commify0(totalAddresses) }}</font>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.bottom="'# token events'">{{ commify0(filteredTokenEvents.length) + '/' + commify0(filteredTokenEvents.length) }}</font>
                </div>
                <div v-if="settings.tabIndex == 0" class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.activityTable.currentPage" @input="saveSettings" :total-rows="filteredActivity.length" :per-page="settings.activityTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 1" class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.registryActivityTable.currentPage" @input="saveSettings" :total-rows="filteredRegistryEntries.length" :per-page="settings.registryActivityTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <!-- TODO -->
                  <b-pagination size="sm" v-model="settings.addressesTable.currentPage" @input="saveSettings" :total-rows="filteredAddresses.length" :per-page="settings.addressesTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.tokenEventsTable.currentPage" @input="saveSettings" :total-rows="filteredTokenEvents.length" :per-page="settings.tokenEventsTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 0" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.activityTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 1" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.registryActivityTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.addressesTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.tokenEventsTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
              </div>
            </b-card-text>

            <b-card-text class="m-0 p-0">
              <!-- :INFO -->
              <b-card v-if="settings.showInfo || coinbase == null" no-body class="my-1 p-1">
                <b-card-body class="mt-1 p-1">
                  <h4>Welcome</h4>
                  Stealth Chad is an implementation of <b-link href="https://eips.ethereum.org/EIPS/eip-5564" target="_blank">ERC-5564: Stealth Addresses</b-link> and <b-link href="https://eips.ethereum.org/EIPS/eip-6538" target="_blank">ERC-6538: Stealth Meta-Address Registry</b-link> (using <i>bytes32</i> instead of <i>bytes</i>).

                  <h5 class="mt-4">How The ERC-5564: Stealth Addresses Protocol Works</h5>
                  <ul>
                    <li>Alice wants to pay Bob in ETH/ERC-20/ERC-721 tokens</li>
                    <li>Bob generates a <i>Stealth Meta-Address</i> and provides this to Alice</li>
                    <li>Alice uses Bob's <i>Stealth Meta-Address</i> to compute a random <i>Stealth Address</i> that can be accessed only by Bob</li>
                    <li>Alice transfers the tokens to this address and announces the transfers in the <i>ERC-5564: Stealth Address Announcer</i> contract</li>
                    <li>Bob can access the private keys to their computed <i>Stealth Addresses</i>, using information included in the announcements</li>
                    <li>The <i>ERC-6538: Stealth Meta-Address Registry</i> allows any account to publish their associated <i>Stealth Meta-Addresses</i></li>
                  </ul>

                  <h5 class="mt-4">How This Dapp Works</h5>
                  This dapp:
                  <ul>
                    <li>Allows Bob's web3 attached account to generate a unique <i>Stealth Meta-Address</i> for each unique associated <i>phrase</i></li>
                    <li>Allows Bob to publish one or more <i>Stealth Meta-Addresses</i> associated with thier web3 attached accounts and unique <i>phrase</i></li>
                    <li>Allows Alice to compute a random <i>Stealth Address</i> using Bob's <i>Stealth Meta-Address</i></li>
                    <li>Allows Alice to then execute the transfer to Bob's <i>Stealth Address</i> and announce the transfer to the <i>Announcer</i></li>
                    <li>Retrieve all event logs published to the <i>Announcer</i>. Alice's transfer to Bob will appear in this data</li>
                    <li>Retrieves all event logs published to the <i>Registry</i></li>
                  </ul>

                  <!-- <h5 class="mt-3">Requirements</h5>
                  <ul>
                    <li>This dapp runs in web3 enabled desktop browsers connected to the Ethereum mainnet, and should work with other Ethereum-Virtual-Machine compatible chains</li>
                  </ul> -->

                  <h5 class="mt-3">Contracts on Sepolia</h5>
                  <ul>
                    <li><b-link href="https://sepolia.etherscan.io/address/0x4f58404f363f8a3282648e80440e075e5c1e28a1#code" target="_blank">ERC5564Announcer</b-link></li>
                    <li><b-link href="https://sepolia.etherscan.io/address/0xC5F111011acAd96860a3cd3d7C50Dd8f56a5684e#code" target="_blank">ERC5564Registry v0.8.0</b-link></li>
                    <li><b-link href="https://sepolia.etherscan.io/address/0x3834bcA9093e375893D65975ad765179A149D017#code" target="_blank">StealthChad v0.8.0</b-link></li>
                  </ul>

                  <h5 class="mt-3">References</h5>
                  <ul>
                    <li><b-link href="https://eips.ethereum.org/EIPS/eip-5564" target="_blank">ERC-5564: Stealth Addresses</b-link></li>
                    <li><b-link href="https://eips.ethereum.org/EIPS/eip-6538" target="_blank">ERC-6538: Stealth Meta-Address Registry</b-link></li>
                  </ul>

                  <h5 class="mt-3">This Dapp</h5>
                  <ul>
                    <li>Dapp: <b-link href="https://bokkypoobah.github.io/StealthChad/" target="_blank">https://bokkypoobah.github.io/StealthChad/</b-link></li>
                    <li>GitHub: <b-link href="https://github.com/bokkypoobah/StealthChad" target="_blank">https://github.com/bokkypoobah/StealthChad</b-link></li>
                    <li>Main Dapp Source Code: <b-link href="https://github.com/bokkypoobah/StealthChad/blob/main/docs/index.html" target="_blank">https://github.com/bokkypoobah/StealthChad/blob/main/docs/index.html</b-link></li>
                  </ul>

                  <!-- <h5 class="mt-3">Running Locally</h5>
                  <ul>
                    <li>In a folder on your computer, <b>git clone <b-link href="https://github.com/bokkypoobah/StealthChad" target="_blank">https://github.com/bokkypoobah/StealthChad</b-link></b></li>
                    <li>Run a tool like <b-link href="https://www.npmjs.com/package/anywhere" target="_blank">anywhere</b-link> in the <b>./docs</b> subdirectory of the folder created above</li>
                  </ul> -->

                  <!-- <h5 class="mt-3">Design</h5>
                  <ul>
                    <li>This dapp is designed to have minimal external dependencies - all code is statically served from GitHub</li>
                    <li>No backend servers are necessary, only a web3 connection</li>
                  </ul> -->

                  <!-- <h5 class="mt-3">Warning</h5>
                  <ul>
                    <li>This is experimental unaudited software. Please check your transaction data carefully when updating your approvals!</li>
                  </ul> -->

                  <h5 class="mt-3">Troubleshooting</h5>
                  <ul>
                    <li>If this dapp is not receiving the latest Mainnet data, reset your MetaMask web3 connection using <b>Settings</b> -> <b>Advanced</b> -> <b>Clear activity and nonce data</b></li>
                    <li>Reset this dapp data by removing LocalStorage entries with the keys beginning with <b>stealthChad</b></li>
                  </ul>
                </b-card-body>
              </b-card>


              <!-- :ACTIVITY -->
              <b-table v-if="settings.tabIndex == 0 && !settings.showInfo" ref="activityTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='activityRowSelected' :fields="activityFields" :items="pagedFilteredSortedActivity" show-empty empty-html="Click Sync above to retrieve stealth address announcement events" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.activityTable.currentPage - 1) * settings.activityTable.pageSize) + 1 }}
                  </font>
                </template>
                <template #cell(timestamp)="data">
                  <font size="-1">
                    <b-link :href="chainInfo.explorerTxPrefix + data.item.txHash" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber) + ', txIndex: ' + data.item.txIndex + ', logIndex: ' + data.item.logIndex" target="_blank">
                      <span v-if="data.item.timestamp">
                        {{ formatTimestamp(data.item.timestamp) }}
                      </span>
                      <span v-else>
                        {{ '#' + commify0(data.item.blockNumber) }}
                      </span>
                    </b-link>
                  </font>
                </template>
                <template #cell(sender)="data">
                  <b-link v-if="data.item.tx && data.item.tx.from" @click="viewAddress(data.item.tx.from)">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.tx.from)">{{ nameOrAddress(data.item.tx.from, 28) }}</font>
                  </b-link>
                </template>
                <template #cell(receiver)="data">
                  <b-link @click="viewAddress(data.item.stealthAddress)">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.stealthAddress)">{{ nameOrAddress(data.item.stealthAddress, 28) }}</font>
                  </b-link>
                </template>
                <template #cell(mine)="data">
                  <b-form-checkbox size="sm" disabled value="1" :checked="data.item.mine ? 1 : 0" class="mt-1 ml-2"></b-form-checkbox>
                </template>
                <template #cell(tokens)="data">
                  <!-- TODO: Handle ERC-20/ERC-721 -->
                  <font size="-1">
                    {{ formatETH(data.item.transfers[0].tokens, 0) }}
                  </font>
                </template>
                <template #cell(token)="data">
                  <!-- TODO: Handle ERC-20/ERC-721 -->
                  <font size="-1">
                    ETH
                  </font>
                </template>
              </b-table>

              <!-- :REGISTRY -->
              <b-table v-if="settings.tabIndex == 1 && !settings.showInfo" ref="registryTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='registryRowSelected' :fields="registryEntriesFields" :items="pagedFilteredSortedRegistryEntries" show-empty empty-html="Click Sync above to retrieve stealth address registry events" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.registryActivityTable.currentPage - 1) * settings.registryActivityTable.pageSize) + 1 }}
                  </font>
                </template>
                <template #cell(timestamp)="data">
                  <font size="-1">
                    <b-link :href="chainInfo.explorerTxPrefix + data.item.txHash" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber) + ', txIndex: ' + data.item.txIndex + ', logIndex: ' + data.item.logIndex" target="_blank">
                      <span v-if="data.item.timestamp">
                        {{ formatTimestamp(data.item.timestamp) }}
                      </span>
                      <span v-else>
                        {{ '#' + commify0(data.item.blockNumber) }}
                      </span>
                    </b-link>
                  </font>
                </template>
                <template #cell(registrant)="data">
                  <b-link @click="viewAddress(data.item.registrant)">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.registrant)">{{ nameOrAddress(data.item.registrant) }}</font>
                  </b-link>
                </template>
                <template #cell(schemeId)="data">
                  <font size="-1">{{ data.item.schemeId }}</font>
                </template>
                <template #cell(transfer)="data">
                  <b-button size="sm" @click="transfer(data.item.stealthMetaAddress);" variant="link" v-b-popover.hover="'Transfer to ' + data.item.stealthMetaAddress" class="m-0 ml-2 p-0"><b-icon-caret-right shift-v="+1" font-scale="1.1"></b-icon-caret-right></b-button>
                </template>
                <template #cell(stealthMetaAddress)="data">
                  <b-link @click="viewAddress(data.item.stealthMetaAddress)">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.stealthMetaAddress)">{{ data.item.stealthMetaAddress.substring(0, (STEALTHMETAADDRESS_SHORT_DISPLAY_LENGTH-2)/2) + '...' + data.item.stealthMetaAddress.slice(-STEALTHMETAADDRESS_SHORT_DISPLAY_LENGTH/2) }}</font>
                  </b-link>
                </template>
                <!-- <template #cell(contract)="data">
                  <b-link :href="'https://sepolia.etherscan.io/address/' + data.item.contract" target="_blank">
                    <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.contract)" class="px-0">{{ nameOrAddress(data.item.contract, 28) }}</b-badge>
                  </b-link>
                </template> -->
                <!-- <template #cell(details)="data">
                  <font size="-1">
                    <pre>
      {{ data.item }}
                    </pre>
                  </font>
                </template> -->
              </b-table>

              <!-- :ADDRESSES -->
              <b-table v-if="settings.tabIndex == 2 && !settings.showInfo" ref="addressesTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='addressesRowSelected' :fields="addressesFields" :items="pagedFilteredSortedAddresses" show-empty empty-html="Click Sync above to retrieve stealth address registry events before adding new entries" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.addressesTable.currentPage - 1) * settings.addressesTable.pageSize) + 1 }}
                  </font>
                </template>
                <template #cell(transfer)="data">
                  <div v-if="data.item.address.substring(0, 2) == 'st'">
                    <b-button size="sm" @click="transfer(data.item.address);" variant="link" v-b-popover.hover="'Transfer to ' + data.item.address" class="m-0 ml-2 p-0"><b-icon-caret-right shift-v="+1" font-scale="1.1"></b-icon-caret-right></b-button>
                  </div>
                </template>
                <template #cell(address)="data">
                  <b-link @click="viewAddress(data.item.address)" v-b-popover.hover="addressDescription(data.item.address)">
                    <font size="-1">{{ data.item.address.substring(0, 2) == 'st' ? data.item.address.substring(0, (STEALTHMETAADDRESS_SHORT_DISPLAY_LENGTH-2)/2) + '...' + data.item.address.slice(-STEALTHMETAADDRESS_SHORT_DISPLAY_LENGTH/2) : data.item.address }}</font>
                  </b-link>
                </template>
                <template #cell(linkedTo)="data">
                  <span v-if="data.item.linkedTo && data.item.linkedTo.substring(0, 2) == 'st'">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.linkedTo)">{{ shortAddress(data.item.linkedTo) }}</font>
                  </span>
                  <span v-else>
                    <b-link @click="viewAddress(data.item.linkedTo)">
                      <font size="-1" v-b-popover.hover="addressDescription(data.item.linkedTo)">{{ nameOrAddress(data.item.linkedTo) }}</font>
                    </b-link>
                  </span>
                </template>
                <template #cell(name)="data">
                  <!-- <font size="-1">{{ data.item.ensName ? (data.item.ensName + (data.item.name ? ('; ' + data.item.name) : '')) : data.item.name }}</font> -->
                  <font size="-1">{{ nameOrNull(data.item.address) }}</font>
                </template>
                <template #cell(mine)="data">
                  <b-form-checkbox size="sm" disabled value="1" :checked="data.item.mine ? 1 : 0" class="mt-1 ml-2"></b-form-checkbox>
                </template>
                <template #cell(source)="data">
                  <font size="-1">
                    {{ sourceOptions.filter(e => e.value == data.item.source)[0] && sourceOptions.filter(e => e.value == data.item.source)[0].text || ("Unknown: " + data.item.source) }}
                  </font>
                </template>
              </b-table>

              <!-- :TOKENEVENTS -->
              <!-- <b-table v-if="settings.tabIndex == 3 && !settings.showInfo" ref="tokenEventsTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='activityRowSelected' :fields="tokenEventsFields" :items="pagedFilteredSortedTokenEvents" show-empty empty-html="Click Sync above to retrieve stealth address announcement events" head-variant="light" class="mx-0 my-1"> -->
              <b-table v-if="settings.tabIndex == 3 && !settings.showInfo" ref="tokenEventsTable" small fixed striped responsive hover :fields="tokenEventsFields" :items="pagedFilteredSortedTokenEvents" show-empty empty-html="Click Sync above to retrieve stealth address announcement events" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.tokenEventsTable.currentPage - 1) * settings.tokenEventsTable.pageSize) + 1 }}
                  </font>
                </template>
                <template #cell(contract)="data">
                  <b-link :href="chainInfo.explorerAddressPrefix + data.item.contract + '#code'" target="_blank">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.contract)">{{ ensNameOrAddress(data.item.contract, 21) }}</font>
                  </b-link>
                </template>
                <template #cell(type)="data">
                  <font size="-1">{{ data.item.type == "erc20" ? "ERC-20" : "ERC-721" }}</font>
                </template>
                <template #cell(symbol)="data">
                  <font size="-1">{{ data.item.symbol }}</font>
                </template>
                <template #cell(name)="data">
                  <font size="-1">{{ data.item.name }}</font>
                </template>
                <template #cell(active)="data">
                  <font size="-1"><b-form-checkbox size="sm" value="1" :checked="data.item.active ? 1 : 0" @change="toggleTokenContractActive(data.item)" class="mt-1 ml-2"></b-form-checkbox></font>
                </template>
                <template #cell(firstEventBlockNumber)="data">
                  <font size="-1">{{ commify0(data.item.firstEventBlockNumber) }}</font>
                </template>
                <template #cell(lastEventBlockNumber)="data">
                  <font size="-1">{{ commify0(data.item.lastEventBlockNumber) }}</font>
                </template>
                <template #cell(decimals)="data">
                  <font size="-1">{{ data.item.type == "erc20" ? parseInt(data.item.decimals) : "" }}</font>
                </template>
                <template #cell(balance)="data">
                  <font size="-1">{{ (data.item.balances[coinbase] && data.item.type == "erc20") ? formatDecimals(data.item.balances[coinbase], data.item.decimals || 0) : "" }}</font>
                </template>
                <template #cell(totalSupply)="data">
                  <font size="-1">{{ data.item.type == "erc20" ? formatDecimals(data.item.totalSupply, data.item.decimals || 0) : data.item.totalSupply }}</font>
                </template>
                <!-- <template #cell(timestamp)="data">
                  <font size="-1">
                    <b-link :href="'https://sepolia.etherscan.io/tx/' + data.item.txHash" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber) + ', txIndex: ' + data.item.txIndex + ', logIndex: ' + data.item.logIndex" target="_blank">
                      <span v-if="data.item.timestamp">
                        {{ formatTimestamp(data.item.timestamp) }}
                      </span>
                      <span v-else>
                        {{ '#' + commify0(data.item.blockNumber) }}
                      </span>
                    </b-link>
                  </font>
                </template>
                <template #cell(sender)="data">
                  <b-link v-if="data.item.tx && data.item.tx.from" @click="viewAddress(data.item.tx.from)">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.tx.from)">{{ nameOrAddress(data.item.tx.from, 28) }}</font>
                  </b-link>
                </template>
                <template #cell(receiver)="data">
                  <b-link @click="viewAddress(data.item.stealthAddress)">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.stealthAddress)">{{ nameOrAddress(data.item.stealthAddress, 28) }}</font>
                  </b-link>
                </template>
                <template #cell(mine)="data">
                  <b-form-checkbox size="sm" disabled value="1" :checked="data.item.mine ? 1 : 0" class="mt-1 ml-2"></b-form-checkbox>
                </template>
                <template #cell(tokens)="data">
                  <font size="-1">
                    {{ formatETH(data.item.transfers[0].tokens, 0) }}
                  </font>
                </template>
                <template #cell(token)="data">
                  <font size="-1">
                    ETH
                  </font>
                </template> -->
              </b-table>



              <!-- :CONFIG -->
              <b-card v-if="settings.tabIndex == 4 && !settings.showInfo && coinbase != null" no-body class="my-1 p-1">
                <b-card-body class="mt-1 p-1">
                  <h5>Configure Contracts</h5>
                  <b-card no-body no-header bg-variant="light" class="m-1 p-1">
                    <!-- <b-form-group label-cols-lg="2" label="Search" label-size="md" label-class="font-weight-bold pt-0" class="mt-3 mb-0">
                      <b-form-group label="" label-for="config-search" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
                        <b-button size="sm" id="config-search" @click="searchForContracts()" variant="warning">Search</b-button>
                      </b-form-group>
                    </b-form-group> -->
                    <div class="d-flex flex-wrap m-0 p-0">
                      <div class="mt-0 flex-grow-1">
                      </div>
                      <div v-if="!sync.section" class="mt-0 pr-1">
                        <b-button size="sm" @click="saveSettings(); searchForContracts();" variant="primary" v-b-popover.hover.bottom="'Scan connected network for ERC-5564 and ERC-6538(with bytes32) events'">Scan</b-button>
                      </div>
                      <div class="mt-0 flex-grow-1">
                      </div>
                      <div class="mt-0 pl-1">
                        <b-form-select size="sm" v-model="settings.contractsTable.sortOption" @change="saveSettings" :options="contractsSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                      </div>
                      <div class="mt-0 pl-1">
                        <font size="-2" v-b-popover.hover.bottom="'# contracts'">{{ commify0(totalContracts) }}</font>
                      </div>
                      <div class="mt-0 pl-1">
                        <b-pagination size="sm" v-model="settings.contractsTable.currentPage" @input="saveSettings" :total-rows="totalContracts" :per-page="settings.contractsTable.pageSize" style="height: 0;"></b-pagination>
                      </div>
                      <div class="mt-0 pl-1">
                        <b-form-select size="sm" v-model="settings.contractsTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                      </div>
                    </div>

                    <b-table ref="contractsTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='contractRowSelected' :fields="contractsFields" :items="pagedFilteredSortedContracts" show-empty empty-html="Click Sync above to retrieve stealth address announcement events" head-variant="light" class="mx-0 my-1">
                      <template #cell(number)="data">
                        <font size="-1">
                          {{ parseInt(data.index) + ((settings.contractsTable.currentPage - 1) * settings.contractsTable.pageSize) + 1 }}
                        </font>
                      </template>
                      <template #cell(chainId)="data">
                        <font size="-1">
                          {{ settings.chains[data.item.chainId] && settings.chains[data.item.chainId].name || ("Unconfigured ChainId: " + data.item.chainId) }}
                        </font>
                      </template>
                      <template #cell(contract)="data">
                        <b-link :href="chainInfo.explorerAddressPrefix + data.item.contract + '#code'" target="_blank">
                          <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.contract)" class="px-0">{{ nameOrAddress(data.item.contract, 28) }}</b-badge>
                        </b-link>
                      </template>
                      <template #cell(type)="data">
                        <font size="-1">
                          {{ contractTypeOptions.filter(e => e.value == data.item.type)[0] && contractTypeOptions.filter(e => e.value == data.item.type)[0].text || ("Unknown: " + data.item.type) }}
                        </font>
                      </template>
                      <template #cell(name)="data">
                        <font size="-1">
                          {{ data.item.name }}
                        </font>
                      </template>
                      <template #cell(firstEvent)="data">
                        <font size="-1">
                          <b-link :href="chainInfo.explorerBlockPrefix + data.item.blockNumber" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber)" target="_blank">
                            <span v-if="data.item.timestamp">
                              {{ formatTimestamp(data.item.timestamp) }}
                            </span>
                            <span v-else>
                              {{ '#' + commify0(data.item.blockNumber) }}
                            </span>
                          </b-link>
                        </font>
                      </template>
                      <template #cell(read)="data">
                        <font size="-1">
                          <b-form-checkbox size="sm" disabled value="1" :checked="data.item.read ? 1 : 0" class="mt-1 ml-2"></b-form-checkbox>
                        </font>
                      </template>
                      <template #cell(write)="data">
                        <font size="-1">
                          <b-form-checkbox size="sm" disabled value="1" :checked="data.item.write ? 1 : 0" @input="toggleContractWrite(data.item)" class="mt-1 ml-2"></b-form-checkbox>
                        </font>
                      </template>
                    </b-table>
                  </b-card>
                </b-card-body>
              </b-card>

            </b-card-text>
          </b-card>
        </b-card>

        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div class="ml-0 mt-1 pl-1">
              <font v-if="connected" size="-2">
                <b-link v-if="coinbase" :href="chainInfo.explorerAddressPrefix + coinbase" v-b-popover.hover.bottom="coinbase" target="_blank">
                  {{ ensNameOrAddress(coinbase, 30) }}
                </b-link>
                @
                <b-link v-if="chainId" :href="chainInfo.explorerPrefix" v-b-popover.hover.bottom="'Network ChainId: ' + chainId" target="_blank">
                  {{ chainInfo.name }}
                </b-link>
                <b-link v-if="blockNumber" :href="chainInfo.explorerBlockPrefix + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ '#' + commify0(blockNumber) }}
                </b-link>
                {{ formatTimeDiff(timestamp) }}
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              gm, and enjoy! <i>StealthChad</i> &copy; Bok Consulting Pty Ltd 2024
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          CONFIRMATIONS: 100,
          DB_PROCESSING_BATCH_SIZE: 1000,
          TXHASH_DISPLAY_LENGTH: 50,
          STEALTHMETAADDRESS_SHORT_DISPLAY_LENGTH: 39,
          STEALTHMETAADDRESS_DISPLAY_LENGTH: 59,
          defaultPhrase: "I want to login into my stealth wallet on Ethereum mainnet.",
          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,

          forceRefresh: 0,

          stealthMetaAddress: {
            display: false,
            spendingPrivateKey: null, // TODO: Don't save this
            viewingPrivateKey: null,
          },

          settings: {
            tabIndex: 0,
            showInfo: false,
            reportingDateTime: 0,
            activityTable: {
              filter: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'txorderdsc',
            },
            registryActivityTable: {
              filter: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'txorderdsc',
            },
            addressesTable: {
              filter: null,
              currentPage: 1,
              pageSize: 25,
              sortOption: 'typenameasc',
            },
            tokenEventsTable: {
              activeOnly: false,
              filter: null,
              currentPage: 1,
              pageSize: 25,
              sortOption: 'typenameasc',
            },
            contractsTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'typenameasc',
            },
            chains: {
              "1": {
                name: "Ethereum Mainnet",
                explorerPrefix: "https://etherscan.io/",
                explorerAddressPrefix: "https://etherscan.io/address/",
                explorerTokenPrefix: "https://etherscan.io/token/",
                explorerTxPrefix: "https://etherscan.io/tx/",
                explorerBlockPrefix: "https://etherscan.io/block/",
              },
              "5": {
                name: "Goerli Testnet",
                explorerPrefix: "https://goerli.etherscan.io/",
                explorerAddressPrefix: "https://goerli.etherscan.io/address/",
                explorerTokenPrefix: "https://goerli.etherscan.io/token/",
                explorerTxPrefix: "https://goerli.etherscan.io/tx/",
                explorerBlockPrefix: "https://goerli.etherscan.io/block/",
              },
              "11155111": {
                name: "Sepolia Testnet",
                explorerPrefix: "https://sepolia.etherscan.io/",
                explorerAddressPrefix: "https://sepolia.etherscan.io/address/",
                explorerTokenPrefix: "https://sepolia.etherscan.io/token/",
                explorerTxPrefix: "https://sepolia.etherscan.io/tx/",
                explorerBlockPrefix: "https://sepolia.etherscan.io/block/",
              },
            },
            version: 32,
          },
          contracts: {
            "11155111": {
              "0x4f58404F363f8a3282648E80440e075e5C1E28a1": {
                "type": "announcer",
                "name": "ERC5564Announcer on Sepolia",
                "read": true,
                "write": false,
                "blockNumber": 4959070,
                "timestamp": 1703564424
              },
              "0x3834bcA9093e375893D65975ad765179A149D017": {
                "type": "caller",
                "name": "StealthChad v0.8.0 on Sepolia",
                "read": true,
                "write": true,
                "blockNumber": 4959070,
                "timestamp": 1703564424
              },
              "0xC5F111011acAd96860a3cd3d7C50Dd8f56a5684e": {
                "type": "registry",
                "name": "ERC5564Registry v0.8.0 on Sepolia",
                "read": true,
                "write": true,
                "blockNumber": 4960971,
                "timestamp": 1703590932
              }
            }
          },
          sync: {
            section: null,
            total: null,
            completed: null,
            halt: false,
          },

          announcements: [],
          registryEntries: [],
          tokenEvents: [],
          addresses: {},
          tokenContracts: {},

          modalTransfer: {
            stealthMetaAddress: null,
            amount: null,
          },
          modalActivity: {
            item: null,
            stealthPrivateKey: null,
          },
          modalRegistry: {
            item: null,
          },
          modalAddress: {
            item: null,
            name: null,
            spendingPrivateKey: null,
          },
          modalNewStealthMetaAddress: {
            name: null,
            linkedTo: null,
            phrase: null,
            viewingPrivateKey: null,
            spendingPublicKey: null,
            viewingPublicKey: null,
            stealthMetaAddress: null,
            status: null,
          },
          modalContract: {
            item: null,
            name: null,
            read: false,
            write: false,
          },
          sourceOptions: [
            { value: null, text: '(select)' },
            { value: "attached", text: 'Web3 attached account' },
            { value: "announcer.contract", text: 'ERC-5564 Announcer contract' },
            { value: "announcer.stealthAddress", text: 'ERC-5564 Announcer stealthAddress' },
            { value: "announcer.caller", text: 'ERC-5564 Announcer caller' },
            { value: "announcer.sender", text: 'ERC-5564 Announcer sender' },
            { value: "registry.registrant", text: 'ERC-6538 Registry registrant' },
            { value: "registry.contract", text: 'ERC-6538 Registry contract' },
            { value: "registry.stealthMetaAddress", text: 'ERC-6538 Registry stealthMetaAddress' },
          ],
          contractTypeOptions: [
            { value: null, text: '(select)' },
            { value: "announcer", text: 'ERC-5564 Announcer' },
            { value: "registry", text: 'ERC-6538 Registry' },
            { value: "caller", text: 'ERC-5564 Caller' },
          ],
          activitySortOptions: [
            { value: 'txorderasc', text: ' TxOrder' },
            { value: 'txorderdsc', text: ' TxOrder' },
          ],
          registryActivitySortOptions: [
            { value: 'txorderasc', text: ' TxOrder' },
            { value: 'txorderdsc', text: ' TxOrder' },
          ],
          contractsSortOptions: [
            { value: 'typenameasc', text: ' Type,  Name' },
            { value: 'typenamedsc', text: ' Type,  Name' },
            { value: 'nameasc', text: ' Name,  Address' },
            { value: 'namedsc', text: ' Name,  Address' },
          ],
          addressesSortOptions: [
            { value: 'typenameasc', text: ' Type,  Name' },
            { value: 'typenamedsc', text: ' Type,  Name' },
            { value: 'nameasc', text: ' Name' },
            { value: 'namedsc', text: ' Name' },
            { value: 'addressasc', text: ' Address' },
            { value: 'addressdsc', text: ' Address' },
          ],
          tokenEventsSortOptions: [
            { value: 'typenameasc', text: ' Type,  Name' },
            { value: 'typenamedsc', text: ' Type,  Name' },
            { value: 'nameasc', text: ' Name' },
            { value: 'namedsc', text: ' Name' },
            { value: 'addressasc', text: ' Address' },
            { value: 'addressdsc', text: ' Address' },
          ],
          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],
          falseTrueOptions: [
            { value: false, text: 'false' },
            { value: true, text: 'true' },
          ],
          decimalsOptions: [
            { value: null, text: '(use default)' },
            { value: "0", text: '0' },
            { value: "1", text: '1' },
            { value: "2", text: '2' },
            { value: "3", text: '3' },
            { value: "4", text: '4' },
            { value: "5", text: '5' },
            { value: "6", text: '6 (some)' },
            { value: "7", text: '7' },
            { value: "8", text: '8' },
            { value: "9", text: '9' },
            { value: "10", text: '10' },
            { value: "11", text: '11' },
            { value: "12", text: '12' },
            { value: "13", text: '13' },
            { value: "14", text: '14' },
            { value: "15", text: '15' },
            { value: "16", text: '16' },
            { value: "17", text: '17' },
            { value: "18", text: '18 (common)' },
          ],
          activityFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'timestamp', label: 'When', sortable: false, thStyle: 'width: 15%;', tdClass: 'text-truncate' },
            { key: 'sender', label: 'Sender', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'receiver', label: 'Receiver', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'mine', label: 'Mine', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'tokens', label: 'Tokens', sortable: false, thStyle: 'width: 15%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'token', label: 'Token', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-left' },
          ],
          transfersFields: [
            { key: 'tokens', label: 'Tokens', sortable: false, thStyle: 'width: 50%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'tokenContractAddress', label: 'Token', sortable: false, thStyle: 'width: 50%;', thClass: 'text-left', tdClass: 'text-truncate' },
          ],
          registryEntriesFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'timestamp', label: 'When', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'registrant', label: 'Registrant', sortable: false, thStyle: 'width: 25%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'schemeId', label: 'Scheme Id', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'transfer', label: '', sortable: false, thStyle: 'width: 2%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'stealthMetaAddress', label: 'Stealth Meta-Address', sortable: false, thStyle: 'width: 38%;', thClass: 'text-left', tdClass: 'text-left' },
          ],
          addressesFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 3%;', tdClass: 'text-truncate' },
            { key: 'transfer', label: '', sortable: false, thStyle: 'width: 2%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 25%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'linkedTo', label: 'Linked To', sortable: false, thStyle: 'width: 25%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'mine', label: 'Mine', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'source', label: 'Source', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
          ],
          tokenEventsFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'contract', label: 'Contract', sortable: false, thStyle: 'width: 16%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 7%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'active', label: 'Active', sortable: false, thStyle: 'width: 7%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'symbol', label: 'Symbol', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'firstEventBlockNumber', label: 'First Event #', sortable: false, thStyle: 'width: 13%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'lastEventBlockNumber', label: 'Last Event #', sortable: false, thStyle: 'width: 13%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'decimals', label: 'Decimals', sortable: false, thStyle: 'width: 7%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'balance', label: 'Balance', sortable: false, thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'totalSupply', label: 'Total Supply', sortable: false, thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          contractsFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'chainId', label: 'Chain', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'contract', label: 'Contract', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 25%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'read', label: 'Read', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'write', label: 'Write', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'firstEvent', label: 'First Event', sortable: false, thStyle: 'width: 15%;', tdClass: 'text-truncate' },
          ],
          reportingDateTimeOptions: [
            { value: 0, text: 'Local Time' },
            { value: 1, text: 'UTC Time' },
          ],
          db: {
            name: "stealthchaddata080h",
            version: 1,
            schemaDefinition: {
              announcements: '[chainId+blockNumber+logIndex],[blockNumber+contract],contract,confirmations',
              registryEntries: '[chainId+blockNumber+logIndex],[blockNumber+contract],contract,confirmations',
              tokenEvents: '[chainId+blockNumber+logIndex],[blockNumber+contract],contract,confirmations',
            },
            updated: null,
          },
        },

        // --- COMPUTED ---
        computed: {
          chainInfo() {
            if (this.chainId in this.settings.chains) {
              return this.settings.chains[this.chainId];
            } else {
              return {
                name: "Unconfigured ChainId: " + this.chainId,
                explorerPrefix: "(not configured)",
                explorerAddressPrefix: "(not configured)",
                explorerTokenPrefix: "(not configured)",
                explorerTxPrefix: "(not configured)",
                explorerBlockPrefix: "(not configured)",
              };
            }
          },
          filteredActivity() {
            return this.announcements.filter(e => e.chainId == this.chainId);
          },
          filteredSortedActivity() {
            let results = this.filteredActivity;
            if (this.settings.activityTable.sortOption == 'txorderasc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return a.logIndex - b.logIndex;
                  } else {
                    return a.txIndex - b.txIndex;
                  }
                } else {
                  return a.blockNumber - b.blockNumber;
                }
              });
            } else if (this.settings.activityTable.sortOption == 'txorderdsc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return b.logIndex - a.logIndex;
                  } else {
                    return b.txIndex - a.txIndex;
                  }
                } else {
                  return b.blockNumber - a.blockNumber;
                }
              });
            }
            return results;
          },
          pagedFilteredSortedActivity() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedActivity - results[0..9]: " + JSON.stringify(this.filteredSortedActivity.slice(0, 10), null, 2));
            return this.filteredSortedActivity.slice((this.settings.activityTable.currentPage - 1) * this.settings.activityTable.pageSize, this.settings.activityTable.currentPage * this.settings.activityTable.pageSize);
          },

          filteredRegistryEntries() {
            return this.registryEntries.filter(e => e.chainId == this.chainId);
          },
          filteredSortedRegistryEntries() {
            let results = this.filteredRegistryEntries;
            if (this.settings.registryActivityTable.sortOption == 'txorderasc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return a.logIndex - b.logIndex;
                  } else {
                    return a.txIndex - b.txIndex;
                  }
                } else {
                  return a.blockNumber - b.blockNumber;
                }
              });
            } else if (this.settings.registryActivityTable.sortOption == 'txorderdsc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return b.logIndex - a.logIndex;
                  } else {
                    return b.txIndex - a.txIndex;
                  }
                } else {
                  return b.blockNumber - a.blockNumber;
                }
              });
            }
            return results;
          },
          pagedFilteredSortedRegistryEntries() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedRegistryEntries - results[0..9]: " + JSON.stringify(this.filteredSortedRegistryEntries.slice(0, 10), null, 2));
            return this.filteredSortedRegistryEntries.slice((this.settings.registryActivityTable.currentPage - 1) * this.settings.registryActivityTable.pageSize, this.settings.registryActivityTable.currentPage * this.settings.registryActivityTable.pageSize);
          },

          totalAddresses() {
            let result = this.forceRefresh % 2 == 0 ? 0 : 0;
            for (const [address, data] of Object.entries(this.addresses)) {
              result++;
            }
            return result;
          },
          filteredAddresses() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            for (const [address, data] of Object.entries(this.addresses)) {
              results.push({ address, ...data });
            }
            return results;
          },
          filteredSortedAddresses() {
            let results = this.filteredAddresses;
            if (this.settings.addressesTable.sortOption == 'typenameasc') {
              results.sort((a, b) => {
                if (('' + a.type).localeCompare(b.type) == 0) {
                  const aname = (a.ensName || '') + (a.name || 'zzz');
                  const bname = (b.ensName || '') + (b.name || 'zzz');
                  if (('' + aname).localeCompare(bname) == 0) {
                    return ('' + a.address).localeCompare(b.address);
                  } else {
                    return ('' + aname).localeCompare(bname);
                  }
                } else {
                  return ('' + b.type).localeCompare(a.type);
                }
              });
            } else if (this.settings.addressesTable.sortOption == 'typenamedsc') {
              results.sort((a, b) => {
                if (('' + a.type).localeCompare(b.type) == 0) {
                  const aname = (a.ensName || '') + (a.name || 'zzz');
                  const bname = (b.ensName || '') + (b.name || 'zzz');
                  if (('' + aname).localeCompare(bname) == 0) {
                    return ('' + b.address).localeCompare(a.address);
                  } else {
                    return ('' + bname).localeCompare(aname);
                  }
                } else {
                  return ('' + a.type).localeCompare(b.type);
                }
              });
            } else if (this.settings.addressesTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                const aname = (a.ensName || '') + (a.name || 'zzz');
                const bname = (b.ensName || '') + (b.name || 'zzz');
                if (('' + aname).localeCompare(bname) == 0) {
                  return ('' + a.address).localeCompare(b.address);
                } else {
                  return ('' + aname).localeCompare(bname);
                }
              });
            } else if (this.settings.addressesTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                const aname = (a.ensName || '') + (a.name || 'zzz');
                const bname = (b.ensName || '') + (b.name || 'zzz');
                if (('' + aname).localeCompare(bname) == 0) {
                  return ('' + b.address).localeCompare(a.address);
                } else {
                  return ('' + bname).localeCompare(aname);
                }
              });
            } else if (this.settings.addressesTable.sortOption == 'addressasc') {
              results.sort((a, b) => {
                return ('' + a.address).localeCompare(b.address);
              });
            } else if (this.settings.addressesTable.sortOption == 'addressdsc') {
              results.sort((a, b) => {
                return ('' + b.address).localeCompare(a.address);
              });
            }
            return results;
          },
          pagedFilteredSortedAddresses() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedAddresses - results[0..9]: " + JSON.stringify(this.filteredSortedAddresses.slice(0, 10), null, 2));
            return this.filteredSortedAddresses.slice((this.settings.addressesTable.currentPage - 1) * this.settings.addressesTable.pageSize, this.settings.addressesTable.currentPage * this.settings.addressesTable.pageSize);
          },

          filteredTokenEvents() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            for (const [contract, contractData] of Object.entries(this.tokenContracts[this.chainId] || {})) {
              let include = true;
              if (this.settings.tokenEventsTable.activeOnly) {
                if (!contractData.active) {
                  include = false;
                }
              }
              if (include) {
                results.push({
                  contract,
                  active: contractData.active,
                  symbol: contractData.symbol,
                  name: contractData.name,
                  type: contractData.type,
                  decimals: contractData.type == "erc20" ? contractData.decimals : undefined,
                  balances: contractData.balances || undefined,
                  totalSupply: contractData.totalSupply || undefined,
                  firstEventBlockNumber: contractData.firstEventBlockNumber || undefined,
                  lastEventBlockNumber: contractData.lastEventBlockNumber || undefined,
                });
              }
            }
            // console.log("filteredTokenEvents - this.tokenEvents: " + JSON.stringify(this.tokenEvents));
            return results;
          },

          filteredSortedTokenEvents() {
            let results = this.filteredTokenEvents;
            if (this.settings.tokenEventsTable.sortOption == 'typenameasc') {
              results.sort((a, b) => {
                if (('' + a.type).localeCompare(b.type) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.address).localeCompare(b.address);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return ('' + a.type).localeCompare(b.type);
                }
              });
            } else if (this.settings.tokenEventsTable.sortOption == 'typenamedsc') {
              results.sort((a, b) => {
                if (('' + a.type).localeCompare(b.type) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + b.address).localeCompare(a.address);
                  } else {
                    return ('' + b.name).localeCompare(a.name);
                  }
                } else {
                  return ('' + b.type).localeCompare(a.type);
                }
              });
            } else if (this.settings.tokenEventsTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + a.address).localeCompare(b.address);
                } else {
                  return ('' + a.name).localeCompare(b.name);
                }
              });
            } else if (this.settings.tokenEventsTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + b.address).localeCompare(a.address);
                } else {
                  return ('' + b.name).localeCompare(a.name);
                }
              });
            } else if (this.settings.tokenEventsTable.sortOption == 'addressasc') {
              results.sort((a, b) => {
                return ('' + a.contract).localeCompare(b.contract);
              });
            } else if (this.settings.tokenEventsTable.sortOption == 'addressdsc') {
              results.sort((a, b) => {
                return ('' + b.contract).localeCompare(a.contract);
              });
            }
            return results;
          },
          pagedFilteredSortedTokenEvents() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedTokenEvents - results[0..9]: " + JSON.stringify(this.pagedFilteredSortedTokenEvents.slice(0, 10), null, 2));
            return this.filteredSortedTokenEvents.slice((this.settings.tokenEventsTable.currentPage - 1) * this.settings.tokenEventsTable.pageSize, this.settings.tokenEventsTable.currentPage * this.settings.tokenEventsTable.pageSize);
          },

          totalContracts() {
            let result = this.forceRefresh % 2 == 0 ? 0 : 0;
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                result++;
              }
            }
            return result;
          },
          filteredContracts() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                const contractTypeSortIndex = this.contractTypeOptions.findIndex(e => e.value == contractData.type);
                results.push({ chainId, contract, ...contractData, contractTypeSortIndex });
              }
            }
            return results;
          },
          filteredSortedContracts() {
            // TODO: Sort options 3 and 4 a bit buggy
            let results = this.filteredContracts;
            if (this.settings.contractsTable.sortOption == 'typenameasc') {
              results.sort((a, b) => {
                if (a.contractTypeSortIndex == b.contractTypeSortIndex) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.contract).localeCompare(b.contract);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return a.contractTypeSortIndex - b.contractTypeSortIndex;
                }
              });
            } else if (this.settings.contractsTable.sortOption == 'typenamedsc') {
              results.sort((a, b) => {
                if (a.contractTypeSortIndex == b.contractTypeSortIndex) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + b.contract).localeCompare(a.contract);
                  } else {
                    return ('' + b.name).localeCompare(a.name);
                  }
                } else {
                  return b.contractTypeSortIndex - a.contractTypeSortIndex;
                }
              });
            } else if (this.settings.contractsTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + a.contract).localeCompare(b.contract);
                } else {
                  return ('' + a.name).localeCompare(b.name);
                }
              });
            } else if (this.settings.contractsTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + b.contract).localeCompare(a.contract);
                } else {
                  return ('' + b.name).localeCompare(a.name);
                }
              });
            }
            return results;
          },
          pagedFilteredSortedContracts() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedContracts - results[0..9]: " + JSON.stringify(this.filteredSortedContracts.slice(0, 10), null, 2));
            return this.filteredSortedContracts.slice((this.settings.activityTable.currentPage - 1) * this.settings.activityTable.pageSize, this.settings.activityTable.currentPage * this.settings.activityTable.pageSize);
          },

        },

        // --- METHODS ---
        methods: {

          async searchForContracts() {
            // Announcement (index_topic_1 uint256 schemeId, index_topic_2 address stealthAddress, index_topic_3 address caller, bytes ephemeralPublicKey, bytes metadata)
            // 0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7
            // Note: Following is ERC-6538: Stealth Meta-Address Registry with registrant being bytes32 instead of bytes
            // StealthMetaAddressSet (index_topic_1 bytes32 registrant, index_topic_2 uint256 scheme, bytes stealthMetaAddress)
            // 0x0bb4b5456abb9a4e7e0624d821e95e2fcc8a761c9227b5d761ae0da4a3fda233
            console.log(moment().format("HH:mm:ss") + " searchForContracts");
            const contractsMap = {};
            let total = 0;
            function processLogs(fromBlock, toBlock, logs) {
              total = parseInt(total) + logs.length;
              console.log(moment().format("HH:mm:ss") + " searchForContracts.processLogs: " + fromBlock + " - " + toBlock + " " + logs.length + " " + total);
              for (const event of logs) {
                if (!event.removed) {
                  if (event.topics[0] == "0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7") {
                    const caller = ethers.utils.getAddress("0x" + event.topics[3].substring(26, 66));
                    if (!(event.address in contractsMap)) {
                      contractsMap[event.address] = { type: "announcer", blockNumber: event.blockNumber };
                    }
                    if (!(caller in contractsMap)) {
                      contractsMap[caller] = { type: "caller", blockNumber: event.blockNumber };
                    }
                  } else {
                    if (!(event.address in contractsMap)) {
                      contractsMap[event.address] = { type: "registry", blockNumber: event.blockNumber };
                    }
                  }
                }
              }
            }
            async function getLogs(fromBlock, toBlock, processLogs) {
              try {
                const filter = {
                  address: null,
                  fromBlock,
                  toBlock,
                  topics: [
                    ['0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7', '0x0bb4b5456abb9a4e7e0624d821e95e2fcc8a761c9227b5d761ae0da4a3fda233'],
                    null,
                    null
                  ]
                };
                const eventLogs = await provider.getLogs(filter);
                processLogs(fromBlock, toBlock, eventLogs);
              } catch (e) {
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogs(fromBlock, mid, processLogs);
                await getLogs(parseInt(mid) + 1, toBlock, processLogs);
              }
            }
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            this.coinbase = await signer.getAddress();
            localStorage.stealthChadCoinbase = this.coinbase;
            const network = await provider.getNetwork();
            localStorage.stealthChadChainId = network.chainId;
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            console.log(moment().format("HH:mm:ss") + " searchForContracts - latestBlockNumber: " + latestBlockNumber + ", chainId: " + this.chainId);
            const startBlock = 0;
            await getLogs(startBlock, latestBlockNumber, processLogs);
            const contracts = this.contracts;
            if (!(this.chainId in contracts)) {
              contracts[this.chainId] = {};
            }
            for (const [contract, data] of Object.entries(contractsMap)) {
              const type = data.type;
              const blockNumber = data.blockNumber;
              const timestamp = (await provider.getBlock(blockNumber)).timestamp
              const customData = CUSTOMNAMES[contract] || {};
              contracts[this.chainId][contract] = { type, name: customData.name || null, read: customData.read || false, write: customData.write || false, blockNumber, timestamp };
            }
            Vue.set(this, 'contracts', contracts);
            localStorage.stealthChadContracts = JSON.stringify(this.contracts);
          },

          saveModalContractName() {
            console.log(moment().format("HH:mm:ss") + " saveModalContractName: " + JSON.stringify(this.modalContract));
            this.modalContract.item.name = this.modalContract.name;
            Vue.set(this.contracts[this.modalContract.item.chainId][this.modalContract.item.contract], 'name', this.modalContract.name);
            localStorage.stealthChadContracts = JSON.stringify(this.contracts);
            Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
          },

          saveModalAddressName() {
            console.log(moment().format("HH:mm:ss") + " saveModalAddressName: " + JSON.stringify(this.modalAddress));
            this.modalAddress.item.name = this.modalAddress.name;
            Vue.set(this.addresses[this.modalAddress.item.address], 'name', this.modalAddress.name);
            localStorage.stealthChadAddresses = JSON.stringify(this.addresses);
            Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
          },

          toggleModalAddressMine() {
            console.log(moment().format("HH:mm:ss") + " toggleModalAddressMine: " + JSON.stringify(this.modalAddress));
            this.modalAddress.item.mine = !this.modalAddress.item.mine;
            Vue.set(this.addresses[this.modalAddress.item.address], 'mine', this.modalAddress.item.mine);
            Vue.set(this.addresses, this.modalAddress.item.address, this.addresses[this.modalAddress.item.address]);
            Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
            localStorage.stealthChadAddresses = JSON.stringify(this.addresses);
          },

          toggleContractRead(item) {
            if (this.modalContract.item && this.modalContract.item.chainId && this.modalContract.item.contract) {
              Vue.set(this.contracts[this.modalContract.item.chainId][this.modalContract.item.contract], 'read', !this.modalContract.read);
              Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
              localStorage.stealthChadContracts = JSON.stringify(this.contracts);
            }
          },
          toggleContractWrite(item) {
            if (this.modalContract.item && this.modalContract.item.chainId && this.modalContract.item.contract) {
              Vue.set(this.contracts[this.modalContract.item.chainId][this.modalContract.item.contract], 'write', !this.modalContract.write);
              Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
              localStorage.stealthChadContracts = JSON.stringify(this.contracts);
            }
          },
          toggleTokenContractActive(item) {
            if (item && item.contract) {
              Vue.set(this.tokenContracts[this.chainId][item.contract], 'active', !this.tokenContracts[this.chainId][item.contract].active);
              Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
              localStorage.stealthChadTokenContracts = JSON.stringify(this.tokenContracts);
            }
          },
          transfer(stealthMetaAddress) {
            console.log(moment().format("HH:mm:ss") + " transfer: " + stealthMetaAddress);
            this.modalTransfer.stealthMetaAddress = stealthMetaAddress;
            this.modalTransfer.amount = null;
            this.$bvModal.show('modal-transfertostealthmetaaddress');
          },

          newStealthMetaAddress() {
            console.log(moment().format("HH:mm:ss") + " newStealthMetaAddress");
            this.modalNewStealthMetaAddress.name = null;
            this.modalNewStealthMetaAddress.linkedTo = this.coinbase;
            this.modalNewStealthMetaAddress.phrase = this.defaultPhrase;
            this.modalNewStealthMetaAddress.viewingPrivateKey = null;
            this.modalNewStealthMetaAddress.spendingPublicKey = null;
            this.modalNewStealthMetaAddress.viewingPublicKey = null;
            this.modalNewStealthMetaAddress.stealthMetaAddress = null;
            this.modalNewStealthMetaAddress.status = null;
            this.$bvModal.show('modal-newstealthmetaaddress');
          },

          async generateNewStealthMetaAddress() {
            console.log(moment().format("HH:mm:ss") + " generateNewStealthMetaAddress - phrase: " + this.modalNewStealthMetaAddress.phrase);
            const phraseInHex = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(this.modalNewStealthMetaAddress.phrase));
            const signature = await ethereum.request({
              method: 'personal_sign',
              params: [phraseInHex, this.coinbase],
            });
            const signature1 = signature.slice(2, 66);
            const signature2 = signature.slice(66, 130);
            // Hash "v" and "r" values using SHA-256
            const hashedV = ethers.utils.sha256("0x" + signature1);
            const hashedR = ethers.utils.sha256("0x" + signature2);
            const n = ethers.BigNumber.from(SECP256K1_N);
            // Calculate the private keys by taking the hash values modulo the curve order
            const privateKey1 = ethers.BigNumber.from(hashedV).mod(n);
            const privateKey2 = ethers.BigNumber.from(hashedR).mod(n);
            const keyPair1 = new ethers.Wallet(privateKey1.toHexString());
            const keyPair2 = new ethers.Wallet(privateKey2.toHexString());
            Vue.set(this.modalNewStealthMetaAddress, 'viewingPrivateKey', keyPair2.privateKey);
            const spendingPublicKey = ethers.utils.computePublicKey(keyPair1.privateKey, true);
            const viewingPublicKey = ethers.utils.computePublicKey(keyPair2.privateKey, true);
            const stealthMetaAddress = "st:eth:" + spendingPublicKey + viewingPublicKey.substring(2);
            Vue.set(this.modalNewStealthMetaAddress, 'spendingPublicKey', spendingPublicKey);
            Vue.set(this.modalNewStealthMetaAddress, 'viewingPublicKey', viewingPublicKey);
            Vue.set(this.modalNewStealthMetaAddress, 'stealthMetaAddress', stealthMetaAddress);
            Vue.set(this.modalNewStealthMetaAddress, 'linkedTo', this.coinbase);
            let status;
            if (stealthMetaAddress in this.addresses) {
              status = this.addresses[stealthMetaAddress].mine ? "mine" : "notmine";
            } else {
              status = "doesnotexist";
            }
            Vue.set(this.modalNewStealthMetaAddress, 'status', status);
            console.log("this.modalNewStealthMetaAddress: " + JSON.stringify(this.modalNewStealthMetaAddress, null, 2));
          },

          async revealModalActivitySpendingPrivateKey() {
            function computeStealthKey(ephemeralPublicKey, viewingPrivateKey, spendingPrivateKey) {
              const result = {};
              result.sharedSecret = nobleCurves.secp256k1.getSharedSecret(viewingPrivateKey.substring(2), ephemeralPublicKey.substring(2), false);
              result.hashedSharedSecret = ethers.utils.keccak256(result.sharedSecret.slice(1));
              const stealthPrivateKeyNumber = (BigInt(spendingPrivateKey) + BigInt(result.hashedSharedSecret)) % BigInt(SECP256K1_N);
              const stealthPrivateKeyString = stealthPrivateKeyNumber.toString(16);
              result.stealthPrivateKey = "0x" + stealthPrivateKeyString.padStart(64, '0');
              result.stealthPublicKey = "0x" +  nobleCurves.secp256k1.ProjectivePoint.fromPrivateKey(stealthPrivateKeyNumber).toHex(false);
              result.stealthAddress = ethers.utils.computeAddress(result.stealthPublicKey);
              return result;
            }

            console.log(moment().format("HH:mm:ss") + " revealModalActivitySpendingPrivateKey - modalActivity: " + JSON.stringify(this.modalActivity, null, 2));
            const stealthMetaAddressData = this.addresses[this.modalActivity.item.linkedTo.stealthMetaAddress];
            console.log(moment().format("HH:mm:ss") + " revealModalActivitySpendingPrivateKey - stealthMetaAddressData: " + JSON.stringify(stealthMetaAddressData, null, 2));
            const phraseInHex = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(stealthMetaAddressData.phrase));
            const signature = await ethereum.request({
              method: 'personal_sign',
              params: [phraseInHex, this.coinbase],
            });
            const signature1 = signature.slice(2, 66);
            const signature2 = signature.slice(66, 130);
            // Hash "v" and "r" values using SHA-256
            const hashedV = ethers.utils.sha256("0x" + signature1);
            const hashedR = ethers.utils.sha256("0x" + signature2);
            const n = ethers.BigNumber.from(SECP256K1_N);
            // Calculate the private keys by taking the hash values modulo the curve order
            const privateKey1 = ethers.BigNumber.from(hashedV).mod(n);
            const privateKey2 = ethers.BigNumber.from(hashedR).mod(n);
            const keyPair1 = new ethers.Wallet(privateKey1.toHexString());
            const keyPair2 = new ethers.Wallet(privateKey2.toHexString());
            const spendingPrivateKey = keyPair1.privateKey;
            const viewingPrivateKey = keyPair2.privateKey;
            const spendingPublicKey = ethers.utils.computePublicKey(keyPair1.privateKey, true);
            const viewingPublicKey = ethers.utils.computePublicKey(keyPair2.privateKey, true);
            // const stealthMetaAddress = "st:eth:" + spendingPublicKey + viewingPublicKey.substring(2);
            console.log(moment().format("HH:mm:ss") + " revealModalActivitySpendingPrivateKey - spendingPrivateKey: " + spendingPrivateKey);
            const computedStealthKey = computeStealthKey(this.modalActivity.item.ephemeralPublicKey, viewingPrivateKey, spendingPrivateKey);
            const stealthPrivateKey = computedStealthKey.stealthPrivateKey;
            Vue.set(this.modalActivity, 'stealthPrivateKey', stealthPrivateKey);
            console.log("this.modalActivity: " + JSON.stringify(this.modalActivity, null, 2));
          },

          async revealModalAddressSpendingPrivateKey() {
            console.log(moment().format("HH:mm:ss") + " revealModalAddressSpendingPrivateKey - phrase: " + this.modalAddress.item.phrase);
            const phraseInHex = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(this.modalAddress.item.phrase));
            const signature = await ethereum.request({
              method: 'personal_sign',
              params: [phraseInHex, this.coinbase],
            });
            const signature1 = signature.slice(2, 66);
            const signature2 = signature.slice(66, 130);
            // Hash "v" and "r" values using SHA-256
            const hashedV = ethers.utils.sha256("0x" + signature1);
            const hashedR = ethers.utils.sha256("0x" + signature2);
            const n = ethers.BigNumber.from(SECP256K1_N);
            // Calculate the private keys by taking the hash values modulo the curve order
            const privateKey1 = ethers.BigNumber.from(hashedV).mod(n);
            const privateKey2 = ethers.BigNumber.from(hashedR).mod(n);
            const keyPair1 = new ethers.Wallet(privateKey1.toHexString());
            const keyPair2 = new ethers.Wallet(privateKey2.toHexString());
            Vue.set(this.modalAddress, 'spendingPrivateKey', keyPair1.privateKey);
            const spendingPublicKey = ethers.utils.computePublicKey(keyPair1.privateKey, true);
            const viewingPublicKey = ethers.utils.computePublicKey(keyPair2.privateKey, true);
            const stealthMetaAddress = "st:eth:" + spendingPublicKey + viewingPublicKey.substring(2);
          },

          addStealthMetaAddressToAddresses() {
            console.log(moment().format("HH:mm:ss") + " addStealthMetaAddressToAddresses");
            const account = this.addresses[this.modalNewStealthMetaAddress.stealthMetaAddress];
            if (account) {
              account.type = "stealthMetaAddress";
              account.name = this.modalNewStealthMetaAddress.name;
              account.linkedTo = this.modalNewStealthMetaAddress.linkedTo;
              account.phrase = this.modalNewStealthMetaAddress.phrase;
              account.viewingPrivateKey = this.modalNewStealthMetaAddress.viewingPrivateKey;
              account.spendingPublicKey = this.modalNewStealthMetaAddress.spendingPublicKey;
              account.viewingPublicKey = this.modalNewStealthMetaAddress.viewingPublicKey;
              account.mine = true;
              Vue.set(this.addresses, this.modalNewStealthMetaAddress.stealthMetaAddress, account);
            } else {
              Vue.set(this.addresses, this.modalNewStealthMetaAddress.stealthMetaAddress, {
                type: "stealthMetaAddress",
                name: this.modalNewStealthMetaAddress.name,
                linkedTo: this.modalNewStealthMetaAddress.linkedTo,
                phrase: this.modalNewStealthMetaAddress.phrase,
                viewingPrivateKey: this.modalNewStealthMetaAddress.viewingPrivateKey,
                spendingPublicKey: this.modalNewStealthMetaAddress.spendingPublicKey,
                viewingPublicKey: this.modalNewStealthMetaAddress.viewingPublicKey,
                mine: true,
                source: "user.signed",
              });
            }
            Vue.set(this.addresses, this.modalNewStealthMetaAddress.stealthMetaAddress, this.addresses[this.modalNewStealthMetaAddress.stealthMetaAddress]);
            Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
            localStorage.stealthChadAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " addStealthMetaAddressToAddresses - addresses: " + JSON.stringify(this.addresses, null, 2));
          },

          // async registerKey() {
          //   // TODO: Register keys
          //   console.log(moment().format("HH:mm:ss") + " registerKey BEGIN");
          //   const provider = new ethers.providers.Web3Provider(window.ethereum);
          //   const contract = new ethers.Contract(ERC5564REGISTRYADDRESS_SEPOLIA, ERC5564REGISTRYABI_SEPOLIA, provider);
          //   const contractWithSigner = contract.connect(provider.getSigner());
          //   const schemeId = 0;
          //   try {
          //     const stealthMetaAddress = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(this.settings.stealthMetaAddress.stealthMetaAddress));
          //     const tx = await contractWithSigner.registerKeys(schemeId, stealthMetaAddress);
          //     console.log("tx: " + JSON.stringify(tx));
          //   } catch (e) {
          //     console.log("registerKey ERC5564Registry.registerKeys(...) error: " + JSON.stringify(e));
          //   }
          //   console.log(moment().format("HH:mm:ss") + " registerKey END");
          // },

          async transferEthToStealthMetaAddress() {
            function generateStealthAddress(stealthMetaAddress) {
                const result = {};
                result.stealthMetaAddress = stealthMetaAddress;
                result.receiverSpendingPublicKey = stealthMetaAddress.slice(9, 75);
                result.receiverViewingPublicKey = stealthMetaAddress.slice(75);
                result.ephemeralPrivateKey = nobleCurves.secp256k1.utils.randomPrivateKey();
                // // TODO: Remove after testing
                // result.ephemeralPrivateKey = 26997109008263982877621605952415166666118239613620770339187915977330619367704n;
                result.ephemeralPublicKey = nobleCurves.secp256k1.getPublicKey(result.ephemeralPrivateKey, isCompressed=true);
                result.sharedSecret = nobleCurves.secp256k1.getSharedSecret(result.ephemeralPrivateKey, result.receiverViewingPublicKey, false);
                result.hashedSharedSecret = ethers.utils.keccak256(result.sharedSecret.slice(1));
                result.viewTag = "0x" + result.hashedSharedSecret.substring(2, 4);
                result.hashedSharedSecretPoint = nobleCurves.secp256k1.ProjectivePoint.fromPrivateKey(result.hashedSharedSecret.substring(2));
                result.stealthPublicKey = nobleCurves.secp256k1.ProjectivePoint.fromHex(result.receiverSpendingPublicKey).add(result.hashedSharedSecretPoint);
                result.stealthAddress = ethers.utils.computeAddress("0x" + result.stealthPublicKey.toHex(false));
                return result;
            }
            console.log(moment().format("HH:mm:ss") + " transferEthToStealthMetaAddress BEGIN");
            const result = generateStealthAddress(this.modalTransfer.stealthMetaAddress);
            for (const [k, v] of Object.entries(result)) {
              console.log("    ", k, "=>", v);
            }

            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const contract = new ethers.Contract(STEALTHCHADADDRESS_SEPOLIA, STEALTHCHADABI_SEPOLIA, provider);
            const contractWithSigner = contract.connect(provider.getSigner());
            const schemeId = 0;
            const value = ethers.utils.parseEther(this.modalTransfer.amount);
            try {
              const tx = await contractWithSigner.transferEthAndAnnounce(schemeId, result.stealthAddress, result.ephemeralPublicKey, result.viewTag, { value });
              console.log("tx: " + JSON.stringify(tx));
            } catch (e) {
              console.log("transferEthToStealthMetaAddress StealthChad.transferEthAndAnnounce(...) error: " + JSON.stringify(e));
            }
            console.log(moment().format("HH:mm:ss") + " transferEthToStealthMetaAddress END");
          },

          activityRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " activityRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              this.modalActivity.item = item[0];
              this.modalActivity.stealthPrivateKey = null;
              this.$bvModal.show('modal-activity');
              this.$refs.activityTable.clearSelected();
            }
          },

          registryRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " registryRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              this.modalRegistry.item = item[0];
              this.$bvModal.show('modal-registry');
              this.$refs.registryTable.clearSelected();
            }
          },

          addressesRowSelected(item) {
            // console.log(moment().format("HH:mm:ss") + " addressesRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              const address = item[0].address;
              const addressData = this.addresses[address];
              this.modalAddress.item = { address, ...addressData };
              this.modalAddress.name = addressData.name;
              this.modalAddress.spendingPrivateKey = null;
              // console.log(moment().format("HH:mm:ss") + " addressesRowSelected - modalAddress: " + JSON.stringify(this.modalAddress, null, 2));
              this.$bvModal.show('modal-address');
              this.$refs.addressesTable.clearSelected();
            }
          },

          viewAddress(address) {
            // console.log(moment().format("HH:mm:ss") + " viewAddress: " + JSON.stringify(address, null, 2));
            if (address && address.length > 0) {
              const addressData = this.addresses[address];
              this.modalAddress.item = { address, ...addressData };
              this.modalAddress.name = addressData.name;
              this.$bvModal.show('modal-address');
            }
          },

          contractRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " contractRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              this.modalContract.item = item[0];
              this.modalContract.name = item[0] && item[0].name || null;
              this.modalContract.read = item[0] && item[0].read || false;
              this.modalContract.write = item[0] && item[0].write || false;
              this.$bvModal.show('modal-contract');
              this.$refs.contractsTable.clearSelected();
            }
          },

          async syncIt(devMode) {
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            this.coinbase = await signer.getAddress();
            localStorage.stealthChadCoinbase = this.coinbase;
            const network = await provider.getNetwork();
            localStorage.stealthChadChainId = network.chainId;
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            console.log(moment().format("HH:mm:ss") + " syncIt - latestBlockNumber: " + latestBlockNumber + ", chainId: " + this.chainId);
            if (!devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncAnnouncements(db, provider, latestBlockNumber);
            }
            if (!devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncRegistryEvents(db, provider, latestBlockNumber);
            }
            if (!devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncAnnouncementsData(db, provider, latestBlockNumber);
            }
            if (!devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncRegistryEventsData(db, provider, latestBlockNumber);
            }
            if (!devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.collateAccounts(db, provider, latestBlockNumber);
            }
            if (network.chainId == CHAINID_SEPOLIA) {
              await this.syncTokenEvents(db, provider, latestBlockNumber);
            }
            // if (network.chainId == CHAINID_SEPOLIA) {
            //   await this.syncTokenEventsData(db, provider, latestBlockNumber);
            // }
            // if (false && network.chainId == CHAINID_MAINNET) {
            //   // TODO: Handle large volumes of data by indexing addresses and moving LocalStorage items -> IndexedDB
            //   await this.syncTokenEventsDataMainnet(db, provider, latestBlockNumber);
            // }
            if (network.chainId == CHAINID_SEPOLIA) {
              await this.collateTokens(db, provider, latestBlockNumber);
            }
            if (!devMode && network.chainId == CHAINID_MAINNET) {
              await this.syncENSNames(provider);
            }
            if (!devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.processData(db, provider, latestBlockNumber);
            }
            await this.loadCurrentData();
            this.forceRefresh++; // UI refresh workaround
            this.sync.section = null;
            this.sync.halt = false;
            db.close();
          },

          async syncAnnouncements(db, provider, latestBlockNumber) {
            // Announcement (index_topic_1 uint256 schemeId, index_topic_2 address stealthAddress, index_topic_3 address caller, bytes ephemeralPublicKey, bytes metadata)
            // 0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7
            const erc5564AnnouncerContract = new ethers.Contract(ERC5564ANNOUNCERADDRESS_SEPOLIA, ERC5564ANNOUNCERABI_SEPOLIA, provider);
            let total = 0;
            let t = this;
            async function processLogs(fromBlock, toBlock, selectedContracts, selectedCallers, logs) {
              total = parseInt(total) + logs.length;
              console.log(moment().format("HH:mm:ss") + " syncAnnouncements.processLogs: " + fromBlock + " - " + toBlock + " " + logs.length + " " + total);
              const records = [];
              for (const log of logs) {
                if (!log.removed) {
                  const logData = erc5564AnnouncerContract.interface.parseLog(log);
                  const contract = log.address;
                  const caller = logData.args[2];
                  if (selectedContracts.includes(contract) && selectedCallers.includes(caller)) {
                    const transfers = [];
                    const metadata = logData.args[4];
                    const functionSelector = metadata.substring(4, 12);
                    const tokenContractAddress = metadata.substring(12, 52);
                    const tokensString = metadata.substring(52, 116)
                    const tokens = ethers.BigNumber.from("0x" + tokensString).toString();
                    // TODO: Handle ERC-20 & ERC-721 transfers
                    transfers.push({ functionSelector, tokenContractAddress, tokens });
                    records.push( {
                      chainId: t.chainId,
                      blockNumber: parseInt(log.blockNumber),
                      logIndex: parseInt(log.logIndex),
                      txIndex: parseInt(log.transactionIndex),
                      txHash: log.transactionHash,
                      contract,
                      name: logData.name,
                      schemeId: parseInt(logData.args[0]),
                      stealthAddress: logData.args[1],
                      linkedTo: {
                        stealthMetaAddress: null,
                        address: null,
                      },
                      mine: false,
                      caller,
                      ephemeralPublicKey: logData.args[3],
                      metadata: logData.args[4],
                      transfers,
                      confirmations: latestBlockNumber - log.blockNumber,
                      timestamp: null,
                      tx: null,
                    });
                  }
                }
              }
              // console.log("records: " + JSON.stringify(records, null, 2));
              if (records.length) {
                await db.announcements.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncAnnouncements.bulkPut error: " + error);
                });
              }
            }
            async function getLogs(fromBlock, toBlock, selectedContracts, selectedCallers, processLogs) {
              console.log(moment().format("HH:mm:ss") + " syncAnnouncements.getLogs: " + fromBlock + " - " + toBlock);
              try {
                const filter = {
                  address: null,
                  fromBlock,
                  toBlock,
                  topics: [
                    '0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7',
                    null,
                    null
                  ]
                };
                const eventLogs = await provider.getLogs(filter);
                await processLogs(fromBlock, toBlock, selectedContracts, selectedCallers, eventLogs);
              } catch (e) {
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogs(fromBlock, mid, selectedContracts, selectedCallers, processLogs);
                await getLogs(parseInt(mid) + 1, toBlock, selectedContracts, selectedCallers, processLogs);
              }
            }
            console.log(moment().format("HH:mm:ss") + " syncAnnouncements BEGIN");
            this.sync.completed = 0;
            this.sync.total = 0;
            this.sync.section = 'Stealth Address Announcements';
            const selectedContracts = [];
            const selectedCallers = [];
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                if (contractData.type == "announcer" && contractData.read) {
                  selectedContracts.push(contract);
                }
                if (contractData.type == "caller" && contractData.read) {
                  selectedCallers.push(contract);
                }
              }
            }
            if (selectedContracts.length > 0) {
              const deleteCall = await db.announcements.where("confirmations").below(this.CONFIRMATIONS).delete();
              const latest = await db.announcements.where('[chainId+blockNumber+logIndex]').between([this.chainId, Dexie.minKey, Dexie.minKey],[this.chainId, Dexie.maxKey, Dexie.maxKey]).last();
              const startBlock = latest ? parseInt(latest.blockNumber) + 1: 0;
              await getLogs(startBlock, latestBlockNumber, selectedContracts, selectedCallers, processLogs);
            }
            console.log(moment().format("HH:mm:ss") + " syncAnnouncements END");
          },

          async syncRegistryEvents(db, provider, latestBlockNumber) {
            // Note: Following is ERC-6538: Stealth Meta-Address Registry with registrant being bytes32 instead of bytes
            // StealthMetaAddressSet (index_topic_1 bytes32 registrant, index_topic_2 uint256 scheme, bytes stealthMetaAddress)
            // 0x0bb4b5456abb9a4e7e0624d821e95e2fcc8a761c9227b5d761ae0da4a3fda233
            const erc5564RegistryContract = new ethers.Contract(ERC5564REGISTRYADDRESS_SEPOLIA, ERC5564REGISTRYABI_SEPOLIA, provider);
            let total = 0;
            let t = this;
            async function processLogs(fromBlock, toBlock, selectedContracts, logs) {
              total = parseInt(total) + logs.length;
              console.log(moment().format("HH:mm:ss") + " syncRegistryEvents.processLogs: " + fromBlock + " - " + toBlock + " " + logs.length + " " + total);
              const records = [];
              for (const log of logs) {
                if (!log.removed) {
                  const logData = erc5564RegistryContract.interface.parseLog(log);
                  const contract = log.address;
                  if (selectedContracts.includes(contract)) {
                    records.push( {
                      chainId: t.chainId,
                      blockNumber: parseInt(log.blockNumber),
                      logIndex: parseInt(log.logIndex),
                      txIndex: parseInt(log.transactionIndex),
                      txHash: log.transactionHash,
                      contract,
                      name: logData.name,
                      registrant: ethers.utils.getAddress("0x" + logData.args[0].substring(26, 66)),
                      schemeId: parseInt(logData.args[1]),
                      stealthMetaAddress: ethers.utils.toUtf8String(logData.args[2]),
                      mine: false,
                      confirmations: latestBlockNumber - log.blockNumber,
                      timestamp: null,
                      tx: null,
                    });
                  }
                }
              }
              // console.log("records: " + JSON.stringify(records, null, 2));
              if (records.length) {
                await db.registryEntries.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncRegistryEvents.bulkPut error: " + error);
                });
              }
            }
            async function getLogs(fromBlock, toBlock, selectedContracts, processLogs) {
              console.log(moment().format("HH:mm:ss") + " syncRegistryEvents.getLogs: " + fromBlock + " - " + toBlock);
              try {
                const filter = {
                  address: null,
                  fromBlock,
                  toBlock,
                  topics: [
                    '0x0bb4b5456abb9a4e7e0624d821e95e2fcc8a761c9227b5d761ae0da4a3fda233',
                    null,
                    null
                  ]
                };
                const eventLogs = await provider.getLogs(filter);
                await processLogs(fromBlock, toBlock, selectedContracts, eventLogs);
              } catch (e) {
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogs(fromBlock, mid, selectedContracts, processLogs);
                await getLogs(parseInt(mid) + 1, toBlock, selectedContracts, processLogs);
              }
            }
            console.log(moment().format("HH:mm:ss") + " syncRegistryEvents BEGIN");
            this.sync.completed = 0;
            this.sync.total = 0;
            this.sync.section = 'Stealth Address Registry';
            const selectedContracts = [];
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                if (contractData.type == "registry" && contractData.read) {
                  selectedContracts.push(contract);
                }
              }
            }
            if (selectedContracts.length > 0) {
              const deleteCall = await db.registryEntries.where("confirmations").below(this.CONFIRMATIONS).delete();
              const latest = await db.registryEntries.where('[chainId+blockNumber+logIndex]').between([this.chainId, Dexie.minKey, Dexie.minKey],[this.chainId, Dexie.maxKey, Dexie.maxKey]).last();
              const startBlock = latest ? parseInt(latest.blockNumber) + 1: 0;
              await getLogs(startBlock, latestBlockNumber, selectedContracts, processLogs);
            }
            console.log(moment().format("HH:mm:ss") + " syncRegistryEvents END");
          },

          async syncAnnouncementsData(db, provider, latestBlockNumber) {
            console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData BEGIN");
            let rows = 0;
            let done = false;
            do {
              let data = await db.announcements.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            // console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData - total: " + total);
            this.sync.completed = 0;
            this.sync.total = rows;
            this.sync.section = 'Announcements Tx Data';
            rows = 0;
            do {
              let data = await db.announcements.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              const records = [];
              for (const item of data) {
                // console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData: " + JSON.stringify(item));
                if (item.timestamp == null && item.chainId == this.chainId) {
                  const block = await provider.getBlock(item.blockNumber);
                  item.timestamp = block.timestamp;
                  const tx = await provider.getTransaction(item.txHash);
                  const txReceipt = await provider.getTransactionReceipt(item.txHash);
                  item.tx = {
                    type: tx.type,
                    blockHash: tx.blockHash,
                    from: tx.from,
                    gasPrice: ethers.BigNumber.from(tx.gasPrice).toString(),
                    gasLimit: ethers.BigNumber.from(tx.gasLimit).toString(),
                    to: tx.to,
                    value: ethers.BigNumber.from(tx.value).toString(),
                    nonce: tx.nonce,
                    data: tx.to && tx.data || null, // Remove contract creation data to reduce memory footprint
                    chainId: tx.chainId,
                    contractAddress: txReceipt.contractAddress,
                    transactionIndex: txReceipt.transactionIndex,
                    gasUsed: ethers.BigNumber.from(txReceipt.gasUsed).toString(),
                    blockHash: txReceipt.blockHash,
                    logs: txReceipt.logs,
                    cumulativeGasUsed: ethers.BigNumber.from(txReceipt.cumulativeGasUsed).toString(),
                    effectiveGasPrice: ethers.BigNumber.from(txReceipt.effectiveGasPrice).toString(),
                    status: txReceipt.status,
                    type: txReceipt.type,
                  };
                  records.push(item);
                }
              }
              if (records.length > 0) {
                await db.announcements.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncAnnouncementsData.bulkPut error: " + error);
                });
              }
              rows = parseInt(rows) + data.length;
              this.sync.completed = rows;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
          },

          async syncRegistryEventsData(db, provider, latestBlockNumber) {
            console.log(moment().format("HH:mm:ss") + " syncRegistryEventsData BEGIN");
            let rows = 0;
            let done = false;
            do {
              let data = await db.registryEntries.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncRegistryEventsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            // console.log(moment().format("HH:mm:ss") + " syncRegistryEventsData - total: " + total);
            this.sync.completed = 0;
            this.sync.total = rows;
            this.sync.section = 'Registry Entries Tx Data';
            rows = 0;
            do {
              let data = await db.registryEntries.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncRegistryEventsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              const records = [];
              for (const item of data) {
                // console.log(moment().format("HH:mm:ss") + " syncRegistryEventsData: " + JSON.stringify(item));
                if (item.timestamp == null && item.chainId == this.chainId) {
                  const block = await provider.getBlock(item.blockNumber);
                  item.timestamp = block.timestamp;
                  const tx = await provider.getTransaction(item.txHash);
                  const txReceipt = await provider.getTransactionReceipt(item.txHash);
                  item.tx = {
                    type: tx.type,
                    blockHash: tx.blockHash,
                    from: tx.from,
                    gasPrice: ethers.BigNumber.from(tx.gasPrice).toString(),
                    gasLimit: ethers.BigNumber.from(tx.gasLimit).toString(),
                    to: tx.to,
                    value: ethers.BigNumber.from(tx.value).toString(),
                    nonce: tx.nonce,
                    data: tx.to && tx.data || null, // Remove contract creation data to reduce memory footprint
                    chainId: tx.chainId,
                    contractAddress: txReceipt.contractAddress,
                    transactionIndex: txReceipt.transactionIndex,
                    gasUsed: ethers.BigNumber.from(txReceipt.gasUsed).toString(),
                    blockHash: txReceipt.blockHash,
                    logs: txReceipt.logs,
                    cumulativeGasUsed: ethers.BigNumber.from(txReceipt.cumulativeGasUsed).toString(),
                    effectiveGasPrice: ethers.BigNumber.from(txReceipt.effectiveGasPrice).toString(),
                    status: txReceipt.status,
                    type: txReceipt.type,
                  };
                  records.push(item);
                }
              }
              if (records.length > 0) {
                await db.registryEntries.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncRegistryEventsData.bulkPut error: " + error);
                });
              }
              rows = parseInt(rows) + data.length;
              this.sync.completed = rows;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
          },

          async collateAccounts(db, provider, latestBlockNumber) {
            console.log(moment().format("HH:mm:ss") + " collateAccounts BEGIN");
            const accounts = this.addresses;
            if (!(this.coinbase in accounts)) {
              accounts[this.coinbase] = { type: "address", source: "attached", mine: true, name: null };
            }
            let rows = 0;
            let done = false;
            do {
              let data = await db.announcements.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " collateAccounts - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              for (const item of data) {
                if (!(item.contract in accounts)) {
                  const name = CUSTOMNAMES[item.contract] && CUSTOMNAMES[item.contract].name || null;
                  accounts[item.contract] = { type: "address", source: "announcer.contract", mine: false, name };
                }
                if (!(item.stealthAddress in accounts)) {
                  accounts[item.stealthAddress] = { type: "address", source: "announcer.stealthAddress", mine: false, name: null };
                }
                if (!(item.caller in accounts)) {
                  const name = CUSTOMNAMES[item.caller] && CUSTOMNAMES[item.caller].name || null;
                  accounts[item.caller] = { type: "address", source: "announcer.caller", mine: false, name };
                }
                if (!(item.tx.from in accounts)) {
                  accounts[item.tx.from] = { type: "address", source: "announcer.sender", mine: item.tx.from == this.coinbase, name: null };
                }
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            rows = 0;

            done = false;
            do {
              let data = await db.registryEntries.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " collateAccounts - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              for (const item of data) {
                if (!(item.contract in accounts)) {
                  const name = CUSTOMNAMES[item.contract] && CUSTOMNAMES[item.contract].name || null;
                  accounts[item.contract] = { type: "address", source: "registry.contract", mine: false, name };
                }
                if (!(item.registrant in accounts)) {
                  accounts[item.registrant] = { type: "address", source: "registry.registrant", mine: false, name: null };
                }
                if (!(item.stealthMetaAddress in accounts)) {
                  accounts[item.stealthMetaAddress] = { type: "stealthMetaAddress", source: "registry.stealthMetaAddress", linkedTo: item.registrant, mine: false };
                }
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);

            for (const [address, accountData] of Object.entries(accounts)) {
              if (accountData.type == "stealthMetaAddress") {
                const linkedToData = accountData.linkedTo && accounts[accountData.linkedTo] || null;
                if (linkedToData && linkedToData.mine) {
                  accounts[address].mine = true;
                }
              }
            }

            Vue.set(this, 'accounts', accounts);
            localStorage.stealthChadAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " collateAccounts - addresses: " + JSON.stringify(accounts, null, 2));
            console.log(moment().format("HH:mm:ss") + " collateAccounts END");
          },

          async syncTokenEvents(db, provider, latestBlockNumber) {
            // ERC-20 & ERC-721 Transfer (index_topic_1 address from, index_topic_2 address to, index_topic_3 uint256 id)
            // [ '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', accountAs32Bytes, null ],
            // [ '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', null, accountAs32Bytes ],

            // WETH Deposit (index_topic_1 address dst, uint256 wad)
            // 0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c
            // WETH Withdrawal (index_topic_1 address src, uint256 wad)
            // 0x7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65

            // // ERC-20 Approval (index_topic_1 address owner, index_topic_2 address spender, uint256 value)
            // // 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
            // // ERC-721 Approval (index_topic_1 address owner, index_topic_2 address approved, index_topic_3 uint256 tokenId)
            // // 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
            // // ERC-721 ApprovalForAll (index_topic_1 address owner, index_topic_2 address operator, bool approved)
            // // 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31
            let total = 0;
            let t = this;
            async function processLogs(fromBlock, toBlock, section, logs) {
              total = parseInt(total) + logs.length;
              console.log(moment().format("HH:mm:ss") + " syncTokenEvents.processLogs: " + fromBlock + " - " + toBlock + " " + section + " " + logs.length + " " + total);
              const records = [];
              for (const log of logs) {
                if (!log.removed) {
                  const contract = log.address;
                  let eventRecord = null;
                  if (log.topics[0] == "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef") {
                    let from = null;
                    let to = null;
                    let tokensOrTokenId = null;
                    let tokens = null;
                    let tokenId = null;
                    if (log.topics.length == 4) {
                      from = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                      to = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                      tokensOrTokenId = ethers.BigNumber.from(log.topics[3]).toString();
                    } else if (log.topics.length == 3) {
                      from = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                      to = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                      tokensOrTokenId = ethers.BigNumber.from(log.data).toString();
                    // TODO: Handle 2
                    } else if (log.topics.length == 1) {
                      from = ethers.utils.getAddress('0x' + log.data.substring(26, 66));
                      to = ethers.utils.getAddress('0x' + log.data.substring(90, 130));
                      tokensOrTokenId = ethers.BigNumber.from('0x' + log.data.substring(130, 193)).toString();
                    }
                    if (from) {
                      if (log.topics.length == 4) {
                        eventRecord = { type: "Transfer", from, to, tokenId: tokensOrTokenId, eventType: "erc721" };
                      } else {
                        eventRecord = { type: "Transfer", from, to, tokens: tokensOrTokenId, eventType: "erc20" };
                      }
                    }
                  } else if (log.topics[0] == "0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c") {
                    const to = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                    tokens = ethers.BigNumber.from(log.data).toString();
                    eventRecord = { type: "Transfer", from: ADDRESS0, to, tokens, eventType: "erc20" };
                  } else if (log.topics[0] == "0x7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65") {
                    const from = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                    tokens = ethers.BigNumber.from(log.data).toString();
                    eventRecord = { type: "Transfer", from, to: ADDRESS0, tokens, eventType: "erc20" };
                  } else if (log.topics[0] == "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925") {
                    if (log.topics.length == 4) {
                      const owner = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                      const approved = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                      tokenId = ethers.BigNumber.from(log.topics[3]).toString();
                      eventRecord = { type: "Approval", owner, approved, tokenId, eventType: "erc721" };
                    } else {
                      const owner = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                      const spender = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                      tokens = ethers.BigNumber.from(log.data).toString();
                      eventRecord = { type: "Approval", owner, spender, tokens, eventType: "erc20" };
                    }
                  } else if (log.topics[0] == "0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31") {
                    const owner = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                    const operator = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                    approved = ethers.BigNumber.from(log.data).toString();
                    eventRecord = { type: "ApprovalForAll", owner, operator, approved, eventType: "erc721" };
                  } else {
                    console.log("NOT HANDLED: " + JSON.stringify(log));
                  }
                  // if (eventRecord && contract == "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9") {
                  if (eventRecord) {
                    records.push( {
                      chainId: t.chainId,
                      blockNumber: parseInt(log.blockNumber),
                      logIndex: parseInt(log.logIndex),
                      txIndex: parseInt(log.transactionIndex),
                      txHash: log.transactionHash,
                      contract,
                      ...eventRecord,
                      confirmations: latestBlockNumber - log.blockNumber,
                    });
                  }
                }
              }
              if (records.length) {
                await db.tokenEvents.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncTokenEvents.bulkPut error: " + error);
                });
              }
            }
            async function getLogs(fromBlock, toBlock, section, selectedAddresses, processLogs) {
              console.log(moment().format("HH:mm:ss") + " syncTokenEvents.getLogs: " + fromBlock + " - " + toBlock + " " + section);
              try {
                let topics = null;
                if (section == 0) {
                  topics = [[
                      '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
                      '0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c',
                      '0x7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65',
                      '0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925',
                      '0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31',
                    ],
                    selectedAddresses,
                    null
                  ];
                } else if (section == 1) {
                  topics = [ ['0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'], null, selectedAddresses ];
                }
                const logs = await provider.getLogs({ address: null, fromBlock, toBlock, topics });
                await processLogs(fromBlock, toBlock, section, logs);
              } catch (e) {
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogs(fromBlock, mid, section, selectedAddresses, processLogs);
                await getLogs(parseInt(mid) + 1, toBlock, section, selectedAddresses, processLogs);
              }
            }
            console.log(moment().format("HH:mm:ss") + " syncTokenEvents BEGIN");
            this.sync.completed = 0;
            this.sync.total = 0;
            this.sync.section = 'ERC-20 & ERC-721 Tokens';
            const selectedAddresses = [];
            for (const [address, addressData] of Object.entries(this.addresses)) {
              if (address.substring(0, 2) == "0x" && addressData.mine) {
                selectedAddresses.push('0x000000000000000000000000' + address.substring(2, 42).toLowerCase());
              }
            }
            if (selectedAddresses.length > 0) {
              const deleteCall = await db.tokenEvents.where("confirmations").below(this.CONFIRMATIONS).delete();
              const latest = await db.tokenEvents.where('[chainId+blockNumber+logIndex]').between([this.chainId, Dexie.minKey, Dexie.minKey],[this.chainId, Dexie.maxKey, Dexie.maxKey]).last();
              const startBlock = latest ? parseInt(latest.blockNumber) + 1: 0;
              for (let section = 0; section < 2; section++) {
                await getLogs(startBlock, latestBlockNumber, section, selectedAddresses, processLogs);
              }
            }
            console.log(moment().format("HH:mm:ss") + " syncTokenEvents END");
          },

          // async syncTokenEventsData(db, provider, latestBlockNumber) {
          //   console.log(moment().format("HH:mm:ss") + " syncTokenEventsData BEGIN");
          //   let rows = 0;
          //   let done = false;
          //   do {
          //     let data = await db.tokenEvents.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
          //     console.log(moment().format("HH:mm:ss") + " syncTokenEventsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
          //     rows = parseInt(rows) + data.length;
          //     done = data.length < this.DB_PROCESSING_BATCH_SIZE;
          //   } while (!done);
          //   // console.log(moment().format("HH:mm:ss") + " syncTokenEventsData - total: " + total);
          //   this.sync.completed = 0;
          //   this.sync.total = rows;
          //   this.sync.section = 'Token Events Tx Data';
          //   rows = 0;
          //   do {
          //     let data = await db.tokenEvents.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
          //     console.log(moment().format("HH:mm:ss") + " syncTokenEventsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
          //     const records = [];
          //     for (const item of data) {
          //       if (item.timestamp == null && item.chainId == this.chainId) {
          //         console.log(moment().format("HH:mm:ss") + " syncTokenEventsData: " + JSON.stringify(item));
          //         const block = await provider.getBlock(item.blockNumber);
          //         item.timestamp = block.timestamp;
          //         // const tx = await provider.getTransaction(item.txHash);
          //         // const txReceipt = await provider.getTransactionReceipt(item.txHash);
          //         // item.tx = {
          //         //   type: tx.type,
          //         //   blockHash: tx.blockHash,
          //         //   from: tx.from,
          //         //   gasPrice: ethers.BigNumber.from(tx.gasPrice).toString(),
          //         //   gasLimit: ethers.BigNumber.from(tx.gasLimit).toString(),
          //         //   to: tx.to,
          //         //   value: ethers.BigNumber.from(tx.value).toString(),
          //         //   nonce: tx.nonce,
          //         //   data: tx.to && tx.data || null, // Remove contract creation data to reduce memory footprint
          //         //   chainId: tx.chainId,
          //         //   contractAddress: txReceipt.contractAddress,
          //         //   transactionIndex: txReceipt.transactionIndex,
          //         //   gasUsed: ethers.BigNumber.from(txReceipt.gasUsed).toString(),
          //         //   blockHash: txReceipt.blockHash,
          //         //   logs: txReceipt.logs,
          //         //   cumulativeGasUsed: ethers.BigNumber.from(txReceipt.cumulativeGasUsed).toString(),
          //         //   effectiveGasPrice: ethers.BigNumber.from(txReceipt.effectiveGasPrice).toString(),
          //         //   status: txReceipt.status,
          //         //   type: txReceipt.type,
          //         // };
          //         records.push(item);
          //       } else {
          //         // console.log(moment().format("HH:mm:ss") + " syncTokenEventsData: TIMESTAMP <> NULL" + JSON.stringify(item));
          //       }
          //     }
          //     if (records.length > 0) {
          //       console.log(moment().format("HH:mm:ss") + " syncTokenEventsData - records: " + JSON.stringify(records));
          //       await db.tokenEvents.bulkPut(records).then (function() {
          //       }).catch(function(error) {
          //         console.log("syncTokenEventsData.bulkPut error: " + error);
          //       });
          //     }
          //     rows = parseInt(rows) + data.length;
          //     this.sync.completed = rows;
          //     done = data.length < this.DB_PROCESSING_BATCH_SIZE;
          //   } while (!done);
          //   console.log(moment().format("HH:mm:ss") + " syncTokenEventsData END");
          // },

          // async syncTokenEventsDataMainnet(db, provider, latestBlockNumber) {
          //   console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet BEGIN");
          //   let rows = 0;
          //   let done = false;
          //
          //   const blocksWithNullTimestampsMap = {};
          //   do {
          //     let data = await db.tokenEvents.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
          //     console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
          //     for (const item of data) {
          //       if (item.timestamp == null) {
          //         if (!(item.blockNumber in blocksWithNullTimestampsMap)) {
          //           blocksWithNullTimestampsMap[item.blockNumber] = true;
          //         }
          //       }
          //     }
          //     rows = parseInt(rows) + data.length;
          //     done = data.length < this.DB_PROCESSING_BATCH_SIZE;
          //   } while (!done);
          //   console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet - rows: " + rows);
          //   const blocksWithNullTimestamps = Object.keys(blocksWithNullTimestampsMap);
          //   // console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet - blocksWithNullTimestamps: " + JSON.stringify(blocksWithNullTimestamps));
          //
          //   const blockTimestamps = {};
          //   const BATCHSIZE = 1000;
          //   for (let i = 0; i < blocksWithNullTimestamps.length; i += BATCHSIZE) {
          //     const batch = blocksWithNullTimestamps.slice(i, parseInt(i) + BATCHSIZE);
          //     // console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet - batch[0]: " + batch[0] + ", batch[-1]: " + batch.slice(-1));
          //     const data = await fetch(BLOCKTIMESTAMPSUBGRAPHURL, {
          //       method: 'POST',
          //       headers: {
          //         'Content-Type': 'application/json',
          //         'Accept': 'application/json',
          //       },
          //       body: JSON.stringify({
          //         query: BLOCKTIMESTAMPINQUERY,
          //         variables: { blockNumbers: batch.map(e => parseInt(e)) },
          //       })
          //     }).then(response => response.json())
          //       .catch(function(e) {
          //         console.log("error: " + e);
          //       });
          //     const timestamps = data.data && data.data.blocks || [];
          //     // console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet - timestamps: " + JSON.stringify(timestamps));
          //     for (const timestampItem of timestamps) {
          //       blockTimestamps[timestampItem.number] = parseInt(timestampItem.timestamp);
          //     //   Vue.set(this.blockTimestamps, parseInt(timestampItem.number), parseInt(timestampItem.timestamp));
          //     }
          //     this.sync.completed += batch.length;
          //     console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet " + this.sync.completed + " of " + blocksWithNullTimestamps.length);
          //   }
          //
          //   console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet - blockTimestamps: " + JSON.stringify(blockTimestamps));
          //
          //   // this.sync.completed = 0;
          //   // this.sync.total = rows;
          //   // this.sync.section = 'Token Events Tx Data';
          //   rows = 0;
          //   do {
          //     let data = await db.tokenEvents.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
          //     console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
          //     const records = [];
          //     for (const item of data) {
          //       if (item.timestamp == null && item.chainId == this.chainId) {
          //         item.timestamp = blockTimestamps[item.blockNumber];
          //   //       console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet: " + JSON.stringify(item));
          //   //       const block = await provider.getBlock(item.blockNumber);
          //   //       item.timestamp = block.timestamp;
          //   //       // const tx = await provider.getTransaction(item.txHash);
          //   //       // const txReceipt = await provider.getTransactionReceipt(item.txHash);
          //   //       // item.tx = {
          //   //       //   type: tx.type,
          //   //       //   blockHash: tx.blockHash,
          //   //       //   from: tx.from,
          //   //       //   gasPrice: ethers.BigNumber.from(tx.gasPrice).toString(),
          //   //       //   gasLimit: ethers.BigNumber.from(tx.gasLimit).toString(),
          //   //       //   to: tx.to,
          //   //       //   value: ethers.BigNumber.from(tx.value).toString(),
          //   //       //   nonce: tx.nonce,
          //   //       //   data: tx.to && tx.data || null, // Remove contract creation data to reduce memory footprint
          //   //       //   chainId: tx.chainId,
          //   //       //   contractAddress: txReceipt.contractAddress,
          //   //       //   transactionIndex: txReceipt.transactionIndex,
          //   //       //   gasUsed: ethers.BigNumber.from(txReceipt.gasUsed).toString(),
          //   //       //   blockHash: txReceipt.blockHash,
          //   //       //   logs: txReceipt.logs,
          //   //       //   cumulativeGasUsed: ethers.BigNumber.from(txReceipt.cumulativeGasUsed).toString(),
          //   //       //   effectiveGasPrice: ethers.BigNumber.from(txReceipt.effectiveGasPrice).toString(),
          //   //       //   status: txReceipt.status,
          //   //       //   type: txReceipt.type,
          //   //       // };
          //         records.push(item);
          //   //     } else {
          //   //       // console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet: TIMESTAMP <> NULL" + JSON.stringify(item));
          //       }
          //     }
          //     if (records.length > 0) {
          //       console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet - records: " + JSON.stringify(records));
          //       await db.tokenEvents.bulkPut(records).then (function() {
          //       }).catch(function(error) {
          //         console.log("syncTokenEventsDataMainnet.bulkPut error: " + error);
          //       });
          //     }
          //     rows = parseInt(rows) + data.length;
          //     // this.sync.completed = rows;
          //     done = data.length < this.DB_PROCESSING_BATCH_SIZE;
          //   } while (!done);
          //   console.log(moment().format("HH:mm:ss") + " syncTokenEventsDataMainnet END");
          // },

          async collateTokens(db, provider, latestBlockNumber) {
            // TODO: Handle low confirmation events
            console.log(moment().format("HH:mm:ss") + " collateTokens BEGIN");
            const selectedAddressesMap = {};
            for (const [address, addressData] of Object.entries(this.addresses)) {
              if (address.substring(0, 2) == "0x" && addressData.mine) {
                selectedAddressesMap[address] = true;
              }
            }
            console.log(moment().format("HH:mm:ss") + " collateTokens - selectedAddressesMap: " + JSON.stringify(Object.keys(selectedAddressesMap)));
            const accounts = this.addresses;
            if (!(this.coinbase in accounts)) {
              accounts[this.coinbase] = { type: "address", source: "attached", mine: true, name: null };
            }
            // TODO: Dev const tokenContracts = this.tokenContracts;
            const tokenContracts = {};
            if (!(this.chainId in tokenContracts)) {
              tokenContracts[this.chainId] = {};
            }
            this.sync.completed = 0;
            this.sync.total = 0;
            this.sync.section = 'Token Contracts';
            let rows = 0;
            let done = false;
            do {
              let data = await db.tokenEvents.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " collateTokens - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              for (const item of data) {
                if (item.chainId == this.chainId) {
                  if (!(item.contract in tokenContracts[item.chainId])) {
                    const contract = new ethers.Contract(item.contract, ERC20ABI, provider);
                    let symbol = null;
                    try {
                      symbol = await contract.symbol();
                    } catch (e) {
                    }
                    let name = null;
                    try {
                      name = await contract.name();
                    } catch (e) {
                    }
                    let decimals = null;
                    if (item.eventType == "erc20") {
                      try {
                        decimals = await contract.decimals();
                      } catch (e) {
                      }
                    }
                    let totalSupply = null;
                    try {
                      totalSupply = await contract.totalSupply();
                    } catch (e) {
                    }
                    if (item.eventType == "erc20") {
                      tokenContracts[item.chainId][item.contract] = {
                        active: false,
                        symbol: symbol.trim(),
                        name: name.trim(),
                        decimals: parseInt(decimals || 0),
                        totalSupply: totalSupply && totalSupply.toString() || null,
                        type: "erc20",
                        firstEventBlockNumber: item.blockNumber,
                        lastEventBlockNumber: item.blockNumber,
                        events: {},
                        balances: {},
                        tokenIds: {},
                      };
                    } else {
                      tokenContracts[item.chainId][item.contract] = {
                        symbol,
                        name,
                        totalSupply: totalSupply && totalSupply.toString() || null,
                        type: "erc721",
                        firstEventBlockNumber: item.blockNumber,
                        lastEventBlockNumber: item.blockNumber,
                        events: {},
                        balances: {},
                        tokenIds: {},
                      };
                    }
                    this.sync.completed++;
                  }
                  tokenContracts[item.chainId][item.contract].lastEventBlockNumber = item.blockNumber;
                  // console.log("item: " + JSON.stringify(item));
                  if (item.eventType == "erc20" && item.type == "Transfer") {
                    const balances = tokenContracts[item.chainId][item.contract].balances;
                    if (item.from in selectedAddressesMap) {
                      // console.log("from included: " + item.from);
                      if (!(item.from in balances)) {
                        balances[item.from] = "0";
                      }
                      balances[item.from] = ethers.BigNumber.from(balances[item.from]).sub(item.tokens).toString();
                    }
                    if (item.to in selectedAddressesMap) {
                      // console.log("to included: " + item.to);
                      if (!(item.to in balances)) {
                        balances[item.to] = "0";
                      }
                      balances[item.to] = ethers.BigNumber.from(balances[item.to]).add(item.tokens).toString();
                    }
                    tokenContracts[item.chainId][item.contract].balances = balances;
                    // console.log("tokenContracts[item.chainId][item.contract]: " + JSON.stringify(tokenContracts[item.chainId][item.contract]));
                  }
                  const tokenContract = tokenContracts[item.chainId][item.contract];
                  // console.log("tokenContract: " + item.contract + " => " + JSON.stringify(tokenContract));
                  const events = tokenContracts[item.chainId][item.contract].events;
                  if (!(item.blockNumber in events)) {
                    events[item.blockNumber] = { timestamp: item.timestamp, logIndexes: {} };
                  }
                  if (!(item.logIndex in events[item.blockNumber].logIndexes)) {
                    events[item.blockNumber].logIndexes[item.logIndex] = {
                      txHash: item.txHash,
                      type: item.type,
                      eventType: item.eventType,
                      from: item.from || undefined,
                      to: item.to || undefined,
                      tokens: item.tokens || undefined,
                      tokenId: item.tokenId || undefined,
                      owner: item.owner || undefined,
                      operator: item.operator || undefined,
                      approved: item.approved || undefined,
                    };
                  }
                  // if (item.active) {
                  //   console.log("tokenContract: " + item.contract + " => " + JSON.stringify(tokenContract));
                  // }
                }
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            rows = 0;

            // done = false;
            // do {
            //   let data = await db.registryEntries.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
            //   console.log(moment().format("HH:mm:ss") + " collateTokens - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
            //   for (const item of data) {
            //     if (!(item.contract in accounts)) {
            //       const name = CUSTOMNAMES[item.contract] && CUSTOMNAMES[item.contract].name || null;
            //       accounts[item.contract] = { type: "address", source: "registry.contract", mine: false, name };
            //     }
            //     if (!(item.registrant in accounts)) {
            //       accounts[item.registrant] = { type: "address", source: "registry.registrant", mine: false, name: null };
            //     }
            //     if (!(item.stealthMetaAddress in accounts)) {
            //       accounts[item.stealthMetaAddress] = { type: "stealthMetaAddress", source: "registry.stealthMetaAddress", linkedTo: item.registrant, mine: false };
            //     }
            //   }
            //   rows = parseInt(rows) + data.length;
            //   done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            // } while (!done);
            //
            // for (const [address, accountData] of Object.entries(accounts)) {
            //   if (accountData.type == "stealthMetaAddress") {
            //     const linkedToData = accountData.linkedTo && accounts[accountData.linkedTo] || null;
            //     if (linkedToData && linkedToData.mine) {
            //       accounts[address].mine = true;
            //     }
            //   }
            // }
            //
            Vue.set(this, 'tokenContracts', tokenContracts);
            localStorage.stealthChadTokenContracts = JSON.stringify(this.tokenContracts);
            console.log(moment().format("HH:mm:ss") + " collateTokens - tokenContracts: " + JSON.stringify(tokenContracts, null, 2));
            console.log(moment().format("HH:mm:ss") + " collateTokens END");
          },

          async syncENSNames(provider) {
            console.log(moment().format("HH:mm:ss") + " syncENSNames BEGIN");
            const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, provider);
            for (const [account, accountData] of Object.entries(this.addresses)) {
              if (accountData.type == "address") {
                try {
                  const allnames = await ensReverseRecordsContract.getNames([account]);
                  const name = allnames.length >= 0 && allnames[0] && ethers.utils.isValidName(allnames[0]) && allnames[0] || null;
                  Vue.set(this.addresses[account], 'ensName', name);
                } catch (e) {
                  console.log("syncENSNames - ENS reverse lookup failed: " + e.toString());
                }
              }
            }
            localStorage.stealthChadAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " syncENSNames END");
          },

          async processData(db, provider, latestBlockNumber) {
            function checkStealthAddress(stealthAddress, ephemeralPublicKey, viewingPrivateKey, spendingPublicKey) {
              const result = {};
              // console.log(moment().format("HH:mm:ss") + " processDataOld - checkStealthAddress - stealthAddress: " + stealthAddress + ", ephemeralPublicKey: " + ephemeralPublicKey + ", viewingPrivateKey: " + viewingPrivateKey + ", spendingPublicKey: " + spendingPublicKey);
              // console.log("    Check stealthAddress: " + stealthAddress + ", ephemeralPublicKey: " + ephemeralPublicKey + ", viewingPrivateKey: " + viewingPrivateKey + ", spendingPublicKey: " + spendingPublicKey);
              result.sharedSecret = nobleCurves.secp256k1.getSharedSecret(viewingPrivateKey.substring(2), ephemeralPublicKey.substring(2), false);
              result.hashedSharedSecret = ethers.utils.keccak256(result.sharedSecret.slice(1));
              result.hashedSharedSecretPoint = nobleCurves.secp256k1.ProjectivePoint.fromPrivateKey(result.hashedSharedSecret.substring(2));
              result.stealthPublicKey = nobleCurves.secp256k1.ProjectivePoint.fromHex(spendingPublicKey.substring(2)).add(result.hashedSharedSecretPoint);
              result.stealthAddress = ethers.utils.computeAddress("0x" + result.stealthPublicKey.toHex(false));
              result.match = result.stealthAddress == stealthAddress;
              return result;
            }

            console.log(moment().format("HH:mm:ss") + " processData BEGIN");
            const checkAccounts = [];
            for (const [address, accountData] of Object.entries(this.addresses)) {
              if (accountData.type == "stealthMetaAddress" && accountData.mine && accountData.viewingPrivateKey) {
                checkAccounts.push({ address, ...accountData });
              }
            }
            console.log(moment().format("HH:mm:ss") + " processData - checkAccounts: " + JSON.stringify(checkAccounts.map(e => e.address)));

            let rows = 0;
            let done = false;
            do {
              let data = await db.announcements.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " processData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              const writeRecords = [];
              for (const item of data) {
                const stealthAddress = item.stealthAddress;
                const ephemeralPublicKey = item.ephemeralPublicKey;
                for (const account of checkAccounts) {
                  const viewingPrivateKey = account.viewingPrivateKey;
                  const viewingPublicKey = account.viewingPublicKey;
                  const spendingPublicKey = account.spendingPublicKey;
                  const status = checkStealthAddress(stealthAddress, ephemeralPublicKey, viewingPrivateKey, spendingPublicKey);
                  if (status && status.match) {
                    // console.log(moment().format("HH:mm:ss") + " processData - stealthAddress: " + stealthAddress + ", ephemeralPublicKey: " + ephemeralPublicKey.substring(0, 20) + '... @ ' + item.blockNumber);
                    // console.log( " viewingPrivateKey: " + viewingPrivateKey + ", viewingPublicKey: " + viewingPublicKey.substring(0, 20) + "... " + spendingPublicKey.substring(0, 20) + "...");
                    // console.log("item: " + JSON.stringify(item, null, 2));
                    // console.log("account: " + JSON.stringify(account, null, 2));
                    item.linkedTo = { stealthMetaAddress: account.address, address: account.linkedTo };
                    item.mine = true;
                    writeRecords.push(item);
                    break;
                  }
                }
              }
              if (writeRecords.length > 0) {
                await db.announcements.bulkPut(writeRecords).then (function() {
                }).catch(function(error) {
                  console.log("processData.bulkPut error: " + error);
                });
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            rows = 0;

            // console.log(moment().format("HH:mm:ss") + " processData - addresses: " + JSON.stringify(accounts, null, 2));
            console.log(moment().format("HH:mm:ss") + " processData END");
          },

          async loadCurrentData() {
            console.log(moment().format("HH:mm:ss") + " loadCurrentData BEGIN");
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const announcements = await db.announcements.toArray();
            Vue.set(this, 'announcements', announcements);
            const registryEntries = await db.registryEntries.toArray();
            Vue.set(this, 'registryEntries', registryEntries);
            const tokenEvents = await db.tokenEvents.toArray();
            Vue.set(this, 'tokenEvents', tokenEvents);
            // console.log(moment().format("HH:mm:ss") + " loadCurrentData - tokenEvents[0..1]: " + JSON.stringify(tokenEvents.slice(0, 2), null, 2));
            db.close();
            console.log(moment().format("HH:mm:ss") + " loadCurrentData END");
          },

          saveSettings() {
            // console.log(moment().format("HH:mm:ss") + " saveSettings: " + JSON.stringify(this.settings));
            localStorage.stealthChadSettings = JSON.stringify(this.settings);
          },
          async processNewBlock(blockNumber) {
            console.log(moment().format("HH:mm:ss") + " processNewBlock[" + this.chainId + "] #" + this.commify0(blockNumber) + ", latest #" + this.commify0(this.blockNumber) + " @ " + moment.unix(this.timestamp).format("YYYY-MM-DD HH:mm:ss") + " " + moment.unix(this.timestamp).fromNow());
          },
          async halt() {
            this.sync.halt = true;
            console.log(moment().format("HH:mm:ss") + " halt()");
          },
          commify0(n) {
            if (n != null) {
              return Number(n).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
            return null;
          },
          formatETH(e, precision = 9) {
            try {
              if (precision == 0) {
                return e ? ethers.utils.formatEther(e) : null;
              } else {
                return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(precision) : null;
              }
            } catch (err) {
            }
            return e.toFixed(precision);
          },
          formatDecimals(e, decimals = 18) {
            return e ? ethers.utils.formatUnits(e, decimals) : null;
          },
          formatTimestamp(ts) {
            if (ts != null) {
              if (this.settings.reportingDateTime == 1) {
                return moment.unix(ts).utc().format("YYYY-MM-DD HH:mm:ss");
              } else {
                return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
              }
            }
            return null;
          },
          formatTimeDiff(unixtime) {
            if (!unixtime) {
              return "";
            } else {
              return moment.unix(unixtime).fromNow();
            }
          },
          shortAddress(address) {
            let result = null;
            if (address) {
              if (address.substring(0, 3) == "st:") {
                result = address.substring(0, (9+16)) + "..." + address.slice(-16);
              } else {
                // result = address.substring(0, 10) + "..." + address.slice(-8);
                result = address;
              }
            }
            return result;
          },
          ensNameOrAddress(address, length = 0) {
            let result = null;
            const account = this.addresses[address];
            if (account && account.ensName) {
              if (length > 0 && account.ensName.length > length) {
                result = account.ensName.substring(0, (length-7)/2) + '...' + account.ensName.slice(-((length-7)/2 + 4));
                // result = account.ensName;
              } else {
                result = account.ensName;
              }
            } else if (address) {
              if (length > 0) {
                result = address.substring(0, ((length-5)/2 + 2)) + '...' + address.slice(-(length-5)/2);
              } else {
                result = address;
              }
            }
            return result;
          },
          nameOrAddress(address, length = 0) {
            let result = null;
            const account = this.addresses[address];
            if (account) {
              if (account.ensName) {
                if (account.name) {
                  result = account.name + '; ' + account.ensName;
                } else {
                  result = account.ensName;
                }
              } else {
                if (account.name) {
                  result = account.name;
                } else {
                  result = address;
                }
              }
            } else {
              result = address;
            }
            if (result && length > 0) {
              result = result.substring(0, length);
            }
            return result;
          },
          nameOrNull(address) {
            let result = null;
            const addressData = address && this.addresses[address];
            if (addressData) {
              if (addressData.ensName) {
                if (addressData.name) {
                  result = addressData.name + '; ' + addressData.ensName;
                } else {
                  result = addressData.ensName;
                }
              } else {
                result = addressData.name || null;
              }
            }
            return result;
          },
          addressDescription(address) {
            const account = this.addresses[address];
            if (account) {
              result = address;
              for (let key of [ 'linkedTo', 'ensName', 'name', 'source', 'stealthMetaAddress' ]) {
                if (key in account) {
                  result = result + "; " + key + "=" + account[key];
                }
              }
            } else {
              result = address;
            }
            return result;
          },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
          },
          async connectToWeb3() {
            if (!window.ethereum) {
              this.connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                this.connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                this.connected = false;
              }
            }
            if (!this.connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const t = this;
              function handleChainChanged(_chainId) {
                t.chainId = _chainId;
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleChainChanged - this.chainId: " + t.chainId);
                alert('Ethereum chain has changed - reloading this page.')
                window.location.reload();
              }
              window.ethereum.on('chainChanged', handleChainChanged);
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              async function handleAccountsChanged(accounts) {
                const signer = provider.getSigner();
                t.coinbase = await signer.getAddress();
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleAccountsChanged: " + t.coinbase);
              }
              window.ethereum.on('accountsChanged', handleAccountsChanged);
              async function handleNewBlock(blockNumber) {
                if (!t.blockNumber || blockNumber > t.blockNumber) {
                  const block = await provider.getBlock("latest");
                  t.blockNumber = block.number;
                  t.timestamp = block.timestamp;
                  await t.processNewBlock(blockNumber);
                }
              }
              provider.on("block", handleNewBlock);
              const signer = provider.getSigner();
              this.coinbase = await signer.getAddress();
              const network = await provider.getNetwork();
              this.chainId = network.chainId;
              console.log(moment().format("HH:mm:ss") + " connectToWeb3[" + this.chainId + "]");
            }
          },
        },

        // --- MOUNTED ---
        mounted() {
          (async() => {
            await this.connectToWeb3();
          })();
          if ('stealthChadChainId' in localStorage) {
            this.chainId = localStorage.stealthChadChainId;
          }
          if ('stealthChadCoinbase' in localStorage) {
            this.coinbase = localStorage.stealthChadCoinbase;
          }
          if ('stealthChadSettings' in localStorage) {
            const tempSettings = JSON.parse(localStorage.stealthChadSettings);
            if ('version' in tempSettings && tempSettings.version == this.settings.version) {
              this.settings = tempSettings;
              if (this.settings.activityTable.currentPage > 1) {
                this.settings.activityTable.currentPage = 1;
              }
              if (this.settings.registryActivityTable.currentPage > 1) {
                this.settings.registryActivityTable.currentPage = 1;
              }
              if (this.settings.addressesTable.currentPage > 1) {
                this.settings.addressesTable.currentPage = 1;
              }
              if (this.settings.tokenEventsTable.currentPage > 1) {
                this.settings.tokenEventsTable.currentPage = 1;
              }
              if (this.settings.contractsTable.currentPage > 1) {
                this.settings.contractsTable.currentPage = 1;
              }
              // Restore other settings for the same version
              if ('stealthChadContracts' in localStorage) {
                this.contracts = JSON.parse(localStorage.stealthChadContracts);
              }
              if ('stealthChadAddresses' in localStorage) {
                this.addresses = JSON.parse(localStorage.stealthChadAddresses);
              }
              if ('stealthChadTokenContracts' in localStorage) {
                this.tokenContracts = JSON.parse(localStorage.stealthChadTokenContracts);
                // console.log(moment().format("HH:mm:ss") + " mounted - tokenContracts: " + JSON.stringify(this.tokenContracts, null, 2));
              }
              // (async() => {
              //   // TODO: TESTING
              //   await delay(1500);
              //   await this.newStealthMetaAddress();
              // })();
            }
            (async() => {
              await this.loadCurrentData();
            })();
          }
        },
      })
    </script>
  </body>
</html>
