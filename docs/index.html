<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Magical Internet Money</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="Magical Internet Money (c) Bok Consulting Pty Ltd 2024" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="js/dexie.js"></script>
    <script src="js/noble-curves.js"></script>
    <script src="globals.js"></script>
    <script src="customNames.js"></script>
    <script src="deploymentData.js"></script>

    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/site.webmanifest">
    <link rel="mask-icon" href="images/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="images/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="images/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="https://bokkypoobah.github.io/MagicalInternetMoney/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/LarvaChad_1532_zoomed_transparentbg.png" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <em v-b-popover.hover.bottom="'gm gm gm'">Magical Internet Money</em>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Your Magical Internet Money Dashboard'">Dashboard</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings();" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'Stealth Transfers - ERC-5564: Stealth Addresses'">Transfers</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings();" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'Directory - ERC-6538: Stealth Meta-Address Registry'">Directory</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 3; saveSettings();" :active="settings.tabIndex == 3" active-class="active" v-b-popover.hover="'List of Regular Addresses and Stealth Meta-Addresses'">Addresses</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 4; saveSettings();" :active="settings.tabIndex == 4" active-class="active" v-b-popover.hover="'ERC-20 and ERC-721 Tokens'">Tokens</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 5; saveSettings();" :active="settings.tabIndex == 5" active-class="active" v-b-popover.hover="'Configuration'">Config</b-nav-item>
            <b-avatar v-if="ensName(coinbase)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensName(coinbase)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar>
            <b-button size="sm" variant="outline-primary" class="ml-1" @click="connectToWeb3(); processNewBlock(0);" v-b-popover.hover.bottom="addressDescription(coinbase, 100)">{{ coinbase ? ensNameOrAddress(coinbase, 30) : 'Connect' }}</b-button>
          </b-navbar-nav>
        </b-navbar>

        <b-card no-body class="p-0 mt-0" style="min-height: 666px;">
          <b-alert v-if="false" size="sm" dismissible variant="warning" show class="m-1 my-0">
            Warning: This is experimental unaudited software. Please check your transaction data carefully before signing
          </b-alert>
          <b-card class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="!coinbase || chainId != 11155111">
            <b-card-text>
              Please install the MetaMask extension and connect to the Ethereum Sepolia Testnet or an EVM compatible chain. Then refresh this page, and click the [Connect] button on the top right.
              <br />
              You can switch to the Ethereum Mainnet and click Sync your addresses with ENS names
            </b-card-text>
          </b-card>

          <!-- :MODALSYNC -->
          <b-modal ref="modalsync" id="modal-sync" hide-footer size="md">
            <template #modal-title>Sync</template>
            <b-form-checkbox size="sm" switch :disabled="chainId != 11155111" v-model="settings.sync.transfers" @input="saveSettings" class="ml-2 mt-1">Stealth Address transfer announcements</b-form-checkbox>
            <b-form-checkbox size="sm" switch :disabled="chainId != 11155111" v-model="settings.sync.directory" @input="saveSettings" class="ml-2 mt-1">Stealth Address Registry registrations</b-form-checkbox>
            <b-form-checkbox size="sm" switch :disabled="chainId != 11155111" v-model="settings.sync.tokens" @input="saveSettings" class="ml-2 mt-1">ERC-20 & ERC-721 transfers for my address set</b-form-checkbox>
            <b-form-checkbox size="sm" switch :disabled="chainId != 11155111 || !settings.sync.tokens" v-model="settings.sync.rescanTokens" @input="saveSettings" class="ml-2 mt-1">Full ERC-20 & ERC-721 rescan, after my address set changes</b-form-checkbox>
            <b-form-checkbox size="sm" switch :disabled="chainId != 1" v-model="settings.sync.ens" @input="saveSettings" class="ml-2 mt-1">Sync ENS names in Mainnet</b-form-checkbox>
            <b-form-checkbox size="sm" switch :disabled="true" v-model="settings.sync.balances" @input="saveSettings" class="ml-2 mt-1">TODO: Balances for my addresses</b-form-checkbox>
            <b-form-checkbox size="sm" switch :disabled="chainId != 11155111" v-model="settings.sync.exchangeRates" @input="saveSettings" class="ml-2 mt-1">TODO: Exchange rates</b-form-checkbox>
            <b-form-group label="" label-for="sync-go" label-size="sm" label-cols-sm="5" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" id="sync-go" @click="syncIt()" variant="primary">Do It!</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALNEWTRANSFER -->
          <b-modal id="modal-newtransfer" hide-footer size="lg">
            <template #modal-title>Transfer To Stealth Meta-Address</template>
            <b-form-group label="From:" label-for="newtransfer-sender" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <template slot="label">
                From:
              </template>
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="newtransfer-sender" @click="viewAddress(coinbase)" variant="link" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(coinbase) }}</b-button>
                  <div v-if="formatAddressNameSecondary(coinbase)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(coinbase) }}</font>
                  </div>
                </div>
                <div>
                  <b-avatar v-if="ensName(coinbase)" rounded variant="light" size="2.5rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensName(coinbase)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
                  <b-button size="sm" @click="copyToClipboard(coinbase);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group label="To:" label-for="newtransfer-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="nameOrNull(modalNewTransfer.stealthMetaAddress) || 'Stealth Meta-Address'" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-textarea type="text" id="newtransfer-stealthmetaaddress" v-model.trim="modalNewTransfer.stealthMetaAddress" @input="saveSettings" rows="3" placeholder="e.g., st:eth:0x12...89"></b-form-textarea>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalNewTransfer.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group label="Amount:" label-for="newtransfer-amount" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="modalNewTransfer.items.length > 0 && !modalNewTransfer.amount ? 'Note: Send some ETH with ERC-20/ERC-721 transfers to cover conversion expenses' : ''" class="mx-0 my-1 p-0">
              <b-row>
                <b-col cols="3" class="mx-0 px-1 text-right">
                  <font size="-1">ETH</font>
                </b-col>
                <b-col cols="3" class="pr-1">
                  <b-form-input type="text" size="sm" id="newtransfer-amount" v-model.trim="modalNewTransfer.amount" placeholder="e.g., 0.01 for 0.01 ETH" class="text-right"></b-form-input>
                </b-col>
              </b-row>
            </b-form-group>
            <b-form-group label="" label-for="newtransfer-tokens" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-row v-for="(item, index) of modalNewTransfer.items" v-bind:key="item.token">
                <b-col cols="3" class="mx-0 px-1 text-right">
                  <font size="-1">{{ item.symbol }}</font>
                </b-col>
                <b-col cols="3" class="mb-1 pr-1">
                  <div v-if="item.type == 'erc20'" class="ml-1">
                    <font size="-1">{{ item.amount }}</font>
                  </div>
                  <div v-if="item.type == 'erc721'">
                    <b-button size="sm" :href="chainInfo.nftTokenPrefix + item.token + '/' + item.tokenId" variant="link" v-b-popover.hover.bottom="item.tokenId" class="m-0 ml-2 p-0" target="_blank">{{ item.tokenId.toString().length > 20 ? (item.tokenId.toString().substring(0, 8) + '...' + item.tokenId.toString().slice(-8)) : item.tokenId.toString() }}</b-button>
                  </div>
                </b-col>
                <b-col cols="1" class="mx-0 px-1">
                  <b-button size="sm" @click="removeTokensForTransfer(index);" variant="link" v-b-popover.hover.bottom="'Remove ' + item.symbol + ' ' + (item.type == 'erc20' ? item.amount : item.tokenId)" class="m-0 ml-2 p-0"><b-icon-dash shift-v="+1" font-scale="1.1"></b-icon-dash></b-button>
                </b-col>
              </b-row>
              <b-row>
                <b-col cols="3" class="mx-0 px-1 text-right">
                </b-col>
                <b-col cols="3" class="mb-1 pr-1">
                </b-col>
                <b-col cols="1" class="mx-0 px-1">
                  <b-button size="sm" @click="addTokensForTransfer();" variant="link" v-b-popover.hover.bottom="'Add ERC-20/ERC-721 tokens to transfer'" class="m-0 ml-2 p-0"><b-icon-plus shift-v="+1" font-scale="1.1"></b-icon-plus></b-button>
                </b-col>
              </b-row>
            </b-form-group>
            <b-form-group label="" label-for="newtransfer-transfer" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!modalNewTransfer.stealthMetaAddress || modalNewTransfer.amount == null || (modalNewTransfer.amount == 0 && modalNewTransfer.items.length == 0)" id="newtransfer-transfer" @click="executeNewTransfer()" variant="warning">Transfer</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALADDTOKENSTOTRANSFER -->
          <b-modal ref="addtokensfortransfer" id="modal-addtokensfortransfer" hide-footer size="md">
            <template #modal-title>Add Tokens For Transfer</template>
            <b-form-select size="sm" v-model="modalAddTokensToNewTransfer.token" @change="additionalTokenSelected" :options="additionalERC20TokensOptions" v-b-popover.hover.bottom="'Select ERC-20 or ERC-721 tokens to transfer'" class="w-100"></b-form-select>
            <div v-if="additionalERC20TokensOptions.length == 1">
              <b-alert size="sm" show variant="warning" class="mt-2">Select active tokens in the Tokens tab first</b-alert>
            </div>
            <b-form-group v-if="modalAddTokensToNewTransfer.token && modalAddTokensToNewTransfer.type =='erc20'" label="Balance:" label-for="newtransfer-additionaltokens-erc20-balance" label-size="sm" label-cols-sm="5" label-align-sm="right" class="mx-0 my-1 p-0">
              <font size="-1">{{ modalAddTokensToNewTransfer.balance }}</font>
            </b-form-group>
            <b-form-group v-if="modalAddTokensToNewTransfer.token && modalAddTokensToNewTransfer.type =='erc20'" label="Approved To Transfer:" label-for="newtransfer-additionaltokens-erc20-approved" label-size="sm" label-cols-sm="5" label-align-sm="right" description="Approval to MagicalInternetMoney for transfer" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input type="text" size="sm" id="newtransfer-additionaltokens-erc20-approved" v-model.trim="modalAddTokensToNewTransfer.approvedInput"></b-form-input>
                <b-input-group-append>
                  <b-button :disabled="modalAddTokensToNewTransfer.approved == modalAddTokensToNewTransfer.approvedInput" @click="updateApproval();" variant="warning"><b-icon-pencil-square shift-v="+1" font-scale="1.1"></b-icon-pencil-square></b-button>
                  <b-button @click="additionalTokenSelected();" variant="link"><b-icon-arrow-repeat shift-v="+1" font-scale="1.1"></b-icon-arrow-repeat></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalAddTokensToNewTransfer.token && modalAddTokensToNewTransfer.type =='erc20'" label="Amount To Transfer:" label-for="newtransfer-additionaltokens-erc20-amounttotransfer" label-size="sm" label-cols-sm="5" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newtransfer-additionaltokens-erc20-amounttotransfer" v-model.trim="modalAddTokensToNewTransfer.amount" class="w-100"></b-form-input>
            </b-form-group>
            <b-form-group v-if="modalAddTokensToNewTransfer.token && modalAddTokensToNewTransfer.type =='erc20'" label="" label-for="newtransfer-additionaltokens-transfer-erc-20" label-size="sm" label-cols-sm="5" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!modalAddTokensToNewTransfer.amount" id="newtransfer-additionaltokens-transfer-erc-20" @click="addERC20TokenToTransfer()" variant="primary">Add To Transfer List</b-button>
            </b-form-group>

            <!-- <b-table v-if="modalAddTokensToNewTransfer.token && modalAddTokensToNewTransfer.type =='erc721'" small fixed striped responsive hover :fields="erc721TokensFields" :items="pagedFilteredSortedERC721Tokens" head-variant="light" class="m-2 p-2 pr-3"> -->
            <b-table v-if="modalAddTokensToNewTransfer.token && modalAddTokensToNewTransfer.type =='erc721'" small fixed striped responsive hover :fields="erc721TokensFields" :items="pagedFilteredSortedERC721Tokens" head-variant="light" class="m-0 mt-1 p-0">
              <template #cell(number)="data">
                <font size="-1">
                  {{ parseInt(data.index) + ((settings.erc721TokensTable.currentPage - 1) * settings.erc721TokensTable.pageSize) + 1 }}
                </font>
              </template>
              <template #cell(tokenId)="data">
                <b-button size="sm" :href="chainInfo.nftTokenPrefix + modalAddTokensToNewTransfer.token + '/' + data.item.tokenId" variant="link" v-b-popover.hover.bottom="data.item.tokenId" class="m-0 ml-2 p-0" target="_blank">{{ data.item.tokenId.toString().length > 20 ? (data.item.tokenId.toString().substring(0, 8) + '...' + data.item.tokenId.toString().slice(-8)) : data.item.tokenId.toString() }}</b-button>
              </template>
              <template #cell(select)="data">
                <b-form-checkbox size="sm" :checked="data.item.selected ? 1 : 0" value="1" @change="erc721TokenIdToggle(data.item.tokenId)" class="ml-2"></b-form-checkbox>
              </template>
            </b-table>
            <b-form-group v-if="modalAddTokensToNewTransfer.token && modalAddTokensToNewTransfer.type =='erc721'" label="Approved To Transfer:" label-for="newtransfer-additionaltokens-erc20-approved" label-size="sm" label-cols-sm="5" label-align-sm="right" description="Approval to MagicalInternetMoney for transfer" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <!-- <b-form-checkbox size="sm" v-model="modalAddTokensToNewTransfer.isApprovedForAllInput" value="true" @change="erc721TokenIdToggle(data.item.tokenId)" class="ml-2"></b-form-checkbox> -->
                <b-form-checkbox size="sm" v-model="modalAddTokensToNewTransfer.isApprovedForAllInput" value="true" unchecked-value="false" class="ml-2"></b-form-checkbox>
                <!-- <b-form-input type="text" size="sm" id="newtransfer-additionaltokens-erc721-approved" v-model.trim="modalAddTokensToNewTransfer.approvedInput"></b-form-input> -->
                <b-input-group-append>
                  <b-button :disabled="modalAddTokensToNewTransfer.isApprovedForAll == modalAddTokensToNewTransfer.isApprovedForAllInput" @click="updateApproval();" variant="warning"><b-icon-pencil-square shift-v="+1" font-scale="1.1"></b-icon-pencil-square></b-button>
                  <b-button @click="additionalTokenSelected();" variant="link"><b-icon-arrow-repeat shift-v="+1" font-scale="1.1"></b-icon-arrow-repeat></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalAddTokensToNewTransfer.token && modalAddTokensToNewTransfer.type =='erc721'" label="" label-for="newtransfer-additionaltokens-transfer-erc721" label-size="sm" label-cols-sm="4" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!modalAddTokensToNewTransfer.token || Object.keys(modalAddTokensToNewTransfer.selectedERC721TokenIds) == 0" id="newtransfer-additionaltokens-transfer-erc721" @click="addERC721TokenToTransfer()" variant="primary">Add To Transfer List</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALTRANSFER -->
          <b-modal id="modal-transfer" hide-footer size="lg">
            <template #modal-title>Stealth Transfer</template>
            <b-form-group v-if="modalTransfer.item" label="Transaction:" label-for="transfer-txhash" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="transfer-txhash" :href="chainInfo.explorerTxPrefix + modalTransfer.item.txHash" variant="link" class="m-0 ml-2 p-0" v-b-popover.hover.bottom="modalTransfer.item.txHash" target="_blank">{{ formatTxHash(modalTransfer.item.txHash) }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalTransfer.item.txHash);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalTransfer.item" label="Timestamp:" label-for="transfer-timestamp" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="transfer-timestamp" v-b-popover.hover.bottom="'Block #' + commify0(modalTransfer.item.blockNumber)">{{ formatTimestamp(modalTransfer.item.timestamp) }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalTransfer.item && modalTransfer.item.tx" label="Sender:" label-for="transfer-sender" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="transfer-registrant" @click="viewAddress(modalTransfer.item.tx.from)" variant="link" v-b-popover.hover.bottom="modalTransfer.item.tx.from" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(modalTransfer.item.tx.from) }}</b-button>
                  <span v-if="modalTransfer.item.iSent"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[modalTransfer.item.senderInfo.type].name" :variant="addressTypeInfo[modalTransfer.item.senderInfo.type].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div v-if="formatAddressNameSecondary(modalTransfer.item.tx.from)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(modalTransfer.item.tx.from) }}</font>
                  </div>
                </div>
                <div>
                  <b-avatar v-if="ensName(modalTransfer.item.tx.from)" rounded variant="light" size="2.5rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensName(modalTransfer.item.tx.from)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
                  <b-button size="sm" @click="copyToClipboard(modalTransfer.item.tx.from);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalTransfer.item && modalTransfer.item.stealthAddress" label="Receiver:" label-for="transfer-receiver" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="transfer-receiver" @click="viewAddress(modalTransfer.item.stealthAddress)" variant="link" v-b-popover.hover.bottom="modalTransfer.item.stealthAddress" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(modalTransfer.item.stealthAddress) }}</b-button>
                  <span v-if="modalTransfer.item.iReceived"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[modalTransfer.item.receiverInfo.type].name" :variant="addressTypeInfo[modalTransfer.item.receiverInfo.type].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div v-if="formatAddressNameSecondary(modalTransfer.item.stealthAddress)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(modalTransfer.item.stealthAddress) }}</font>
                  </div>
                </div>
                <div>
                  <b-avatar v-if="ensName(modalTransfer.item.stealthAddress)" rounded variant="light" size="2.5rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensName(modalTransfer.item.stealthAddress)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
                  <b-button size="sm" @click="copyToClipboard(modalTransfer.item.stealthAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalTransfer.item && modalTransfer.item.linkedTo && modalTransfer.item.linkedTo.stealthMetaAddress" label="Receiver Private Key:" label-for="transfer-spendingprivatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Sign message to reveal the Receiver Stealth Address private key" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input :type="modalTransfer.stealthPrivateKey ? 'text' : 'password'" size="sm" plaintext id="transfer-spendingprivatekey" :value="modalTransfer.stealthPrivateKey ? modalTransfer.stealthPrivateKey : 'A'.repeat(66)" class="px-2"></b-form-input>
                <b-input-group-append>
                  <b-button v-if="!modalTransfer.stealthPrivateKey" :disabled="modalTransfer.item.linkedTo.address != coinbase" @click="revealModalTransferSpendingPrivateKey();" variant="link" class="m-0 ml-2 p-0"><b-icon-eye shift-v="+1" font-scale="1.1"></b-icon-eye></b-button>
                  <b-button v-if="modalTransfer.stealthPrivateKey" @click="copyToClipboard(modalTransfer.stealthPrivateKey ? modalTransfer.stealthPrivateKey : '*'.repeat(66));" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalTransfer.item && modalTransfer.item.linkedTo && modalTransfer.item.linkedTo.address" label="Linked To Address:" label-for="transfer-owner" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="transfer-owner" @click="viewAddress(modalTransfer.item.linkedTo.address)" variant="link" v-b-popover.hover="modalTransfer.item.linkedTo.address" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(modalTransfer.item.linkedTo.address) }}</b-button>
                  <span v-if="modalTransfer.item.iReceived"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[modalTransfer.item.linkedAddressInfo.type].name" :variant="addressTypeInfo[modalTransfer.item.linkedAddressInfo.type].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div v-if="formatAddressNameSecondary(modalTransfer.item.linkedTo.address)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(modalTransfer.item.linkedTo.address) }}</font>
                  </div>
                </div>
                <div>
                  <b-avatar v-if="ensName(modalTransfer.item.linkedTo.address)" rounded variant="light" size="2.5rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensName(modalTransfer.item.linkedTo.address)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
                  <b-button size="sm" @click="copyToClipboard(modalTransfer.item.linkedTo.address);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalTransfer.item && modalTransfer.item.linkedTo && modalTransfer.item.linkedTo.stealthMetaAddress" label="Via Stealth Meta-Address:" label-for="transfer-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="transfer-stealthmetaaddress" @click="viewAddress(modalTransfer.item.linkedTo.stealthMetaAddress)" variant="link" v-b-popover.hover="modalTransfer.item.linkedTo.stealthMetaAddress" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(modalTransfer.item.linkedTo.stealthMetaAddress) }}</b-button>
                  <span v-if="modalTransfer.item.iReceived"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[modalTransfer.item.linkedStealthMetaAddressInfo.type].name" :variant="addressTypeInfo[modalTransfer.item.linkedStealthMetaAddressInfo.type].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div v-if="formatAddressNameSecondary(modalTransfer.item.linkedTo.stealthMetaAddress)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(modalTransfer.item.linkedTo.stealthMetaAddress) }}</font>
                  </div>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalTransfer.item.linkedTo.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalTransfer.item && modalTransfer.item.transfers" label="Transfers:" label-for="transfer-transfers" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <font size="-1">
                <b-row v-for="(item, index) of modalTransfer.item.transfers" v-bind:key="item.token">
                  <b-col cols="3" class="text-right px-0 mt-1">
                    <span v-if="getTokenType(item.token) == 'eth'">
                      <font size="-1">{{ formatETH(item.value) }}</font>
                    </span>
                    <span v-else-if="getTokenType(item.token) == 'erc20'">
                      <font size="-1">{{ formatETH(item.value) }}</font>
                    </span>
                    <span v-else>
                      <b-button size="sm" :href="chainInfo.nftTokenPrefix + item.token + '/' + item.value" variant="link" v-b-popover.hover.bottom="item.value" class="m-0 ml-2 p-0" target="_blank">{{ item.value.toString().length > 20 ? (item.value.toString().substring(0, 8) + '...' + item.value.toString().slice(-8)) : item.value.toString() }}</b-button>
                    </span>
                  </b-col>
                  <b-col cols="3" class="px-0 mt-1">
                    <span v-if="isEthereums(item.token)">
                      <b-button size="sm" disabled variant="transparent" class="m-0 ml-2 p-0">ETH</b-button>
                    </span>
                    <span v-else>
                      <b-button size="sm" :href="chainInfo.explorerTokenPrefix + item.token" variant="link" v-b-popover.hover.bottom="item.tokenId" class="m-0 ml-2 p-0" target="_blank">{{ getTokenSymbol(item.token) }}</b-button>
                    </span>
                  </b-col>
                </b-row>
              </font>
            </b-form-group>
            <b-form-group v-if="settings.showDetails && modalTransfer.item" label="Scheme Id:" label-for="transfer-schemeid" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="transfer-schemeid">{{ modalTransfer.item.schemeId }}</b-button>
            </b-form-group>
            <b-form-group v-if="settings.showDetails && modalTransfer.item && modalTransfer.item.ephemeralPublicKey" label="Ephemeral Public Key:" label-for="transfer-ephemeralpublickey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="transfer-ephemeralpublickey" variant="transparent" v-b-popover.hover.bottom="modalTransfer.item.ephemeralPublicKey" class="m-0 ml-2 p-0">{{ modalTransfer.item.ephemeralPublicKey.substring(0, PUBLICKEY_SEGMENT_LENGTH + 2) + "..." + modalTransfer.item.ephemeralPublicKey.slice(-PUBLICKEY_SEGMENT_LENGTH) }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalTransfer.item.ephemeralPublicKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="settings.showDetails && modalTransfer.item && modalTransfer.item.caller" label="Caller:" label-for="transfer-caller" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="transfer-caller" @click="viewAddress(modalTransfer.item.caller)" variant="link" v-b-popover.hover.bottom="modalTransfer.item.caller" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(modalTransfer.item.caller) }}</b-button>
                  <div v-if="formatAddressNameSecondary(modalTransfer.item.caller)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(modalTransfer.item.caller) }}</font>
                  </div>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalTransfer.item.caller);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
          </b-modal>

          <!-- :MODALREGISTRATION -->
          <b-modal id="modal-registration" hide-footer size="lg">
            <template #modal-title>Registration</template>
            <b-form-group v-if="modalRegistration.item" label="Transaction:" label-for="registration-txhash" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="registration-txhash" :href="chainInfo.explorerTxPrefix + modalRegistration.item.txHash" variant="link" class="m-0 ml-2 p-0" v-b-popover.hover.bottom="modalRegistration.item.txHash" target="_blank">{{ formatTxHash(modalRegistration.item.txHash) }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalRegistration.item.txHash);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalRegistration.item" label="Timestamp:" label-for="registration-timestamp" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="registration-timestamp" v-b-popover.hover.bottom="'Block #' + commify0(modalRegistration.item.blockNumber)">{{ formatTimestamp(modalRegistration.item.timestamp) }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalRegistration.item" label="Registrant:" label-for="registration-registrant" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="registration-registrant" @click="viewAddress(modalRegistration.item.registrant)" variant="link" v-b-popover.hover.bottom="modalRegistration.item.registrant" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(modalRegistration.item.registrant) }}</b-button>
                  <span v-if="modalRegistration.item.mine"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[modalRegistration.item.registrantType].name" :variant="addressTypeInfo[modalRegistration.item.registrantType].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div v-if="formatAddressNameSecondary(modalRegistration.item.registrant)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(modalRegistration.item.registrant) }}</font>
                  </div>
                </div>
                <div>
                  <b-avatar v-if="ensName(modalRegistration.item.registrant)" rounded variant="light" size="2.5rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensName(modalRegistration.item.registrant)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
                  <b-button size="sm" @click="copyToClipboard(modalRegistration.item.registrant);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="settings.showDetails && modalRegistration.item" label="Scheme Id:" label-for="registration-schemeid" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="registration-schemeid">{{ modalRegistration.item.schemeId }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalRegistration.item" label="Stealth Meta-Address:" label-for="registration-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="registration-stealthmetaaddress" @click="viewAddress(modalRegistration.item.stealthMetaAddress)" variant="link" v-b-popover.hover.bottom="modalRegistration.item.stealthMetaAddress" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(modalRegistration.item.stealthMetaAddress) }}</b-button>
                  <span v-if="modalRegistration.item.mine"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo['stealthMetaAddress'].name" :variant="addressTypeInfo['stealthMetaAddress'].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div v-if="formatAddressNameSecondary(modalRegistration.item.stealthMetaAddress)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(modalRegistration.item.stealthMetaAddress) }}</font>
                  </div>
                </div>
                <div>
                  <b-button size="sm" @click="newTransfer(modalRegistration.item.stealthMetaAddress);" variant="link" v-b-popover.hover="'Transfer to ' + modalRegistration.item.stealthMetaAddress" class="m-0 ml-2 p-0"><b-icon-caret-right shift-v="+1" font-scale="1.1"></b-icon-caret-right></b-button>
                  <b-button size="sm" @click="copyToClipboard(modalRegistration.item.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
          </b-modal>

          <!-- :MODALADDRESS -->
          <b-modal id="modal-address" hide-footer size="lg">
            <template #modal-title>Address</template>
            <b-form-group v-if="modalAddress.item && (modalAddress.item.type == 'address' || modalAddress.item.type == 'stealthAddress')" label="Address:" label-for="address-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" :href="chainInfo.explorerAddressPrefix + modalAddress.item.address" variant="link" v-b-popover.hover="modalAddress.item.address" class="m-0 ml-2 p-0" target="_blank">{{ modalAddress.item.address }}</b-button>
                  <span v-if="modalAddress.item.mine"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[modalAddress.item.type].name" :variant="addressTypeInfo[modalAddress.item.type].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div v-if="ensName(modalAddress.item.address)">
                    <font size="-1" class="text-muted">{{ ensName(modalAddress.item.address) }}</font>
                  </div>
                </div>
                <div>
                  <b-avatar v-if="ensName(modalAddress.item.address)" rounded variant="light" size="2.5rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensName(modalAddress.item.address)" v-b-popover.hover="'ENS avatar if set'" class="mt-1"></b-avatar>
                  <b-button size="sm" @click="copyToClipboard(modalAddress.item.address);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalAddress.item" label="Name:" label-for="address-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input type="text" size="sm" id="address-name" v-model.trim="modalAddress.name"></b-form-input>
                <b-input-group-append>
                  <b-button :disabled="modalAddress.name == modalAddress.item.name" @click="saveModalAddressName();" variant="link" class="m-0 ml-2 p-0"><b-icon-pencil-square shift-v="+1" font-scale="1.1"></b-icon-pencil-square></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.viewingPrivateKey" label="Spending Private Key:" label-for="address-spendingprivatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input :type="modalAddress.spendingPrivateKey ? 'text' : 'password'" size="sm" plaintext id="address-spendingprivatekey" :value="modalAddress.spendingPrivateKey ? modalAddress.spendingPrivateKey : 'A'.repeat(66)" class="px-2"></b-form-input>
                <b-input-group-append>
                  <b-button v-if="!modalAddress.spendingPrivateKey" :disabled="modalAddress.item.linkedTo.address != coinbase" @click="revealModalAddressSpendingPrivateKey();" variant="link" class="m-0 ml-2 p-0"><b-icon-eye shift-v="+1" font-scale="1.1"></b-icon-eye></b-button>
                  <b-button v-if="modalAddress.spendingPrivateKey" @click="copyToClipboard(modalAddress.spendingPrivateKey ? modalAddress.spendingPrivateKey : '*'.repeat(66));" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.linkedTo && modalAddress.item.linkedTo.address" label="Linked To Address:" label-for="address-linkedto-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="address-linkedto-address" @click="viewAddress(modalAddress.item.linkedTo.address)" variant="link" v-b-popover.hover="modalAddress.item.linkedTo.address" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(modalAddress.item.linkedTo.address) }}</b-button>
                  <span v-if="modalAddress.item.mine"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[modalAddress.item.linkedAddressType].name" :variant="addressTypeInfo[modalAddress.item.linkedAddressType].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div v-if="formatAddressNameSecondary(modalAddress.item.linkedTo.address)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(modalAddress.item.linkedTo.address) }}</font>
                  </div>
                </div>
                <div>
                  <b-avatar v-if="ensName(modalAddress.item.linkedTo.address)" rounded variant="light" size="2.5rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensName(modalAddress.item.linkedTo.address)" v-b-popover.hover="'ENS avatar if set'" class="mt-1"></b-avatar>
                  <b-button size="sm" @click="copyToClipboard(modalAddress.item.linkedTo.address);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalAddress.item && modalAddress.item.linkedTo && modalAddress.item.linkedTo.stealthMetaAddress" label="Via Stealth Meta-Address:" label-for="address-linkedto-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="address-linkedto-stealthmetaaddress" @click="viewAddress(modalAddress.item.linkedTo.stealthMetaAddress)" variant="link" v-b-popover.hover="modalAddress.item.linkedTo.stealthMetaAddress" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(modalAddress.item.linkedTo.stealthMetaAddress) }}</b-button>
                  <span v-if="modalAddress.item.mine"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[modalAddress.item.linkedStealthMetaAddressType].name" :variant="addressTypeInfo[modalAddress.item.linkedStealthMetaAddressType].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div v-if="formatAddressNameSecondary(modalAddress.item.linkedTo.stealthMetaAddress)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(modalAddress.item.linkedTo.stealthMetaAddress) }}</font>
                  </div>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalAddress.item.linkedTo.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="settings.showDetails && modalAddress.item && modalAddress.item.source" label="Source:" label-for="address-source" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" disabled id="address-source" variant="transparent" class="m-0 ml-2 p-0">{{ sourceOptions.filter(e => e.value == modalAddress.item.source)[0] && sourceOptions.filter(e => e.value == modalAddress.item.source)[0].text || ("Unknown: " + modalAddress.item.source) }}</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALSTEALTHMETAADDRESS -->
          <b-modal id="modal-stealthmetaaddress" hide-footer size="lg">
            <template #modal-title>Stealth Meta-Address</template>
            <b-form-group v-if="modalStealthMetaAddress.item && modalStealthMetaAddress.item.type == 'stealthMetaAddress'" label="Stealth Meta-Address:" label-for="address-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-textarea size="sm" plaintext id="address-stealthmetaaddress" :value="modalStealthMetaAddress.item.address" rows="3" max-rows="4" class="px-2 noscroll"></b-form-textarea>
                <b-input-group-append>
                  <div>
                    <b-button size="sm" @click="newTransfer(modalStealthMetaAddress.item.address);" variant="link" v-b-popover.hover="'Transfer to ' + modalStealthMetaAddress.item.address" class="m-0 ml-2 p-0"><b-icon-caret-right shift-v="+1" font-scale="1.1"></b-icon-caret-right></b-button>
                    <b-button size="sm" @click="copyToClipboard(modalStealthMetaAddress.item.address);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                  </div>
                </b-input-group-append>
              </b-input-group>
              <span v-if="modalStealthMetaAddress.item.mine" class="pl-2"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[modalStealthMetaAddress.item.type].name" :variant="addressTypeInfo[modalStealthMetaAddress.item.type].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
            </b-form-group>
            <b-form-group v-if="modalStealthMetaAddress.item && modalStealthMetaAddress.item.linkedTo && modalStealthMetaAddress.item.linkedTo.stealthMetaAddress" label="Linked To Stealth Meta-Address:" label-for="address-linkedto-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" disabled id="address-linkedto-stealthmetaaddress" :href="chainInfo.explorerAddressPrefix + modalStealthMetaAddress.item.linkedTo.stealthMetaAddress" variant="transparent" class="m-0 ml-2 p-0" target="_blank">{{ formatAddressNamePrimary(modalStealthMetaAddress.item.linkedTo.stealthMetaAddress) }}</b-button>
                  <div v-if="formatAddressNameSecondary(modalStealthMetaAddress.item.linkedTo.stealthMetaAddress)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(modalStealthMetaAddress.item.linkedTo.stealthMetaAddress) }}</font>
                  </div>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalStealthMetaAddress.item.linkedTo.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalStealthMetaAddress.item && modalStealthMetaAddress.item.linkedTo && modalStealthMetaAddress.item.linkedTo.address" label="Linked To Address:" label-for="address-linkedto-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="address-linkedto-address" @click="viewAddress(modalStealthMetaAddress.item.linkedTo.address)" variant="link" v-b-popover.hover="modalStealthMetaAddress.item.linkedTo.address" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(modalStealthMetaAddress.item.linkedTo.address) }}</b-button>
                  <span v-if="modalStealthMetaAddress.item.mine"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[modalStealthMetaAddress.item.linkedAddressType].name" :variant="addressTypeInfo[modalStealthMetaAddress.item.linkedAddressType].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div v-if="formatAddressNameSecondary(modalStealthMetaAddress.item.linkedTo.address)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(modalStealthMetaAddress.item.linkedTo.address) }}</font>
                  </div>
                </div>
                <div>
                  <b-avatar v-if="ensName(modalStealthMetaAddress.item.linkedTo.address)" rounded variant="light" size="2.5rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensName(modalStealthMetaAddress.item.linkedTo.address)" v-b-popover.hover="'ENS avatar if set'" class="mt-1"></b-avatar>
                  <b-button size="sm" @click="copyToClipboard(modalStealthMetaAddress.item.linkedTo.address);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalStealthMetaAddress.item && modalStealthMetaAddress.item.phrase" label="Phrase:" label-for="address-phrase" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input size="sm" plaintext id="address-phrase" :value="modalStealthMetaAddress.item.phrase" class="px-2"></b-form-input>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalStealthMetaAddress.item.phrase);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalStealthMetaAddress.item" label="Name:" label-for="address-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input type="text" size="sm" id="address-name" v-model.trim="modalStealthMetaAddress.name"></b-form-input>
                <b-input-group-append>
                  <b-button :disabled="modalStealthMetaAddress.name == modalStealthMetaAddress.item.name" @click="saveModalStealthMetaAddressName();" variant="link" class="m-0 ml-2 p-0"><b-icon-pencil-square shift-v="+1" font-scale="1.1"></b-icon-pencil-square></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="settings.showDetails && modalStealthMetaAddress.item && modalStealthMetaAddress.item.viewingPrivateKey" label="Spending Private Key:" label-for="address-spendingprivatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input :type="modalStealthMetaAddress.spendingPrivateKey ? 'text' : 'password'" size="sm" plaintext id="address-spendingprivatekey" :value="modalStealthMetaAddress.spendingPrivateKey ? modalStealthMetaAddress.spendingPrivateKey : 'A'.repeat(66)" class="px-2"></b-form-input>
                <b-input-group-append>
                  <b-button v-if="!modalStealthMetaAddress.spendingPrivateKey" :disabled="modalStealthMetaAddress.item.linkedTo.address != coinbase" @click="revealModalAddressSpendingPrivateKey();" variant="link" class="m-0 ml-2 p-0"><b-icon-eye shift-v="+1" font-scale="1.1"></b-icon-eye></b-button>
                  <b-button v-if="modalStealthMetaAddress.spendingPrivateKey" @click="copyToClipboard(modalStealthMetaAddress.spendingPrivateKey ? modalStealthMetaAddress.spendingPrivateKey : '*'.repeat(66));" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="settings.showDetails && modalStealthMetaAddress.item && modalStealthMetaAddress.item.viewingPrivateKey" label="Viewing Private Key:" label-for="address-viewingprivatekey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input size="sm" plaintext id="address-viewingprivatekey" :value="modalStealthMetaAddress.item.viewingPrivateKey" class="px-2"></b-form-input>
                <b-input-group-append>
                  <b-button size="sm" @click="copyToClipboard(modalStealthMetaAddress.item.viewingPrivateKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="settings.showDetails && modalStealthMetaAddress.item && modalStealthMetaAddress.item.spendingPublicKey" label="Spending Public Key:" label-for="address-spendingpublickey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input size="sm" plaintext id="address-spendingpublickey" :value="modalStealthMetaAddress.item.spendingPublicKey" class="px-2"></b-form-input>
                <b-input-group-append>
                  <b-button size="sm" @click="copyToClipboard(modalStealthMetaAddress.item.spendingPublicKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="settings.showDetails && modalStealthMetaAddress.item && modalStealthMetaAddress.item.viewingPublicKey" label="Viewing Public Key:" label-for="address-viewingpublickey" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input size="sm" plaintext id="address-viewingpublickey" :value="modalStealthMetaAddress.item.viewingPublicKey" class="px-2"></b-form-input>
                <b-input-group-append>
                  <b-button size="sm" @click="copyToClipboard(modalStealthMetaAddress.item.viewingPublicKey);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="settings.showDetails && modalStealthMetaAddress.item && modalStealthMetaAddress.item.source" label="Source:" label-for="address-source" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" disabled id="address-source" variant="transparent" class="m-0 ml-2 p-0">{{ sourceOptions.filter(e => e.value == modalStealthMetaAddress.item.source)[0] && sourceOptions.filter(e => e.value == modalStealthMetaAddress.item.source)[0].text || ("Unknown: " + modalStealthMetaAddress.item.source) }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalStealthMetaAddress.item && modalStealthMetaAddress.item.linkedTo" label="" label-for="address-addtoregistry" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="'Add or update in registry'" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="modalStealthMetaAddress.item.linkedTo.address != coinbase" id="address-addtoregistry" @click="addStealthMetaAddressToRegistry(modalStealthMetaAddress.item.address)" variant="warning">{{ 'Add/Update' }}</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALNEWSTEALTHMETAADDRESS -->
          <b-modal id="modal-newstealthmetaaddress" hide-footer size="lg">
            <template #modal-title>Generate New Stealth Meta-Address</template>
            <b-form-group label="Attached Address:" label-for="newsma-attachedaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" id="newsma-attachedaddress" @click="viewAddress(coinbase)" variant="link" v-b-popover.hover="coinbase" class="m-0 ml-2 p-0">{{ formatAddressNamePrimary(coinbase) }}</b-button>
                  <div v-if="formatAddressNameSecondary(coinbase)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(coinbase) }}</font>
                  </div>
                </div>
                <div>
                  <b-avatar v-if="ensName(coinbase)" rounded variant="light" size="2.5rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + ensName(coinbase)" v-b-popover.hover="'ENS avatar if set'"></b-avatar>
                  <b-button size="sm" @click="copyToClipboard(coinbase);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group label="Name:" label-for="newsma-smaname" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-form-input type="text" size="sm" id="newsma-smaname" v-model.trim="modalNewStealthMetaAddress.name" class="w-50"></b-form-input>
            </b-form-group>
            <b-form-group label="Phrase:" label-for="newsma-phrase" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0" description="This exact phrase with the attached address is required for the recovery of your stealth keys!">
              <b-input-group size="sm" class="w-100">
                <b-form-input type="text" size="sm" id="newsma-phrase" v-model.trim="modalNewStealthMetaAddress.phrase"></b-form-input>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalNewStealthMetaAddress.phrase);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group label="" label-for="newsma-generate" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Sign the phrase above with your web3 attached address" class="mx-0 my-1 p-0">
              <b-button size="sm" id="newsma-generate" @click="generateNewStealthMetaAddress()" variant="warning">Generate</b-button>
            </b-form-group>
            <b-form-group v-if="modalNewStealthMetaAddress.stealthMetaAddress" label="Stealth Meta-Address:" label-for="newsma-stealthmetaaddress" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-textarea size="sm" plaintext id="newsma-stealthmetaaddress" :value="modalNewStealthMetaAddress.stealthMetaAddress" rows="3" max-rows="4" class="px-2 noscroll"></b-form-textarea>
                <b-input-group-append>
                  <b-button @click="copyToClipboard(modalNewStealthMetaAddress.stealthMetaAddress);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group v-if="modalNewStealthMetaAddress.stealthMetaAddress" label="" label-for="newsma-addtoaddressbook" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="modalNewStealthMetaAddress.status == 'mine' ? 'Update address with stealth keys' : (modalNewStealthMetaAddress.status == 'notmine' ? 'Already in addresses, to be claimed' : 'Add new to addresses')" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!modalNewStealthMetaAddress.stealthMetaAddress" id="newsma-addtoaddressbook" @click="addStealthMetaAddressToAddresses()" variant="warning">{{ modalNewStealthMetaAddress.status == 'mine' ? 'Update' : (modalNewStealthMetaAddress.status == 'notmine' ? 'Claim' : 'Add') }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalNewStealthMetaAddress.stealthMetaAddress" label="" label-for="newsma-addtoregistry" label-size="sm" label-cols-sm="3" label-align-sm="right" :description="'Add or update in registry'" class="mx-0 my-1 p-0">
              <b-button size="sm" :disabled="!modalNewStealthMetaAddress.stealthMetaAddress" id="newsma-addtoregistry" @click="addStealthMetaAddressToRegistry(modalNewStealthMetaAddress.stealthMetaAddress)" variant="warning">{{ 'Add/Update' }}</b-button>
            </b-form-group>
          </b-modal>

          <!-- :MODALCONTRACT -->
          <b-modal id="modal-contract" hide-footer size="lg">
            <template #modal-title>{{ contractTypeOptions.filter(e => e.value == modalContract.item.type)[0] && contractTypeOptions.filter(e => e.value == modalContract.item.type)[0].text || ("Unknown: " + modalContract.item.type) }}</template>
            <b-form-group v-if="modalContract.item && modalContract.item.chainId" label="Chain:" label-for="contract-chain" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="contract-chain">{{ settings.chains[modalContract.item.chainId] && settings.chains[modalContract.item.chainId].name || ("Unconfigured ChainId: " + modalContract.item.chainId) }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalContract.item && modalContract.item.contract" label="Address:" label-for="contract-address" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <div class="d-flex justify-content-between">
                <div>
                  <b-button size="sm" :href="chainInfo.explorerAddressPrefix + modalContract.item.contract" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ formatAddress(modalContract.item.contract) }}</b-button>
                </div>
                <div>
                  <b-button size="sm" @click="copyToClipboard(modalContract.item.contract);" variant="link" class="m-0 ml-2 p-0"><b-icon-clipboard shift-v="+1" font-scale="1.1"></b-icon-clipboard></b-button>
                </div>
              </div>
            </b-form-group>
            <b-form-group v-if="modalContract.item && modalContract.item.type" label="Type:" label-for="contract-type" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="transparent" id="contract-type">{{ contractTypeOptions.filter(e => e.value == modalContract.item.type)[0] && contractTypeOptions.filter(e => e.value == modalContract.item.type)[0].text || ("Unknown: " + modalContract.item.type) }}</b-button>
            </b-form-group>
            <b-form-group v-if="modalContract.item && modalContract.item.timestamp" label="First Event:" label-for="contract-timestamp" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-button size="sm" variant="link" id="contract-timestamp" :href="chainInfo.explorerBlockPrefix + modalContract.item.blockNumber" v-b-popover.hover.bottom="'Block #' + commify0(modalContract.item.blockNumber)" target="_blank">{{ formatTimestamp(modalContract.item.timestamp) }}</b-button>
            </b-form-group>
            <b-form-group label="Name:" label-for="modalcontract-name" label-size="sm" label-cols-sm="3" label-align-sm="right" class="mx-0 my-1 p-0">
              <b-input-group size="sm" class="w-100">
                <b-form-input type="text" size="sm" id="modalcontract-name" v-model.trim="modalContract.name"></b-form-input>
                <b-input-group-append>
                  <b-button :disabled="modalContract.name == (modalContract.item && modalContract.item.name)" @click="saveModalContractName();" variant="link" class="m-0 ml-2 p-0"><b-icon-pencil-square shift-v="+1" font-scale="1.1"></b-icon-pencil-square></b-button>
                </b-input-group-append>
              </b-input-group>
            </b-form-group>
            <b-form-group label="Read:" label-for="contract-read" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Read event logs involving this contract" class="mx-0 my-1 p-0">
              <b-form-checkbox size="sm" id="contract-read" value="1" :checked="modalContract.read ? 1 : 0" @change="toggleContractRead()" class="mt-1 ml-2"></b-form-checkbox>
            </b-form-group>
            <b-form-group label="Write:" label-for="contract-write" label-size="sm" label-cols-sm="3" label-align-sm="right" description="Send transactions to contract, where supported" class="mx-0 my-1 p-0">
              <b-form-checkbox size="sm" id="contract-write" value="1" :checked="modalContract.write ? 1 : 0" @change="toggleContractWrite()" class="mt-1 ml-2"></b-form-checkbox>
            </b-form-group>
          </b-modal>

          <b-card class="m-0 p-0 border-0" body-class="m-1 p-0">
            <!-- :TOOLBAR -->
            <b-card-text v-if="coinbase" class="m-0 p-0">
              <div class="d-flex flex-wrap m-0 p-0">
                <div v-if="settings.tabIndex == 1" class="mt-0 pr-1">
                  <b-form-input type="text" size="sm" v-model.trim="settings.transfersTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Filter by name, ENS name or address regex'" placeholder=" name or addr regex"></b-form-input>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pr-1">
                  <b-form-input type="text" size="sm" v-model.trim="settings.registrationsTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Filter by name, ENS name or address regex'" placeholder=" name or addr regex"></b-form-input>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pr-1">
                  <b-form-input type="text" size="sm" v-model.trim="settings.addressesTable.filter" @change="saveSettings" debounce="600" v-b-popover.hover.top="'Filter by name, ENS name or address regex'" placeholder=" name or addr regex"></b-form-input>
                </div>
                <div v-if="settings.tabIndex == 1" class="mt-0 pr-1">
                  <b-form-select size="sm" v-model="settings.transfersTable.iSentIReceived" @change="saveSettings" :options="iSentIReceivedOptions" v-b-popover.hover.bottom="'Transfer type'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-1 pr-1">
                  <b-form-checkbox size="sm" v-model.trim="settings.registrationsTable.mineOnly" @input="saveSettings" v-b-popover.hover.bottom="'Only display my items'">Mine Only</b-form-checkbox>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-1 pr-1">
                  <b-form-checkbox size="sm" v-model.trim="settings.addressesTable.mineOnly" @input="saveSettings" v-b-popover.hover.bottom="'Only display my items'">Mine Only</b-form-checkbox>
                </div>
                <div v-if="settings.tabIndex == 4" class="mt-1 pr-1">
                  <b-form-checkbox size="sm" v-model.trim="settings.tokenContractsTable.activeOnly" @input="saveSettings" v-b-popover.hover.bottom="'Only display Active items'">Active Only</b-form-checkbox>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="!sync.section" class="mt-0 pr-1">
                  <b-button size="sm" @click="saveSettings(); viewModalSyncOptions();" variant="primary" v-b-popover.hover.bottom="'Sync stealth address announcement events'">Sync</b-button>
                </div>
                <div v-if="sync.section" class="mt-1 p-0" style="width: 300px;">
                  <b-progress height="1.5rem" :max="sync.total" show-progress :animated="!sync.section" :variant="sync.section ? 'success' : 'secondary'" v-b-popover.hover.bottom="'Click the button on the right to stop this process'">
                    <b-progress-bar :value="sync.completed">
                      {{ sync.total == null || sync.total == 0 ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                    </b-progress-bar>
                  </b-progress>
                </div>
                <!-- <div class="ml-0 mt-1">
                  <b-link v-if="sync.section" size="sm" @click="halt" variant="link" v-b-popover.hover.bottom="'Click to stop. It may take a few minutes to clean up. This process can be continued later'"><b-icon-stop-fill shift-v="+1" font-scale="1.0"></b-icon-stop-fill></b-link>
                </div> -->
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <b-button size="sm" @click="newStealthMetaAddress" variant="link" v-b-popover.hover.bottom="'Generate new Stealth Meta-Address'"><b-icon-plus shift-v="+1" font-scale="1.0"></b-icon-plus></b-button>
                </div>
                <div class="mt-0 pl-1">
                  <b-button size="sm" @click="newTransfer(null);" variant="link" v-b-popover.hover.bottom="'Transfer to Stealth Meta-Address'"><b-icon-caret-right shift-v="+1" font-scale="1.0"></b-icon-caret-right></b-button>
                </div>
                <div v-if="settings.tabIndex == 1 || settings.tabIndex == 3" class="mt-0 flex-grow-1">
                </div>
                <div v-if="settings.tabIndex == 1" class="mt-0 pl-1">
                  <b-button size="sm" @click="downloadTransfers" variant="link" v-b-popover.hover.bottom="'Download transfers'"><b-icon-file-earmark-spreadsheet shift-v="+1" font-scale="1.2"></b-icon-file-earmark-spreadsheet></b-button>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <b-button size="sm" @click="downloadAddresses" variant="link" v-b-popover.hover.bottom="'Download addresses'"><b-icon-file-earmark-spreadsheet shift-v="+1" font-scale="1.2"></b-icon-file-earmark-spreadsheet></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div class="mt-0 pl-1">
                  <b-button size="sm" :pressed.sync="settings.showInfo" @click="saveSettings" variant="link" v-b-popover.hover.bottom="'Show info'"><span v-if="settings.showInfo"><b-icon-info-circle-fill shift-v="+1" font-scale="1.0"></b-icon-info-circle-fill></span><span v-else><b-icon-info-circle shift-v="+1" font-scale="1.0"></b-icon-info-circle></span></b-button>
                </div>
                <div class="mt-0 flex-grow-1">
                </div>
                <div v-if="settings.tabIndex == 1" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.transfersTable.sortOption" @change="saveSettings" :options="announcementsSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.registrationsTable.sortOption" @change="saveSettings" :options="registrationsSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.addressesTable.sortOption" @change="saveSettings" :options="addressesSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 4" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.tokenContractsTable.sortOption" @change="saveSettings" :options="tokenContractsSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 1" class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.bottom="'# events'">{{ commify0(filteredTransfers.length) + '/' + commify0(transfers.length) }}</font>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.bottom="'# registrations'">{{ commify0(filteredRegistrations.length) + '/' + commify0(registrations.length) }}</font>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.bottom="'# addresses'">{{ commify0(filteredAddresses.length) + '/' + commify0(totalAddresses) }}</font>
                </div>
                <div v-if="settings.tabIndex == 4" class="mt-0 pl-1">
                  <font size="-2" v-b-popover.hover.bottom="'# token events'">{{ commify0(filteredTokenContracts.length) + '/' + commify0(filteredTokenContracts.length) }}</font>
                </div>
                <div v-if="settings.tabIndex == 1" class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.transfersTable.currentPage" @input="saveSettings" :total-rows="filteredTransfers.length" :per-page="settings.transfersTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.registrationsTable.currentPage" @input="saveSettings" :total-rows="filteredRegistrations.length" :per-page="settings.registrationsTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.addressesTable.currentPage" @input="saveSettings" :total-rows="filteredAddresses.length" :per-page="settings.addressesTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 4" class="mt-0 pl-1">
                  <b-pagination size="sm" v-model="settings.tokenContractsTable.currentPage" @input="saveSettings" :total-rows="filteredTokenContracts.length" :per-page="settings.tokenContractsTable.pageSize" style="height: 0;"></b-pagination>
                </div>
                <div v-if="settings.tabIndex == 1" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.transfersTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 2" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.registrationsTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 3" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.addressesTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
                <div v-if="settings.tabIndex == 4" class="mt-0 pl-1">
                  <b-form-select size="sm" v-model="settings.tokenContractsTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                </div>
              </div>
            </b-card-text>

            <b-card-text class="m-0 p-0">
              <!-- :INFO -->
              <b-card v-if="settings.showInfo || coinbase == null" no-body class="my-1 p-1">
                <b-card-body class="mt-1 p-1">
                  <h4>Welcome</h4>
                  Stealth Chad is an implementation of <b-link href="https://eips.ethereum.org/EIPS/eip-5564" target="_blank">ERC-5564: Stealth Addresses</b-link> and <b-link href="https://eips.ethereum.org/EIPS/eip-6538" target="_blank">ERC-6538: Stealth Meta-Address Registry</b-link> (using <i>address</i> instead of <i>bytes</i>).

                  <h5 class="mt-4">How The ERC-5564: Stealth Addresses Protocol Works</h5>
                  <ul>
                    <li>Alice wants to pay Bob in ETH/ERC-20/ERC-721 tokens</li>
                    <li>Bob generates a <i>Stealth Meta-Address</i> and provides this to Alice</li>
                    <li>Alice uses Bob's <i>Stealth Meta-Address</i> to compute a random <i>Stealth Address</i> that can be accessed only by Bob</li>
                    <li>Alice transfers the tokens to this address and announces the transfers in the <i>ERC-5564: Stealth Address Announcer</i> contract</li>
                    <li>Bob can access the private keys to their computed <i>Stealth Addresses</i>, using information included in the announcements</li>
                    <li>The <i>ERC-6538: Stealth Meta-Address Registry</i> allows any account to publish their associated <i>Stealth Meta-Addresses</i></li>
                  </ul>

                  <h5 class="mt-4">How This Dapp Works</h5>
                  This dapp:
                  <ul>
                    <li>Allows Bob's web3 attached account to generate a unique <i>Stealth Meta-Address</i> for each unique associated <i>phrase</i></li>
                    <li>Allows Bob to publish one or more <i>Stealth Meta-Addresses</i> associated with thier web3 attached accounts and unique <i>phrase</i></li>
                    <li>Allows Alice to compute a random <i>Stealth Address</i> using Bob's <i>Stealth Meta-Address</i></li>
                    <li>Allows Alice to then execute the transfer to Bob's <i>Stealth Address</i> and announce the transfer to the <i>Announcer</i></li>
                    <li>Retrieve all event logs published to the <i>Announcer</i>. Alice's transfer to Bob will appear in this data</li>
                    <li>Retrieves all event logs published to the <i>Registry</i></li>
                  </ul>

                  <!-- <h5 class="mt-3">Requirements</h5>
                  <ul>
                    <li>This dapp runs in web3 enabled desktop browsers connected to the Ethereum mainnet, and should work with other Ethereum-Virtual-Machine compatible chains</li>
                  </ul> -->

                  <h5 class="mt-3">Contracts on Sepolia</h5>
                  <ul>
                    <li><b-link href="https://sepolia.etherscan.io/address/0xFe6335f5dc5a469e74fB6a9FDAe116bFD5346365#code" target="_blank">ERC5564Announcer v0.8.1</b-link></li>
                    <li><b-link href="https://sepolia.etherscan.io/address/0x5F8ac9e3B2DD28cA2c9bc7A992Ce36c3C4929Cde#code" target="_blank">ERC5564Registry v0.8.1</b-link></li>
                    <li><b-link href="https://sepolia.etherscan.io/address/0xA745760E9f1E425215CCD7735F932FdDE3276344#code" target="_blank">StealthChad v0.8.1</b-link></li>
                  </ul>

                  <h5 class="mt-3">References</h5>
                  <ul>
                    <li><b-link href="https://eips.ethereum.org/EIPS/eip-5564" target="_blank">ERC-5564: Stealth Addresses</b-link></li>
                    <li><b-link href="https://eips.ethereum.org/EIPS/eip-6538" target="_blank">ERC-6538: Stealth Meta-Address Registry</b-link></li>
                  </ul>

                  <h5 class="mt-3">This Dapp</h5>
                  <ul>
                    <li>Dapp: <b-link href="https://bokkypoobah.github.io/MagicalInternetMoney/" target="_blank">https://bokkypoobah.github.io/MagicalInternetMoney/</b-link></li>
                    <li>GitHub: <b-link href="https://github.com/bokkypoobah/MagicalInternetMoney" target="_blank">https://github.com/bokkypoobah/MagicalInternetMoney</b-link></li>
                    <li>Main Dapp Source Code: <b-link href="https://github.com/bokkypoobah/MagicalInternetMoney/blob/main/docs/index.html" target="_blank">https://github.com/bokkypoobah/MagicalInternetMoney/blob/main/docs/index.html</b-link></li>
                  </ul>

                  <!-- <h5 class="mt-3">Running Locally</h5>
                  <ul>
                    <li>In a folder on your computer, <b>git clone <b-link href="https://github.com/bokkypoobah/MagicalInternetMoney" target="_blank">https://github.com/bokkypoobah/MagicalInternetMoney</b-link></b></li>
                    <li>Run a tool like <b-link href="https://www.npmjs.com/package/anywhere" target="_blank">anywhere</b-link> in the <b>./docs</b> subdirectory of the folder created above</li>
                  </ul> -->

                  <!-- <h5 class="mt-3">Design</h5>
                  <ul>
                    <li>This dapp is designed to have minimal external dependencies - all code is statically served from GitHub</li>
                    <li>No backend servers are necessary, only a web3 connection</li>
                  </ul> -->

                  <!-- <h5 class="mt-3">Warning</h5>
                  <ul>
                    <li>This is experimental unaudited software. Please check your transaction data carefully when updating your approvals!</li>
                  </ul> -->

                  <h5 class="mt-3">Troubleshooting</h5>
                  <ul>
                    <li>If this dapp is not receiving the latest Mainnet data, reset your MetaMask web3 connection using <b>Settings</b> -> <b>Advanced</b> -> <b>Clear activity and nonce data</b></li>
                    <li>Reset this dapp data by removing LocalStorage entries with the keys beginning with <b>MagicalInternetMoney</b></li>
                  </ul>
                </b-card-body>
              </b-card>

              <!-- :DASHBOARD -->
              <b-row v-if="settings.tabIndex == 0 && !settings.showInfo && coinbase != null" class="m-0 p-0">
                <b-col class="m-0 p-0 pt-1 pr-1">
                  <b-card no-body class="m-0 p-1">
                    <h5>Stealth Transfers Received</h5>
                    <font size="-2">
                      <pre>
{{ received }}
                      </pre>
                    </font>
                  </b-card>
                </b-col>
                <b-col class="m-0 p-0 pt-1 pl-1">
                  <b-card no-body class="m-0 p-1">
                    <h5>Stealth Transfers Sent</h5>
                    <font size="-2">
                      <pre>
{{ sent }}
                      </pre>
                    </font>
                  </b-card>
                </b-col>
              </b-row>
              <!-- <div v-if="settings.tabIndex == 0 && !settings.showInfo && coinbase != null">
                <font size="-2">
                  <pre>
{{ transfers }}
                  </pre>
                </font>
              </div> -->

              <!-- :TRANSFERS -->
              <b-table v-if="settings.tabIndex == 1 && !settings.showInfo" ref="transfersTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='transferRowSelected' :fields="transfersFields" :items="pagedFilteredSortedTransfers" show-empty empty-html="Click Sync above to retrieve ERC-5564: Stealth Addresses announcement events" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.transfersTable.currentPage - 1) * settings.transfersTable.pageSize) + 1 }}
                  </font>
                </template>
                <template #cell(timestamp)="data">
                  <font size="-1">
                    <b-link :href="chainInfo.explorerTxPrefix + data.item.txHash" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber) + ', txIndex: ' + data.item.txIndex + ', logIndex: ' + data.item.logIndex" target="_blank">
                      <span v-if="data.item.timestamp">
                        {{ formatTimestamp(data.item.timestamp) }}
                      </span>
                      <span v-else>
                        {{ '#' + commify0(data.item.blockNumber) }}
                      </span>
                    </b-link>
                  </font>
                  <div>
                    &nbsp;
                  </div>
                </template>
                <template #cell(iSent)="data">
                  <b-form-checkbox size="sm" disabled :checked="data.item.iSent" class="mt-1 ml-2"></b-form-checkbox>
                </template>
                <template #cell(sender)="data">
                  <div v-if="data.item.tx && data.item.tx.from">
                    <b-link @click="viewAddress(data.item.tx.from)">
                      <font size="-1" v-b-popover.hover="addressDescription(data.item.tx.from)">{{ formatAddressNamePrimary(data.item.tx.from) }}</font>
                    </b-link>
                    <span v-if="data.item.iSent"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[data.item.senderInfo.type].name" :variant="addressTypeInfo[data.item.senderInfo.type].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                    <div v-if="formatAddressNameSecondary(data.item.tx.from)">
                      <font size="-1" class="text-muted">{{ formatAddressNameSecondary(data.item.tx.from) }}</font>
                    </div>
                  </div>
                </template>
                <template #cell(iReceived)="data">
                  <b-form-checkbox size="sm" disabled :checked="data.item.iReceived" class="mt-1 ml-2"></b-form-checkbox>
                </template>
                <template #cell(receiver)="data">
                  <b-link @click="viewAddress(data.item.stealthAddress)">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.stealthAddress)">{{ formatAddressNamePrimary(data.item.stealthAddress) }}</font>
                  </b-link>
                  <span v-if="data.item.iReceived"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[data.item.receiverInfo.type].name" :variant="addressTypeInfo[data.item.receiverInfo.type].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div v-if="formatAddressNameSecondary(data.item.stealthAddress)">
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(data.item.stealthAddress) }}</font>
                  </div>
                </template>
                <template #cell(linkedToAddress)="data">
                  <div v-if="data.item.linkedTo && data.item.linkedTo.address">
                    <b-link @click="viewAddress(data.item.linkedTo.address)">
                      <font size="-1" v-b-popover.hover="addressDescription(data.item.linkedTo.address)">{{ formatAddressNamePrimary(data.item.linkedTo.address) }}</font>
                    </b-link>
                    <span v-if="data.item.iReceived"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[data.item.linkedAddressInfo.type].name" :variant="addressTypeInfo[data.item.linkedAddressInfo.type].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                    <div v-if="formatAddressNameSecondary(data.item.linkedTo.address)">
                      <font size="-1" class="text-muted">{{ formatAddressNameSecondary(data.item.linkedTo.address) }}</font>
                    </div>
                  </div>
                </template>
                <template #cell(viaStealthMetaAddress)="data">
                  <div v-if="data.item.linkedTo && data.item.linkedTo.stealthMetaAddress">
                    <b-link @click="viewAddress(data.item.linkedTo.stealthMetaAddress)">
                      <font size="-1" v-b-popover.hover="addressDescription(data.item.linkedTo.stealthMetaAddress)">{{ formatAddressNamePrimary(data.item.linkedTo.stealthMetaAddress) }}</font>
                    </b-link>
                    <span v-if="data.item.iReceived"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[data.item.linkedStealthMetaAddressInfo.type].name" :variant="addressTypeInfo[data.item.linkedStealthMetaAddressInfo.type].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                    <div v-if="formatAddressNameSecondary(data.item.linkedTo.stealthMetaAddress)">
                      <font size="-1" class="text-muted">{{ formatAddressNameSecondary(data.item.linkedTo.stealthMetaAddress) }}</font>
                    </div>
                  </div>
                </template>
                <template #cell(tokens)="data">
                  <b-row v-for="(item, index) of data.item.transfers" v-bind:key="item.token">
                    <b-col>
                      <span v-if="getTokenType(item.token) == 'eth'">
                        <font size="-1">{{ formatETH(item.value) }}</font>
                      </span>
                      <span v-else-if="getTokenType(item.token) == 'erc20'">
                        <font size="-1">{{ formatETH(item.value) }}</font>
                      </span>
                      <span v-else>
                        <b-button size="sm" :href="chainInfo.nftTokenPrefix + item.token + '/' + item.value" variant="link" v-b-popover.hover.bottom="item.value" class="m-0 ml-2 p-0" target="_blank">{{ item.value.toString().length > 20 ? (item.value.toString().substring(0, 8) + '...' + item.value.toString().slice(-8)) : item.value.toString() }}</b-button>
                      </span>
                    </b-col>
                  </b-row>
                </template>
                <template #cell(token)="data">
                  <b-row v-for="(item, index) of data.item.transfers" v-bind:key="item.token">
                    <b-col>
                      <span v-if="isEthereums(item.token)">
                        <b-button size="sm" disabled variant="transparent" class="m-0 ml-2 p-0">ETH</b-button>
                      </span>
                      <span v-else>
                        <b-button size="sm" :href="chainInfo.explorerTokenPrefix + item.token" variant="link" v-b-popover.hover.bottom="item.tokenId" class="m-0 ml-2 p-0" target="_blank">{{ getTokenSymbol(item.token) }}</b-button>
                      </span>
                    </b-col>
                  </b-row>
                </template>
              </b-table>

              <!-- :DIRECTORY -->
              <b-table v-if="settings.tabIndex == 2 && !settings.showInfo" ref="registrationsTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='registrationRowSelected' :fields="registrationsFields" :items="pagedFilteredSortedRegistrations" show-empty empty-html="Click Sync above to retrieve ERC-6538: Stealth Meta-Address Registry events" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.registrationsTable.currentPage - 1) * settings.registrationsTable.pageSize) + 1 }}
                  </font>
                </template>
                <template #cell(timestamp)="data">
                  <font size="-1">
                    <b-link :href="chainInfo.explorerTxPrefix + data.item.txHash" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber) + ', txIndex: ' + data.item.txIndex + ', logIndex: ' + data.item.logIndex" target="_blank">
                      <span v-if="data.item.timestamp">
                        {{ formatTimestamp(data.item.timestamp) }}
                      </span>
                      <span v-else>
                        {{ '#' + commify0(data.item.blockNumber) }}
                      </span>
                    </b-link>
                  </font>
                </template>
                <template #cell(registrant)="data">
                  <b-link @click="viewAddress(data.item.registrant)">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.registrant)">{{ formatAddressNamePrimary(data.item.registrant) }}</font>
                  </b-link>
                  <span v-if="data.item.mine"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[data.item.registrantType].name" :variant="addressTypeInfo[data.item.registrantType].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div>
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(data.item.registrant) || '&nbsp' }}</font>
                  </div>
                </template>
                <template #cell(mine)="data">
                  <b-form-checkbox size="sm" disabled value="1" :checked="data.item.mine ? 1 : 0" class="mt-1 ml-2"></b-form-checkbox>
                </template>
                <template #cell(schemeId)="data">
                  <font size="-1">{{ data.item.schemeId }}</font>
                </template>
                <template #cell(transfer)="data">
                  <b-button size="sm" @click="newTransfer(data.item.stealthMetaAddress);" variant="link" v-b-popover.hover="'Transfer to ' + data.item.stealthMetaAddress" class="m-0 ml-2 p-0"><b-icon-caret-right shift-v="+1" font-scale="1.1"></b-icon-caret-right></b-button>
                </template>
                <template #cell(stealthMetaAddress)="data">
                  <b-link @click="viewAddress(data.item.stealthMetaAddress)">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.stealthMetaAddress)">{{ formatAddressNamePrimary(data.item.stealthMetaAddress) }}</font>
                  </b-link>
                  <span v-if="data.item.mine"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo['stealthMetaAddress'].name" :variant="addressTypeInfo['stealthMetaAddress'].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div>
                    <font size="-1" class="text-muted">{{ formatAddressNameSecondary(data.item.stealthMetaAddress) }}</font>
                  </div>
                </template>
                <!-- <template #cell(contract)="data">
                  <b-link :href="'https://sepolia.etherscan.io/address/' + data.item.contract" target="_blank">
                    <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.contract)" class="px-0">{{ nameOrAddress(data.item.contract, 28) }}</b-badge>
                  </b-link>
                </template> -->
                <!-- <template #cell(details)="data">
                  <font size="-1">
                    <pre>
      {{ data.item }}
                    </pre>
                  </font>
                </template> -->
              </b-table>

              <!-- :ADDRESSES -->
              <b-table v-if="settings.tabIndex == 3 && !settings.showInfo" ref="addressesTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='addressesRowSelected' :fields="addressesFields" :items="pagedFilteredSortedAddresses" show-empty empty-html="Click Sync above to retrieve addresses from ERC-5564: Stealth Addresses announcement and ERC-6538: Stealth Meta-Address Registry events" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.addressesTable.currentPage - 1) * settings.addressesTable.pageSize) + 1 }}
                  </font>
                </template>
                <template #cell(transfer)="data">
                  <div v-if="data.item.address.substring(0, 2) == 'st'">
                    <b-button size="sm" @click="newTransfer(data.item.address);" variant="link" v-b-popover.hover="'Transfer to ' + data.item.address" class="m-0 ml-2 p-0"><b-icon-caret-right shift-v="+1" font-scale="1.1"></b-icon-caret-right></b-button>
                  </div>
                </template>
                <template #cell(address)="data">
                  <b-link @click="viewAddress(data.item.address)" v-b-popover.hover="addressDescription(data.item.address)">
                    <font size="-1">{{ formatAddress(data.item.address) }}</font>
                  </b-link>
                  <span v-if="data.item.mine"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[data.item.type].name" :variant="addressTypeInfo[data.item.type].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                  <div>
                    &nbsp;
                  </div>
                </template>
                <!-- <template #head(linkedToAddress)="data">
                  <span v-b-popover.hover="'Linked to Address'">
                    <b-icon-link shift-v="+1" font-scale="0.9"></b-icon-link> Address
                  </span>
                </template> -->
                <!-- <template #head(viaStealthMetaAddress)="data">
                  <span v-b-popover.hover="'Linked via Stealth Meta-Address'">
                    <b-icon-link shift-v="+1" font-scale="0.9"></b-icon-link> Stealth Meta-Address
                  </span>
                </template> -->
                <template #cell(name)="data">
                  <!-- <font size="-1">{{ data.item.ensName ? (data.item.ensName + (data.item.name ? ('; ' + data.item.name) : '')) : data.item.name }}</font> -->
                  <font size="-1">{{ nameOrNull(data.item.address) }}</font>
                </template>
                <template #cell(linkedToAddress)="data">
                  <div v-if="data.item.linkedTo && data.item.linkedTo.address">
                    <b-link @click="viewAddress(data.item.linkedTo.address)">
                      <font size="-1" v-b-popover.hover="addressDescription(data.item.linkedTo.address)">{{ formatAddressNamePrimary(data.item.linkedTo.address) }}</font>
                    </b-link>
                    <span v-if="data.item.mine"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo[data.item.linkedAddressType].name" :variant="addressTypeInfo[data.item.linkedAddressType].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                    <div v-if="formatAddressNameSecondary(data.item.linkedTo.address)">
                      <font size="-1" class="text-muted">{{ formatAddressNameSecondary(data.item.linkedTo.address) }}</font>
                    </div>
                  </div>
                </template>
                <template #cell(viaStealthMetaAddress)="data">
                  <div v-if="data.item.linkedTo && data.item.linkedTo.stealthMetaAddress">
                    <b-link @click="viewAddress(data.item.linkedTo.stealthMetaAddress)">
                      <font size="-1" v-b-popover.hover="addressDescription(data.item.linkedTo.stealthMetaAddress)">{{ formatAddressNamePrimary(data.item.linkedTo.stealthMetaAddress, 28) }}</font>
                    </b-link>
                    <span v-if="data.item.mine"><b-icon-star-fill v-b-popover.hover.right="addressTypeInfo['stealthMetaAddress'].name" :variant="addressTypeInfo['stealthMetaAddress'].variant" shift-v="+7" font-scale="0.6"></b-icon-star-fill></span>
                    <div v-if="formatAddressNameSecondary(data.item.linkedTo.stealthMetaAddress)">
                      <font size="-1" class="text-muted">{{ formatAddressNameSecondary(data.item.linkedTo.stealthMetaAddress) }}</font>
                    </div>
                  </div>
                </template>
                <template #cell(mine)="data">
                  <b-form-checkbox size="sm" disabled :checked="data.item.mine" class="mt-1 ml-2"></b-form-checkbox>
                </template>
                <template #cell(typeAndSource)="data">
                  <font size="-1">
                    {{ addressTypeOptions.filter(e => e.value == data.item.type)[0] && addressTypeOptions.filter(e => e.value == data.item.type)[0].text || ("Unknown: " + data.item.type) }}
                    <br />
                    {{ sourceOptions.filter(e => e.value == data.item.source)[0] && sourceOptions.filter(e => e.value == data.item.source)[0].text || ("Unknown: " + data.item.source) }}
                  </font>
                </template>
              </b-table>

              <!-- :TOKENS -->
              <b-table v-if="settings.tabIndex == 4 && !settings.showInfo" ref="tokenContractsTable" small fixed striped responsive hover :fields="tokenContractsFields" :items="pagedFilteredSortedTokenContracts" show-empty empty-html="Click Sync above to retrieve your ERC-20 and ERC-721 token events" head-variant="light" class="mx-0 my-1">
                <template #cell(number)="data">
                  <font size="-1">
                    {{ parseInt(data.index) + ((settings.tokenContractsTable.currentPage - 1) * settings.tokenContractsTable.pageSize) + 1 }}
                  </font>
                </template>
                <template #cell(contract)="data">
                  <b-link :href="chainInfo.explorerAddressPrefix + data.item.contract + '#code'" target="_blank">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.contract)">{{ formatAddress(data.item.contract) }}</font>
                  </b-link>
                </template>
                <template #cell(type)="data">
                  <font size="-1">{{ data.item.type == "erc20" ? "ERC-20" : "ERC-721" }}</font>
                </template>
                <template #cell(symbol)="data">
                  <font size="-1">{{ data.item.symbol }}</font>
                </template>
                <template #cell(name)="data">
                  <font size="-1">{{ data.item.name }}</font>
                </template>
                <template #cell(active)="data">
                  <font size="-1"><b-form-checkbox size="sm" value="1" :checked="data.item.active ? 1 : 0" @change="toggleTokenContractActive(data.item)" class="mt-1 ml-2"></b-form-checkbox></font>
                </template>
                <template #cell(firstEventBlockNumber)="data">
                  <font size="-1">{{ commify0(data.item.firstEventBlockNumber) }}</font>
                </template>
                <template #cell(lastEventBlockNumber)="data">
                  <font size="-1">{{ commify0(data.item.lastEventBlockNumber) }}</font>
                </template>
                <template #cell(decimals)="data">
                  <font size="-1">{{ data.item.type == "erc20" ? parseInt(data.item.decimals) : "" }}</font>
                </template>
                <template #cell(balance)="data">
                  <span v-if="data.item.balances[coinbase] && data.item.type == 'erc20'">
                    <b-button size="sm" :href="chainInfo.explorerTokenPrefix + data.item.contract + '?a=' + coinbase" variant="link" class="m-0 ml-2 p-0" target="_blank">{{ formatDecimals(data.item.balances[coinbase], data.item.decimals || 0) }}</b-button>
                  </span>
                  <span v-if="data.item.type == 'erc721'">
                    <font size="-1">
                      <span v-for="tokenId of data.item.tokenIds">
                        <b-button size="sm" :href="chainInfo.nftTokenPrefix + data.item.contract + '/' + tokenId" variant="link" v-b-popover.hover.bottom="tokenId" class="m-0 ml-2 p-0" target="_blank">{{ tokenId.toString().length > 20 ? (tokenId.toString().substring(0, 8) + '...' + tokenId.toString().slice(-8)) : tokenId.toString() }}</b-button>
                      </span>
                    </font>
                  </span>
                </template>
                <template #cell(totalSupply)="data">
                  <font size="-1">{{ data.item.type == "erc20" ? formatDecimals(data.item.totalSupply, data.item.decimals || 0) : data.item.totalSupply }}</font>
                </template>
                <!-- <template #cell(timestamp)="data">
                  <font size="-1">
                    <b-link :href="'https://sepolia.etherscan.io/tx/' + data.item.txHash" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber) + ', txIndex: ' + data.item.txIndex + ', logIndex: ' + data.item.logIndex" target="_blank">
                      <span v-if="data.item.timestamp">
                        {{ formatTimestamp(data.item.timestamp) }}
                      </span>
                      <span v-else>
                        {{ '#' + commify0(data.item.blockNumber) }}
                      </span>
                    </b-link>
                  </font>
                </template>
                <template #cell(sender)="data">
                  <b-link v-if="data.item.tx && data.item.tx.from" @click="viewAddress(data.item.tx.from)">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.tx.from)">{{ nameOrAddress(data.item.tx.from, 28) }}</font>
                  </b-link>
                </template>
                <template #cell(receiver)="data">
                  <b-link @click="viewAddress(data.item.stealthAddress)">
                    <font size="-1" v-b-popover.hover="addressDescription(data.item.stealthAddress)">{{ nameOrAddress(data.item.stealthAddress, 28) }}</font>
                  </b-link>
                </template>
                <template #cell(mine)="data">
                  <b-form-checkbox size="sm" disabled value="1" :checked="data.item.mine ? 1 : 0" class="mt-1 ml-2"></b-form-checkbox>
                </template>
                <template #cell(tokens)="data">
                  <font size="-1">
                    {{ formatETH(data.item.transfers[0].tokens) }}
                  </font>
                </template>
                <template #cell(token)="data">
                  <font size="-1">
                    ETH
                  </font>
                </template> -->
              </b-table>

              <!-- :CONFIG -->
              <b-card v-if="settings.tabIndex == 5 && !settings.showInfo && coinbase != null" no-body class="my-1 p-1">
                <b-card-body class="mt-1 p-1">
                  <h5>Settings</h5>
                  <b-form-group label="Local or UTC Time:" label-for="config-datetime" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="formatTimestamp(timestamp)" class="mx-0 my-1 p-0">
                    <b-form-select size="sm" id="config-datetime" v-model="settings.reportingDateTime" @change="saveSettings" :options="reportingDateTimeOptions" class="w-25"></b-form-select>
                  </b-form-group>
                  <b-form-group label="Show Details:" label-for="config-showdetails" label-size="sm" label-cols-sm="2" label-align-sm="right" description="Show details like Scheme Id and intermediate keys" class="mx-0 my-1 p-0">
                    <b-form-checkbox size="sm" id="config-showdetails" v-model="settings.showDetails" @input="saveSettings" class="ml-2 mt-1"></b-form-checkbox>
                  </b-form-group>
                  <b-form-group label="Currency:" label-for="config-reportingcurrency" label-size="sm" label-cols-sm="2" label-align-sm="right" :description="'Used in https://min-api.cryptocompare.com/data/v2/histoday?fsym=ETH&tsym={ccy}&limit=2000. Changes take effect after a re-sync'" class="mx-0 my-1 p-0">
                    <b-form-select size="sm" id="config-reportingcurrency" v-model="settings.reportingCurrency" @change="saveSettings" :options="reportingCurrencyOptions" class="w-25"></b-form-select>
                  </b-form-group>
                  <b-form-group label="CryptoCompare API Key:" label-for="config-cryptocompareapikey" label-size="sm" label-cols-sm="2" label-align-sm="right" description="This key is stored in your local browser storage and is sent with CryptoCompare API requests for historical ETH/{ccy} rates. If not supplied, imports from CryptoCompare may fail if you reach your free quota" class="mx-0 my-1 p-0">
                    <b-form-input type="text" size="sm" id="config-cryptocompareapikey" v-model="settings.cryptoCompareAPIKey" @change="saveSettings" placeholder="See https://www.cryptocompare.com/ to obtain an API key" class="w-75"></b-form-input>
                  </b-form-group>

                  <h5 class="mt-5">Configure Contracts</h5>
                  <b-card no-body no-header bg-variant="light" class="m-1 p-1">
                    <div class="d-flex flex-wrap m-0 p-0">
                      <div class="mt-0 flex-grow-1">
                      </div>
                      <div v-if="!sync.section" class="mt-0 pr-1">
                        <b-button size="sm" @click="saveSettings(); searchForContracts();" variant="primary" v-b-popover.hover.bottom="'Scan connected network for ERC-5564 and ERC-6538(with bytes32) events'">Scan</b-button>
                      </div>
                      <div class="mt-0 flex-grow-1">
                      </div>
                      <div class="mt-0 pl-1">
                        <b-form-select size="sm" v-model="settings.contractsTable.sortOption" @change="saveSettings" :options="contractsSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
                      </div>
                      <div class="mt-0 pl-1">
                        <font size="-2" v-b-popover.hover.bottom="'# contracts'">{{ commify0(totalContracts) }}</font>
                      </div>
                      <div class="mt-0 pl-1">
                        <b-pagination size="sm" v-model="settings.contractsTable.currentPage" @input="saveSettings" :total-rows="totalContracts" :per-page="settings.contractsTable.pageSize" style="height: 0;"></b-pagination>
                      </div>
                      <div class="mt-0 pl-1">
                        <b-form-select size="sm" v-model="settings.contractsTable.pageSize" @change="saveSettings();" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
                      </div>
                    </div>

                    <b-table ref="contractsTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='contractRowSelected' :fields="contractsFields" :items="pagedFilteredSortedContracts" show-empty empty-html="Click Sync above to retrieve stealth address announcement events" head-variant="light" class="mx-0 my-1">
                      <template #cell(number)="data">
                        <font size="-1">
                          {{ parseInt(data.index) + ((settings.contractsTable.currentPage - 1) * settings.contractsTable.pageSize) + 1 }}
                        </font>
                      </template>
                      <template #cell(chainId)="data">
                        <font size="-1">
                          {{ settings.chains[data.item.chainId] && settings.chains[data.item.chainId].name || ("Unconfigured ChainId: " + data.item.chainId) }}
                        </font>
                      </template>
                      <template #cell(contract)="data">
                        <b-link :href="chainInfo.explorerAddressPrefix + data.item.contract + '#code'" target="_blank">
                          <b-badge pill variant="transparent" v-b-popover.hover="addressDescription(data.item.contract)" class="px-0">{{ nameOrAddress(data.item.contract, 28) }}</b-badge>
                        </b-link>
                      </template>
                      <template #cell(type)="data">
                        <font size="-1">
                          {{ contractTypeOptions.filter(e => e.value == data.item.type)[0] && contractTypeOptions.filter(e => e.value == data.item.type)[0].text || ("Unknown: " + data.item.type) }}
                        </font>
                      </template>
                      <template #cell(name)="data">
                        <font size="-1">
                          {{ data.item.name }}
                        </font>
                      </template>
                      <template #cell(firstEvent)="data">
                        <font size="-1">
                          <b-link :href="chainInfo.explorerBlockPrefix + data.item.blockNumber" v-b-popover.hover.bottom="'Block #' + commify0(data.item.blockNumber)" target="_blank">
                            <span v-if="data.item.timestamp">
                              {{ formatTimestamp(data.item.timestamp) }}
                            </span>
                            <span v-else>
                              {{ '#' + commify0(data.item.blockNumber) }}
                            </span>
                          </b-link>
                        </font>
                      </template>
                      <template #cell(read)="data">
                        <font size="-1">
                          <b-form-checkbox size="sm" disabled value="1" :checked="data.item.read ? 1 : 0" class="mt-1 ml-2"></b-form-checkbox>
                        </font>
                      </template>
                      <template #cell(write)="data">
                        <font size="-1">
                          <b-form-checkbox size="sm" disabled value="1" :checked="data.item.write ? 1 : 0" @input="toggleContractWrite(data.item)" class="mt-1 ml-2"></b-form-checkbox>
                        </font>
                      </template>
                    </b-table>
                  </b-card>
                </b-card-body>
              </b-card>

            </b-card-text>
          </b-card>
        </b-card>

        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div class="ml-0 mt-1 pl-1">
              <font v-if="connected" size="-2">
                <b-link v-if="coinbase" :href="chainInfo.explorerAddressPrefix + coinbase" v-b-popover.hover.bottom="coinbase" target="_blank">
                  {{ ensNameOrAddress(coinbase, 30) }}
                </b-link>
                @
                <b-link v-if="chainId" :href="chainInfo.explorerPrefix" v-b-popover.hover.bottom="'Network ChainId: ' + chainId" target="_blank">
                  {{ chainInfo.name }}
                </b-link>
                <b-link v-if="blockNumber" :href="chainInfo.explorerBlockPrefix + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ '#' + commify0(blockNumber) }}
                </b-link>
                {{ formatTimeDiff(timestamp) }}
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              gm, and enjoy! <i>Magical Internet Money</i> &copy; Bok Consulting Pty Ltd 2024
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {
          CONFIRMATIONS: 100,
          DB_PROCESSING_BATCH_SIZE: 1000,
          TXHASH_SEGMENT_LENGTH: 8,
          ADDRESS_SEGMENT_LENGTH: 8,
          STEALTHMETAADDRESS_SEGMENT_LENGTH: 8,
          PUBLICKEY_SEGMENT_LENGTH: 18,
          defaultPhrase: "I want to login into my stealth wallet on Ethereum mainnet.",
          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,

          forceRefresh: 0,

          stealthMetaAddress: {
            display: false,
            spendingPrivateKey: null, // TODO: Don't save this
            viewingPrivateKey: null,
          },

          settings: {
            tabIndex: 0,
            showInfo: false,
            reportingDateTime: 0,
            showDetails: false,
            cryptoCompareAPIKey: null,
            reportingCurrency: "USD",
            sync: {
              transfers: true,
              directory: true,
              tokens: true,
              rescanTokens: true,
              ens: true,
              balances: true,
              exchangeRates: true,
            },
            transfersTable: {
              filter: null,
              iSentIReceived: null,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'txorderdsc',
            },
            registrationsTable: {
              filter: null,
              mineOnly: false,
              currentPage: 1,
              pageSize: 100,
              sortOption: 'txorderdsc',
            },
            addressesTable: {
              filter: null,
              mineOnly: false,
              currentPage: 1,
              pageSize: 25,
              sortOption: 'typenameasc',
            },
            tokenContractsTable: {
              activeOnly: false,
              filter: null,
              currentPage: 1,
              pageSize: 25,
              sortOption: 'typenameasc',
            },
            contractsTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10,
              sortOption: 'typenameasc',
            },
            erc721TokensTable: {
              filter: null,
              currentPage: 1,
              pageSize: 10000,
              sortOption: 'receiveddsc',
            },
            chains: {
              "1": {
                name: "Ethereum Mainnet",
                explorerPrefix: "https://etherscan.io/",
                explorerAddressPrefix: "https://etherscan.io/address/",
                explorerTokenPrefix: "https://etherscan.io/token/",
                explorerTxPrefix: "https://etherscan.io/tx/",
                explorerBlockPrefix: "https://etherscan.io/block/",
                nftTokenPrefix: "https://opensea.io/assets/ethereum/",
              },
              "11155111": {
                name: "Sepolia Testnet",
                explorerPrefix: "https://sepolia.etherscan.io/",
                explorerAddressPrefix: "https://sepolia.etherscan.io/address/",
                explorerTokenPrefix: "https://sepolia.etherscan.io/token/",
                explorerTxPrefix: "https://sepolia.etherscan.io/tx/",
                explorerBlockPrefix: "https://sepolia.etherscan.io/block/",
                nftTokenPrefix: "https://testnets.opensea.io/assets/sepolia/",
              },
            },
            version: 6,
          },
          contracts: {
            "11155111": {
              "0xFe6335f5dc5a469e74fB6a9FDAe116bFD5346365": {
                "type": "announcer",
                "name": "ERC5564Announcer v0.8.1 on Sepolia",
                "read": true,
                "write": false,
                "blockNumber": 5037208,
                "timestamp": 1704594648
              },
              "0x5F8ac9e3B2DD28cA2c9bc7A992Ce36c3C4929Cde": {
                "type": "registry",
                "name": "ERC5564Registry v0.8.1 on Sepolia",
                "read": true,
                "write": true,
                "blockNumber": 5037496,
                "timestamp": 1704598464
              },
              "0xA745760E9f1E425215CCD7735F932FdDE3276344": {
                "type": "caller",
                "name": "StealthChad v0.8.1 on Sepolia",
                "read": true,
                "write": true,
                "blockNumber": 5037208,
                "timestamp": 1704594648
              },
            }
          },
          sync: {
            section: null,
            total: null,
            completed: null,
            halt: false,
          },

          announcements: [],
          registrations: [],
          tokenEvents: [],
          addresses: {},
          tokenContracts: {},
          exchangeRates: {},

          modalNewTransfer: {
            stealthMetaAddress: null,
            items: [
              // { token: "0x03563574B3839e2CdD6281D8741497Ba82FD6739", type: "erc20", symbol: "BOKKY", name: "BokkyPooBah wuz here!", decimals: 18, amount: "12.34" },
              // { token: "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9", type: "erc20", symbol: "WEENUS", name: "Weenus ", decimals: 18, amount: "12.34" },
              // { token: "0x8b73448426797099b6b9a96c4343f528bbAfc55e", type: "erc721", symbol: "TESTTOADZ", name: "TestToadz", tokenId: "1779" },
              // { token: "0x8b73448426797099b6b9a96c4343f528bbAfc55e", type: "erc721", symbol: "TESTTOADZ", name: "TestToadz", tokenId: "4021" },
              // { token: "0x8b73448426797099b6b9a96c4343f528bbAfc55e", type: "erc721", symbol: "TESTTOADZ", name: "TestToadz", tokenId: "5183" },
              // { token: "0x8b73448426797099b6b9a96c4343f528bbAfc55e", type: "erc721", symbol: "TESTTOADZ", name: "TestToadz", tokenId: "5357" },
            ],
            amount: null,
          },
          modalAddTokensToNewTransfer: {
            token: null,
            type: null,
            amount: null,
            balance: null,
            approved: null,
            approvedInput: null,
            isApprovedForAll: null,
            isApprovedForAllInput: null,
            selectedERC721TokenIds: {},
          },
          modalTransfer: {
            item: null,
            stealthPrivateKey: null,
          },
          modalRegistration: {
            item: null,
          },
          modalAddress: {
            item: null,
            name: null,
          },
          modalStealthMetaAddress: {
            item: null,
            name: null,
            spendingPrivateKey: null,
          },
          modalNewStealthMetaAddress: {
            name: null,
            linkedTo: null,
            phrase: null,
            viewingPrivateKey: null,
            spendingPublicKey: null,
            viewingPublicKey: null,
            stealthMetaAddress: null,
            status: null,
          },
          modalContract: {
            item: null,
            name: null,
            read: false,
            write: false,
          },
          addressTypeInfo: {
            "address": { variant: "warning", name: "My Address" },
            "stealthAddress": { variant: "dark", name: "My Stealth Address" },
            "stealthMetaAddress": { variant: "success", name: "My Stealth Meta-Address" },
          },
          iSentIReceivedOptions: [
            { value: null, text: 'All Transfers' },
            { value: "iSent", text: 'I Sent' },
            { value: "iReceived", text: 'I Received' },
            { value: "iSentOrIReceived", text: 'I Sent OR I Received' },
            { value: "iSentAndIReceived", text: 'I Sent AND I Received' },
          ],
          // As supported by https://min-api.cryptocompare.com/data/v2/histoday?fsym=ETH&tsym={ccy}&limit=2000
          reportingCurrencyOptions: [
            { value: null, text: '(no currency reporting)' },
            { value: 'AUD', text: 'AUD' },
            { value: 'CAD', text: 'CAD' },
            { value: 'CHF', text: 'CHF' },
            { value: 'EUR', text: 'EUR' },
            { value: 'GBP', text: 'GBP' },
            { value: 'JPY', text: 'JPY' },
            { value: 'NZD', text: 'NZD' },
            { value: 'USD', text: 'USD' },
          ],
          addressTypeOptions: [
            { value: null, text: '(unknown)' },
            { value: "address", text: 'Address' },
            { value: "stealthMetaAddress", text: 'Stealth Meta-Address' },
            { value: "stealthAddress", text: 'Stealth Address' },
          ],
          sourceOptions: [
            { value: null, text: '(select)' },
            { value: "attached", text: 'Web3 attached account' },
            { value: "attached.signed", text: 'Signed by web3 attached account' },
            { value: "announcer.contract", text: 'ERC-5564 Announcer contract' },
            { value: "announcer.stealthAddress", text: 'ERC-5564 Announcer stealthAddress' },
            { value: "announcer.caller", text: 'ERC-5564 Announcer caller' },
            { value: "announcer.sender", text: 'ERC-5564 Announcer sender' },
            { value: "registry.registrant", text: 'ERC-6538 Registry registrant' },
            { value: "registry.contract", text: 'ERC-6538 Registry contract' },
            { value: "registry.stealthMetaAddress", text: 'ERC-6538 Registry stealthMetaAddress' },
          ],
          contractTypeOptions: [
            { value: null, text: '(select)' },
            { value: "announcer", text: 'ERC-5564 Announcer' },
            { value: "registry", text: 'ERC-6538 Registry' },
            { value: "caller", text: 'ERC-5564 Caller' },
          ],
          announcementsSortOptions: [
            { value: 'txorderasc', text: ' TxOrder' },
            { value: 'txorderdsc', text: ' TxOrder' },
          ],
          registrationsSortOptions: [
            { value: 'txorderasc', text: ' TxOrder' },
            { value: 'txorderdsc', text: ' TxOrder' },
          ],
          contractsSortOptions: [
            { value: 'typenameasc', text: ' Type,  Name' },
            { value: 'typenamedsc', text: ' Type,  Name' },
            { value: 'nameasc', text: ' Name,  Address' },
            { value: 'namedsc', text: ' Name,  Address' },
          ],
          addressesSortOptions: [
            { value: 'typenameasc', text: ' Type,  Name' },
            { value: 'typenamedsc', text: ' Type,  Name' },
            { value: 'nameasc', text: ' Name' },
            { value: 'namedsc', text: ' Name' },
            { value: 'addressasc', text: ' Address' },
            { value: 'addressdsc', text: ' Address' },
          ],
          tokenContractsSortOptions: [
            { value: 'typenameasc', text: ' Type,  Name' },
            { value: 'typenamedsc', text: ' Type,  Name' },
            { value: 'nameasc', text: ' Name' },
            { value: 'namedsc', text: ' Name' },
            { value: 'addressasc', text: ' Address' },
            { value: 'addressdsc', text: ' Address' },
          ],
          additionalTokensOptions: [
            { value: null, text: '(select ERC-20 or ERC-721 tokens)' },
            { value: 'erc20', text: 'ERC-20' },
            { value: 'erc721', text: 'ERC-721' },
          ],
          pageSizes: [
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 500, text: '500' },
            { value: 1000, text: '1k' },
            { value: 2500, text: '2.5k' },
            { value: 10000, text: '10k' },
          ],
          falseTrueOptions: [
            { value: false, text: 'false' },
            { value: true, text: 'true' },
          ],
          decimalsOptions: [
            { value: null, text: '(use default)' },
            { value: "0", text: '0' },
            { value: "1", text: '1' },
            { value: "2", text: '2' },
            { value: "3", text: '3' },
            { value: "4", text: '4' },
            { value: "5", text: '5' },
            { value: "6", text: '6 (some)' },
            { value: "7", text: '7' },
            { value: "8", text: '8' },
            { value: "9", text: '9' },
            { value: "10", text: '10' },
            { value: "11", text: '11' },
            { value: "12", text: '12' },
            { value: "13", text: '13' },
            { value: "14", text: '14' },
            { value: "15", text: '15' },
            { value: "16", text: '16' },
            { value: "17", text: '17' },
            { value: "18", text: '18 (common)' },
          ],
          transfersFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'timestamp', label: 'When', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            // { key: 'iSent', label: 'I Sent', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'sender', label: 'Sender', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            // { key: 'iReceived', label: 'I Received', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'receiver', label: 'Receiver', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'linkedToAddress', label: 'Linked To Address', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'viaStealthMetaAddress', label: 'Via Stealth Meta-Address', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'tokens', label: 'Tokens', sortable: false, thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'token', label: 'Token', sortable: false, thStyle: 'width: 10%;', thClass: 'text-truncate', tdClass: 'text-truncate' },
          ],
          registrationsFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'timestamp', label: 'When', sortable: false, thStyle: 'width: 20%;', tdClass: 'text-truncate' },
            { key: 'registrant', label: 'Registrant', sortable: false, thStyle: 'width: 25%;', thClass: 'text-left', tdClass: 'text-truncate' },
            // { key: 'mine', label: 'Mine', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            // { key: 'schemeId', label: 'Scheme Id', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'transfer', label: '', sortable: false, thStyle: 'width: 5%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'stealthMetaAddress', label: 'Stealth Meta-Address', sortable: false, thStyle: 'width: 30%;', thClass: 'text-left', tdClass: 'text-left' },
          ],
          addressesFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 3%;', tdClass: 'text-truncate' },
            // { key: 'mine', label: 'Mine', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'transfer', label: '', sortable: false, thStyle: 'width: 2%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'address', label: 'Address', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-left' },
            { key: 'linkedToAddress', label: 'Linked To Address', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'viaStealthMetaAddress', label: 'Via Stealth Meta-Address', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'typeAndSource', label: 'Type & Source', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
          ],
          tokenContractsFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'active', label: 'Active', sortable: false, thStyle: 'width: 7%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'contract', label: 'Contract', sortable: false, thStyle: 'width: 16%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 7%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'symbol', label: 'Symbol', sortable: false, thStyle: 'width: 10%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'firstEventBlockNumber', label: 'First Ev#', sortable: false, thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'lastEventBlockNumber', label: 'Last Ev#', sortable: false, thStyle: 'width: 10%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'decimals', label: 'Decs', sortable: false, thStyle: 'width: 5%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'balance', label: 'Balance', sortable: false, thStyle: 'width: 20%;', thClass: 'text-right', tdClass: 'text-right' },
            { key: 'totalSupply', label: 'Total Supply', sortable: false, thStyle: 'width: 20%;', thClass: 'text-right', tdClass: 'text-right' },
          ],
          contractsFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'chainId', label: 'Chain', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'contract', label: 'Contract', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'type', label: 'Type', sortable: false, thStyle: 'width: 15%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'name', label: 'Name', sortable: false, thStyle: 'width: 25%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'read', label: 'Read', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'write', label: 'Write', sortable: false, thStyle: 'width: 5%;', thClass: 'text-left', tdClass: 'text-truncate' },
            { key: 'firstEvent', label: 'First Event', sortable: false, thStyle: 'width: 15%;', tdClass: 'text-truncate' },
          ],
          erc721TokensFields: [
            { key: 'number', label: '#', sortable: false, thStyle: 'width: 5%;', tdClass: 'text-truncate' },
            { key: 'tokenId', label: 'Token Id', sortable: false, thStyle: 'width: 75%;', tdClass: 'text-truncate' },
            { key: 'select', label: 'Select', sortable: false, thStyle: 'width: 20%;', thClass: 'text-left', tdClass: 'text-truncate' },
          ],
          reportingDateTimeOptions: [
            { value: 0, text: 'Local Time' },
            { value: 1, text: 'UTC Time' },
          ],
          db: {
            name: "magicalinternetmoneydata080b",
            version: 1,
            schemaDefinition: {
              announcements: '[chainId+blockNumber+logIndex],[blockNumber+contract],contract,confirmations',
              registrations: '[chainId+blockNumber+logIndex],[blockNumber+contract],contract,confirmations',
              tokenEvents: '[chainId+blockNumber+logIndex],[blockNumber+contract],contract,confirmations',
            },
            updated: null,
          },
        },

        // --- COMPUTED ---
        computed: {
          additionalERC20TokensOptions() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            results.push({ value: null, text: "(select ERC-20 or ERC-721 token from active list)"})
            for (const item of this.filteredSortedTokenContracts) {
              if (item.active) {
                results.push({ value: item.contract, text: (item.type == "erc20" ? "ERC-20 " : "ERC-721 ") + item.symbol + ' ' + item.name + ' @ ' + item.contract.substring(0, 10) })
              }
            }
            return results;
          },
          chainInfo() {
            if (this.chainId in this.settings.chains) {
              return this.settings.chains[this.chainId];
            } else {
              return {
                name: "Unconfigured ChainId: " + this.chainId,
                explorerPrefix: "(not configured)",
                explorerAddressPrefix: "(not configured)",
                explorerTokenPrefix: "(not configured)",
                explorerTxPrefix: "(not configured)",
                explorerBlockPrefix: "(not configured)",
              };
            }
          },
          transfers() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            for (const announcement of this.announcements) {
              if (announcement.chainId == this.chainId) {
                const sender = announcement.tx.from;
                const senderData = sender && this.addresses[sender] || {};
                const receiver = announcement.stealthAddress;
                const receiverData = receiver && this.addresses[receiver] || {};
                const linkedStealthMetaAddress = announcement.linkedTo && announcement.linkedTo.stealthMetaAddress || null;
                const linkedStealthMetaAddressData = linkedStealthMetaAddress && this.addresses[linkedStealthMetaAddress] || {};
                const linkedAddress = announcement.linkedTo && announcement.linkedTo.address || null;
                const linkedAddressData = linkedAddress && this.addresses[linkedAddress] || {};
                results.push({
                  ...announcement,
                  senderInfo: {
                    type: senderData.type,
                    name: senderData.name,
                    ensName: senderData.ensName,
                  },
                  receiverInfo: {
                    type: receiverData.type,
                    name: receiverData.name,
                    ensName: receiverData.ensName,
                  },
                  linkedAddressInfo: {
                    type: linkedAddressData.type,
                    name: linkedAddressData.name,
                    ensName: linkedAddressData.ensName,
                  },
                  linkedStealthMetaAddressInfo: {
                    type: linkedStealthMetaAddressData.type,
                    name: linkedStealthMetaAddressData.name,
                  },
                });
              }
            }
            return results;
          },
          received() {
            let results = [];
            for (const transfer of this.transfers) {
              if (transfer.iReceived) {
                results.push(transfer);
              }
            }
            return results;
          },
          sent() {
            let results = [];
            for (const transfer of this.transfers) {
              if (transfer.iSent) {
                results.push(transfer);
              }
            }
            return results;
          },
          filteredTransfers() {
            let results = [];
            const regex = this.settings.transfersTable.filter != null && this.settings.transfersTable.filter.length > 0 ? new RegExp(this.settings.transfersTable.filter, 'i') : null;
            for (const transfer of this.transfers) {
              let include = true;
              if (this.settings.transfersTable.iSentIReceived) {
                if (this.settings.transfersTable.iSentIReceived == 'iSent') {
                  if (!transfer.iSent) {
                    include = false;
                  }
                } else if (this.settings.transfersTable.iSentIReceived == 'iReceived') {
                  if (!transfer.iReceived) {
                    include = false;
                  }
                } else if (this.settings.transfersTable.iSentIReceived == 'iSentOrIReceived') {
                  if (!transfer.iSent && !transfer.iReceived) {
                    include = false;
                  }
                } else if (this.settings.transfersTable.iSentIReceived == 'iSentAndIReceived') {
                  if (!transfer.iSent || !transfer.iReceived) {
                    include = false;
                  }
                }
              }
              if (include && regex) {
                if (!(
                  regex.test(transfer.senderInfo.name) || regex.test(transfer.senderInfo.ensName) || regex.test(transfer.tx.from) ||
                  regex.test(transfer.receiverInfo.name) || regex.test(transfer.receiverInfo.ensName) || regex.test(transfer.stealthAddress) ||
                  regex.test(transfer.linkedAddressInfo.name) || regex.test(transfer.linkedAddressInfo.ensName) || regex.test(transfer.linkedTo && transfer.linkedTo.address) ||
                  regex.test(transfer.linkedStealthMetaAddressInfo.name) || regex.test(transfer.linkedTo && transfer.linkedTo.stealthMetaAddress)
                )) {
                  include = false;
                }
              }
              if (include) {
                results.push(transfer);
              }
            }
            return results;
          },
          filteredSortedTransfers() {
            let results = this.filteredTransfers;
            if (this.settings.transfersTable.sortOption == 'txorderasc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return a.logIndex - b.logIndex;
                  } else {
                    return a.txIndex - b.txIndex;
                  }
                } else {
                  return a.blockNumber - b.blockNumber;
                }
              });
            } else if (this.settings.transfersTable.sortOption == 'txorderdsc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return b.logIndex - a.logIndex;
                  } else {
                    return b.txIndex - a.txIndex;
                  }
                } else {
                  return b.blockNumber - a.blockNumber;
                }
              });
            }
            return results;
          },
          pagedFilteredSortedTransfers() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedTransfers - results[0..9]: " + JSON.stringify(this.filteredSortedTransfers.slice(0, 10), null, 2));
            return this.filteredSortedTransfers.slice((this.settings.transfersTable.currentPage - 1) * this.settings.transfersTable.pageSize, this.settings.transfersTable.currentPage * this.settings.transfersTable.pageSize);
          },

          filteredRegistrations() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            const regex = this.settings.registrationsTable.filter != null && this.settings.registrationsTable.filter.length > 0 ? new RegExp(this.settings.registrationsTable.filter, 'i') : null;
            for (const item of this.registrations) {
              if (item.chainId == this.chainId) {
                const registrantData = this.addresses[item.registrant] || {};
                let include = true;
                if (this.settings.registrationsTable.mineOnly && !registrantData.mine) {
                  include = false;
                }
                if (include && regex && !(regex.test(registrantData.name) || regex.test(registrantData.ensName) || regex.test(item.tx.from))) {
                  include = false;
                }
                if (include) {
                  const _cellVariants = {
                    registrant: registrantData.mine ? 'success' : undefined,
                  };
                  results.push({ ...item, mine: registrantData.mine /*, _cellVariants */, registrantType: registrantData.type });
                }
              }
            }
            return results;
          },
          filteredSortedRegistrations() {
            let results = this.filteredRegistrations;
            if (this.settings.registrationsTable.sortOption == 'txorderasc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return a.logIndex - b.logIndex;
                  } else {
                    return a.txIndex - b.txIndex;
                  }
                } else {
                  return a.blockNumber - b.blockNumber;
                }
              });
            } else if (this.settings.registrationsTable.sortOption == 'txorderdsc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  if (a.txIndex == b.txIndex) {
                    return b.logIndex - a.logIndex;
                  } else {
                    return b.txIndex - a.txIndex;
                  }
                } else {
                  return b.blockNumber - a.blockNumber;
                }
              });
            }
            return results;
          },
          pagedFilteredSortedRegistrations() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedRegistrations - results[0..9]: " + JSON.stringify(this.filteredSortedRegistrations.slice(0, 10), null, 2));
            return this.filteredSortedRegistrations.slice((this.settings.registrationsTable.currentPage - 1) * this.settings.registrationsTable.pageSize, this.settings.registrationsTable.currentPage * this.settings.registrationsTable.pageSize);
          },

          totalAddresses() {
            let result = this.forceRefresh % 2 == 0 ? 0 : 0;
            for (const [address, data] of Object.entries(this.addresses)) {
              result++;
            }
            return result;
          },
          filteredAddresses() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            const regex = this.settings.addressesTable.filter != null && this.settings.addressesTable.filter.length > 0 ? new RegExp(this.settings.addressesTable.filter, 'i') : null;
            for (const [address, data] of Object.entries(this.addresses)) {
              let include = true;
              if (this.settings.addressesTable.mineOnly && !data.mine) {
                include = false;
              }
              const linkedAddress = data.linkedTo && data.linkedTo.address || null;
              const linkedAddressData = this.addresses[linkedAddress] || {};
              const linkedStealthMetaAddress = data.linkedTo && data.linkedTo.stealthMetaAddress || null;
              const linkedStealthMetaAddressData = this.addresses[linkedStealthMetaAddress] || {};
              if (include && regex) {
                if (!(
                  regex.test(data.name) || regex.test(data.ensName) || regex.test(address) ||
                  regex.test(linkedAddressData.name) || regex.test(linkedAddressData.ensName) || regex.test(linkedAddress) ||
                  regex.test(linkedStealthMetaAddressData.name) || regex.test(linkedStealthMetaAddress)
                )) {
                  include = false;
                }
              }
              if (include) {
                const _cellVariants = {
                  address: data.mine ? 'success' : undefined,
                };
                results.push({ address, ...data /*, _cellVariants */, linkedAddressType: linkedAddressData.type, linkedStealthMetaAddressType: linkedStealthMetaAddressData.type });
              }
            }
            return results;
          },
          filteredSortedAddresses() {
            let results = this.filteredAddresses;
            if (this.settings.addressesTable.sortOption == 'typenameasc') {
              results.sort((a, b) => {
                if (('' + a.type).localeCompare(b.type) == 0) {
                  const aname = (a.ensName || '') + (a.name || 'zzz');
                  const bname = (b.ensName || '') + (b.name || 'zzz');
                  if (('' + aname).localeCompare(bname) == 0) {
                    return ('' + a.address).localeCompare(b.address);
                  } else {
                    return ('' + aname).localeCompare(bname);
                  }
                } else {
                  return ('' + b.type).localeCompare(a.type);
                }
              });
            } else if (this.settings.addressesTable.sortOption == 'typenamedsc') {
              results.sort((a, b) => {
                if (('' + a.type).localeCompare(b.type) == 0) {
                  const aname = (a.ensName || '') + (a.name || 'zzz');
                  const bname = (b.ensName || '') + (b.name || 'zzz');
                  if (('' + aname).localeCompare(bname) == 0) {
                    return ('' + b.address).localeCompare(a.address);
                  } else {
                    return ('' + bname).localeCompare(aname);
                  }
                } else {
                  return ('' + a.type).localeCompare(b.type);
                }
              });
            } else if (this.settings.addressesTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                const aname = (a.ensName || '') + (a.name || 'zzz');
                const bname = (b.ensName || '') + (b.name || 'zzz');
                if (('' + aname).localeCompare(bname) == 0) {
                  return ('' + a.address).localeCompare(b.address);
                } else {
                  return ('' + aname).localeCompare(bname);
                }
              });
            } else if (this.settings.addressesTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                const aname = (a.ensName || '') + (a.name || 'zzz');
                const bname = (b.ensName || '') + (b.name || 'zzz');
                if (('' + aname).localeCompare(bname) == 0) {
                  return ('' + b.address).localeCompare(a.address);
                } else {
                  return ('' + bname).localeCompare(aname);
                }
              });
            } else if (this.settings.addressesTable.sortOption == 'addressasc') {
              results.sort((a, b) => {
                return ('' + a.address).localeCompare(b.address);
              });
            } else if (this.settings.addressesTable.sortOption == 'addressdsc') {
              results.sort((a, b) => {
                return ('' + b.address).localeCompare(a.address);
              });
            }
            return results;
          },
          pagedFilteredSortedAddresses() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedAddresses - results[0..9]: " + JSON.stringify(this.filteredSortedAddresses.slice(0, 10), null, 2));
            return this.filteredSortedAddresses.slice((this.settings.addressesTable.currentPage - 1) * this.settings.addressesTable.pageSize, this.settings.addressesTable.currentPage * this.settings.addressesTable.pageSize);
          },

          filteredTokenContracts() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            for (const [contract, contractData] of Object.entries(this.tokenContracts[this.chainId] || {})) {
              let include = true;
              if (this.settings.tokenContractsTable.activeOnly) {
                if (!contractData.active) {
                  include = false;
                }
              }
              if (include) {
                const tokenIds = [];
                for (const [tokenId, tokenData] of Object.entries(contractData.tokenIds)) {
                  if (tokenData.owner == this.coinbase) {
                    tokenIds.push(tokenId);
                  }
                }
                results.push({
                  contract,
                  active: contractData.active,
                  symbol: contractData.symbol,
                  name: contractData.name,
                  type: contractData.type,
                  decimals: contractData.type == "erc20" ? contractData.decimals : undefined,
                  balances: contractData.balances || undefined,
                  tokenIds,
                  totalSupply: contractData.totalSupply || undefined,
                  firstEventBlockNumber: contractData.firstEventBlockNumber || undefined,
                  lastEventBlockNumber: contractData.lastEventBlockNumber || undefined,
                });
              }
            }
            return results;
          },
          filteredSortedTokenContracts() {
            let results = this.filteredTokenContracts;
            if (this.settings.tokenContractsTable.sortOption == 'typenameasc') {
              results.sort((a, b) => {
                if (('' + a.type).localeCompare(b.type) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.address).localeCompare(b.address);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return ('' + a.type).localeCompare(b.type);
                }
              });
            } else if (this.settings.tokenContractsTable.sortOption == 'typenamedsc') {
              results.sort((a, b) => {
                if (('' + a.type).localeCompare(b.type) == 0) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + b.address).localeCompare(a.address);
                  } else {
                    return ('' + b.name).localeCompare(a.name);
                  }
                } else {
                  return ('' + b.type).localeCompare(a.type);
                }
              });
            } else if (this.settings.tokenContractsTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + a.address).localeCompare(b.address);
                } else {
                  return ('' + a.name).localeCompare(b.name);
                }
              });
            } else if (this.settings.tokenContractsTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + b.address).localeCompare(a.address);
                } else {
                  return ('' + b.name).localeCompare(a.name);
                }
              });
            } else if (this.settings.tokenContractsTable.sortOption == 'addressasc') {
              results.sort((a, b) => {
                return ('' + a.contract).localeCompare(b.contract);
              });
            } else if (this.settings.tokenContractsTable.sortOption == 'addressdsc') {
              results.sort((a, b) => {
                return ('' + b.contract).localeCompare(a.contract);
              });
            }
            return results;
          },
          pagedFilteredSortedTokenContracts() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedTokenContracts - results[0..9]: " + JSON.stringify(this.pagedFilteredSortedTokenContracts.slice(0, 10), null, 2));
            return this.filteredSortedTokenContracts.slice((this.settings.tokenContractsTable.currentPage - 1) * this.settings.tokenContractsTable.pageSize, this.settings.tokenContractsTable.currentPage * this.settings.tokenContractsTable.pageSize);
          },

          totalContracts() {
            let result = this.forceRefresh % 2 == 0 ? 0 : 0;
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                result++;
              }
            }
            return result;
          },
          filteredContracts() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                const contractTypeSortIndex = this.contractTypeOptions.findIndex(e => e.value == contractData.type);
                results.push({ chainId, contract, ...contractData, contractTypeSortIndex });
              }
            }
            return results;
          },
          filteredSortedContracts() {
            // TODO: Sort options 3 and 4 a bit buggy
            let results = this.filteredContracts;
            if (this.settings.contractsTable.sortOption == 'typenameasc') {
              results.sort((a, b) => {
                if (a.contractTypeSortIndex == b.contractTypeSortIndex) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + a.contract).localeCompare(b.contract);
                  } else {
                    return ('' + a.name).localeCompare(b.name);
                  }
                } else {
                  return a.contractTypeSortIndex - b.contractTypeSortIndex;
                }
              });
            } else if (this.settings.contractsTable.sortOption == 'typenamedsc') {
              results.sort((a, b) => {
                if (a.contractTypeSortIndex == b.contractTypeSortIndex) {
                  if (('' + a.name).localeCompare(b.name) == 0) {
                    return ('' + b.contract).localeCompare(a.contract);
                  } else {
                    return ('' + b.name).localeCompare(a.name);
                  }
                } else {
                  return b.contractTypeSortIndex - a.contractTypeSortIndex;
                }
              });
            } else if (this.settings.contractsTable.sortOption == 'nameasc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + a.contract).localeCompare(b.contract);
                } else {
                  return ('' + a.name).localeCompare(b.name);
                }
              });
            } else if (this.settings.contractsTable.sortOption == 'namedsc') {
              results.sort((a, b) => {
                if (('' + a.name).localeCompare(b.name) == 0) {
                  return ('' + b.contract).localeCompare(a.contract);
                } else {
                  return ('' + b.name).localeCompare(a.name);
                }
              });
            }
            return results;
          },
          pagedFilteredSortedContracts() {
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedContracts - results[0..9]: " + JSON.stringify(this.filteredSortedContracts.slice(0, 10), null, 2));
            return this.filteredSortedContracts.slice((this.settings.transfersTable.currentPage - 1) * this.settings.transfersTable.pageSize, this.settings.transfersTable.currentPage * this.settings.transfersTable.pageSize);
          },

          filteredERC721Tokens() {
            let results = this.forceRefresh % 2 == 0 ? [] : [];
            const tokenContract = this.tokenContracts[this.chainId] && this.tokenContracts[this.chainId][this.modalAddTokensToNewTransfer.token] || {};
            if (tokenContract.type == "erc721") {
              for (const [tokenId, tokenData] of Object.entries(tokenContract.tokenIds)) {
                if (tokenData.owner == this.coinbase) {
                  const selected = tokenId in this.modalAddTokensToNewTransfer.selectedERC721TokenIds;
                  results.push({ tokenId, ...tokenData, selected });
                }
              }
            }
            return results;
          },
          filteredSortedERC721Tokens() {
            let results = this.filteredERC721Tokens;
            // if (this.settings.contractsTable.sortOption == 'typenameasc') {
            //   results.sort((a, b) => {
            //     if (a.contractTypeSortIndex == b.contractTypeSortIndex) {
            //       if (('' + a.name).localeCompare(b.name) == 0) {
            //         return ('' + a.contract).localeCompare(b.contract);
            //       } else {
            //         return ('' + a.name).localeCompare(b.name);
            //       }
            //     } else {
            //       return a.contractTypeSortIndex - b.contractTypeSortIndex;
            //     }
            //   });
            // } else if (this.settings.contractsTable.sortOption == 'typenamedsc') {
            //   results.sort((a, b) => {
            //     if (a.contractTypeSortIndex == b.contractTypeSortIndex) {
            //       if (('' + a.name).localeCompare(b.name) == 0) {
            //         return ('' + b.contract).localeCompare(a.contract);
            //       } else {
            //         return ('' + b.name).localeCompare(a.name);
            //       }
            //     } else {
            //       return b.contractTypeSortIndex - a.contractTypeSortIndex;
            //     }
            //   });
            // } else if (this.settings.contractsTable.sortOption == 'nameasc') {
            //   results.sort((a, b) => {
            //     if (('' + a.name).localeCompare(b.name) == 0) {
            //       return ('' + a.contract).localeCompare(b.contract);
            //     } else {
            //       return ('' + a.name).localeCompare(b.name);
            //     }
            //   });
            // } else if (this.settings.contractsTable.sortOption == 'namedsc') {
            //   results.sort((a, b) => {
            //     if (('' + a.name).localeCompare(b.name) == 0) {
            //       return ('' + b.contract).localeCompare(a.contract);
            //     } else {
            //       return ('' + b.name).localeCompare(a.name);
            //     }
            //   });
            // }
            return results;
          },
          pagedFilteredSortedERC721Tokens() {
            console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedERC721Tokens - results[0..9]: " + JSON.stringify(this.filteredSortedERC721Tokens.slice(0, 10), null, 2));
            return this.filteredSortedERC721Tokens.slice((this.settings.erc721TokensTable.currentPage - 1) * this.settings.erc721TokensTable.pageSize, this.settings.erc721TokensTable.currentPage * this.settings.erc721TokensTable.pageSize);
          },

        },

        // --- METHODS ---
        methods: {
          isEthereums(address) {
            return address == ADDRESS_ETHEREUMS;
          },
          getTokenSymbol(address) {
            // console.log(moment().format("HH:mm:ss") + " getTokenSymbol - address: " + JSON.stringify(address));
            if (address == ADDRESS_ETHEREUMS) {
              return "ETH";
            } else {
              if (address in (this.tokenContracts[this.chainId] || {})) {
                const tokenContract = this.tokenContracts[this.chainId][address];
                return tokenContract.symbol;
              } else {
                return address.substring(0, 10);
              }
            }
          },
          getTokenType(address) {
            // console.log(moment().format("HH:mm:ss") + " getTokenType - address: " + JSON.stringify(address));
            if (address == ADDRESS_ETHEREUMS) {
              return "eth";
            } else {
              return this.tokenContracts[this.chainId] && this.tokenContracts[this.chainId][address] && this.tokenContracts[this.chainId][address].type || null;
            }
          },

          erc721TokenIdToggle(tokenId) {
            // console.log(moment().format("HH:mm:ss") + " erc721TokenIdToggle - tokenId: " + tokenId);
            if (tokenId in this.modalAddTokensToNewTransfer.selectedERC721TokenIds) {
              Vue.delete(this.modalAddTokensToNewTransfer.selectedERC721TokenIds, tokenId);
            } else {
              Vue.set(this.modalAddTokensToNewTransfer.selectedERC721TokenIds, tokenId, true);
            }
            // console.log(moment().format("HH:mm:ss") + " erc721TokenIdToggle - this.modalAddTokensToNewTransfer.selectedERC721TokenIds: " + JSON.stringify(this.modalAddTokensToNewTransfer.selectedERC721TokenIds, null, 2));
          },

          async additionalTokenSelected() {
            console.log(moment().format("HH:mm:ss") + " additionalTokenSelected");
            console.log(moment().format("HH:mm:ss") + " this.modalAddTokensToNewTransfer: " + JSON.stringify(this.modalAddTokensToNewTransfer, null, 2));
            if (this.modalAddTokensToNewTransfer.token) {
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              const tokenContract = this.tokenContracts[this.chainId] && this.tokenContracts[this.chainId][this.modalAddTokensToNewTransfer.token] || {};
              console.log("tokenContract: " + JSON.stringify(tokenContract, null, 2));
              Vue.set(this.modalAddTokensToNewTransfer, 'type', tokenContract.type || null);
              if (tokenContract.type == "erc20") {
                const contract = new ethers.Contract(this.modalAddTokensToNewTransfer.token, ERC20ABI, provider);
                const decimals = tokenContract.decimals && parseInt(tokenContract.decimals) || null;
                const balance = await contract.balanceOf(this.coinbase);
                Vue.set(this.modalAddTokensToNewTransfer, 'balance', this.formatDecimals(balance.toString(), decimals));
                const allowance = await contract.allowance(this.coinbase, STEALTHCHADADDRESS_SEPOLIA);
                Vue.set(this.modalAddTokensToNewTransfer, 'approved', this.formatDecimals(allowance.toString(), decimals));
                Vue.set(this.modalAddTokensToNewTransfer, 'approvedInput', this.formatDecimals(allowance.toString(), decimals));
              } else if (tokenContract.type == "erc721") {
                const contract = new ethers.Contract(this.modalAddTokensToNewTransfer.token, ERC721ABI, provider);
                const isApprovedForAll = await contract.isApprovedForAll(this.coinbase, STEALTHCHADADDRESS_SEPOLIA);
                Vue.set(this.modalAddTokensToNewTransfer, 'isApprovedForAll', isApprovedForAll.toString());
                Vue.set(this.modalAddTokensToNewTransfer, 'isApprovedForAllInput', isApprovedForAll.toString());
              }
              console.log("this.modalAddTokensToNewTransfer: " + JSON.stringify(this.modalAddTokensToNewTransfer));
            }
          },

          addERC20TokenToTransfer() {
            console.log(moment().format("HH:mm:ss") + " addERC20TokenToTransfer");
            const tokenContract = this.tokenContracts[this.chainId] && this.tokenContracts[this.chainId][this.modalAddTokensToNewTransfer.token] || {};
            const decimals = tokenContract.decimals && parseInt(tokenContract.decimals) || null;
            const symbol = tokenContract.symbol || null;
            const name = tokenContract.name || null;
            this.modalNewTransfer.items.push({
              token: this.modalAddTokensToNewTransfer.token,
              type: this.modalAddTokensToNewTransfer.type,
              symbol,
              name,
              decimals,
              amount: this.modalAddTokensToNewTransfer.amount
            });
            console.log("this.modalNewTransfer: " + JSON.stringify(this.modalNewTransfer, null, 2));
            console.log("this.modalAddTokensToNewTransfer: " + JSON.stringify(this.modalAddTokensToNewTransfer, null, 2));
            this.$refs['addtokensfortransfer'].hide();
          },

          addERC721TokenToTransfer() {
            console.log(moment().format("HH:mm:ss") + " addERC721TokenToTransfer");
            const tokenContract = this.tokenContracts[this.chainId] && this.tokenContracts[this.chainId][this.modalAddTokensToNewTransfer.token] || {};
            console.log("tokenContract: " + JSON.stringify(tokenContract, null, 2));
            console.log("this.modalAddTokensToNewTransfer: " + JSON.stringify(this.modalAddTokensToNewTransfer, null, 2));
            if (tokenContract.type == "erc721") {
              for (const [tokenId, tokenData] of Object.entries(tokenContract.tokenIds)) {
                if (tokenData.owner == this.coinbase) {
                  const selected = tokenId in this.modalAddTokensToNewTransfer.selectedERC721TokenIds;
                  if (selected) {
                    // console.log(tokenId + " " + selected + " => " + JSON.stringify(tokenData));
                    const symbol = tokenContract.symbol || null;
                    const name = tokenContract.name || null;
                    this.modalNewTransfer.items.push({
                      token: this.modalAddTokensToNewTransfer.token,
                      type: this.modalAddTokensToNewTransfer.type,
                      symbol,
                      name,
                      tokenId,
                    });
                  }
                }
              }
            }
            console.log("this.modalNewTransfer: " + JSON.stringify(this.modalNewTransfer, null, 2));
            console.log("this.modalAddTokensToNewTransfer: " + JSON.stringify(this.modalAddTokensToNewTransfer, null, 2));
            this.$refs['addtokensfortransfer'].hide();
          },

          removeTokensForTransfer(index) {
            console.log(moment().format("HH:mm:ss") + " removeTokensForTransfer: " + index);
            this.modalNewTransfer.items.splice(index, 1);
          },

          async searchForContracts() {
            // Announcement (index_topic_1 uint256 schemeId, index_topic_2 address stealthAddress, index_topic_3 address caller, bytes ephemeralPublicKey, bytes metadata)
            // 0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7
            // Note: Following is ERC-6538: Stealth Meta-Address Registry with registrant being address instead of bytes
            // StealthMetaAddressSet (index_topic_1 address registrant, index_topic_2 uint256 scheme, bytes stealthMetaAddress)
            // 0x4e739a47dfa4fd3cfa92f8fe760cebe125565927e5c422cb28e7aa388a067af9
            console.log(moment().format("HH:mm:ss") + " searchForContracts");
            const contractsMap = {};
            let total = 0;
            function processLogs(fromBlock, toBlock, logs) {
              total = parseInt(total) + logs.length;
              console.log(moment().format("HH:mm:ss") + " searchForContracts.processLogs: " + fromBlock + " - " + toBlock + " " + logs.length + " " + total);
              for (const event of logs) {
                if (!event.removed) {
                  if (event.topics[0] == "0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7") {
                    const caller = ethers.utils.getAddress("0x" + event.topics[3].substring(26, 66));
                    if (!(event.address in contractsMap)) {
                      contractsMap[event.address] = { type: "announcer", blockNumber: event.blockNumber };
                    }
                    if (!(caller in contractsMap)) {
                      contractsMap[caller] = { type: "caller", blockNumber: event.blockNumber };
                    }
                  } else {
                    if (!(event.address in contractsMap)) {
                      contractsMap[event.address] = { type: "registry", blockNumber: event.blockNumber };
                    }
                  }
                }
              }
            }
            async function getLogs(fromBlock, toBlock, processLogs) {
              try {
                const filter = {
                  address: null,
                  fromBlock,
                  toBlock,
                  topics: [
                    ['0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7', '0x4e739a47dfa4fd3cfa92f8fe760cebe125565927e5c422cb28e7aa388a067af9'],
                    null,
                    null
                  ]
                };
                const eventLogs = await provider.getLogs(filter);
                processLogs(fromBlock, toBlock, eventLogs);
              } catch (e) {
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogs(fromBlock, mid, processLogs);
                await getLogs(parseInt(mid) + 1, toBlock, processLogs);
              }
            }
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            this.coinbase = await signer.getAddress();
            localStorage.magicalInternetMoneyCoinbase = this.coinbase;
            const network = await provider.getNetwork();
            localStorage.magicalInternetMoneyChainId = network.chainId;
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            console.log(moment().format("HH:mm:ss") + " searchForContracts - latestBlockNumber: " + latestBlockNumber + ", chainId: " + this.chainId);
            const startBlock = 0;
            await getLogs(startBlock, latestBlockNumber, processLogs);
            const contracts = this.contracts;
            if (!(this.chainId in contracts)) {
              contracts[this.chainId] = {};
            }
            for (const [contract, data] of Object.entries(contractsMap)) {
              const type = data.type;
              const blockNumber = data.blockNumber;
              const timestamp = (await provider.getBlock(blockNumber)).timestamp
              const customData = CUSTOMNAMES[contract] || {};
              contracts[this.chainId][contract] = { type, name: customData.name || null, read: customData.read || false, write: customData.write || false, blockNumber, timestamp };
            }
            Vue.set(this, 'contracts', contracts);
            localStorage.magicalInternetMoneyContracts = JSON.stringify(this.contracts);
          },

          saveModalContractName() {
            console.log(moment().format("HH:mm:ss") + " saveModalContractName: " + JSON.stringify(this.modalContract));
            this.modalContract.item.name = this.modalContract.name;
            Vue.set(this.contracts[this.modalContract.item.chainId][this.modalContract.item.contract], 'name', this.modalContract.name);
            localStorage.magicalInternetMoneyContracts = JSON.stringify(this.contracts);
            Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
          },

          saveModalAddressName() {
            console.log(moment().format("HH:mm:ss") + " saveModalAddressName: " + JSON.stringify(this.modalAddress));
            this.modalAddress.item.name = this.modalAddress.name;
            Vue.set(this.addresses[this.modalAddress.item.address], 'name', this.modalAddress.name);
            localStorage.magicalInternetMoneyAddresses = JSON.stringify(this.addresses);
            Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
          },

          saveModalStealthMetaAddressName() {
            console.log(moment().format("HH:mm:ss") + " saveModalStealthMetaAddressName: " + JSON.stringify(this.modalStealthMetaAddress));
            this.modalStealthMetaAddress.item.name = this.modalStealthMetaAddress.name;
            Vue.set(this.addresses[this.modalStealthMetaAddress.item.address], 'name', this.modalStealthMetaAddress.name);
            localStorage.magicalInternetMoneyAddresses = JSON.stringify(this.addresses);
            Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
          },

          toggleModalAddressMine() {
            console.log(moment().format("HH:mm:ss") + " toggleModalAddressMine: " + JSON.stringify(this.modalAddress));
            this.modalAddress.item.mine = !this.modalAddress.item.mine;
            Vue.set(this.addresses[this.modalAddress.item.address], 'mine', this.modalAddress.item.mine);
            Vue.set(this.addresses, this.modalAddress.item.address, this.addresses[this.modalAddress.item.address]);
            Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
            localStorage.magicalInternetMoneyAddresses = JSON.stringify(this.addresses);
          },

          // toggleModalStealthMetaAddressMine() {
          //   console.log(moment().format("HH:mm:ss") + " toggleModalStealthMetaAddressMine: " + JSON.stringify(this.modalStealthMetaAddress));
          //   this.modalStealthMetaAddress.item.mine = !this.modalStealthMetaAddress.item.mine;
          //   Vue.set(this.addresses[this.modalStealthMetaAddress.item.address], 'mine', this.modalStealthMetaAddress.item.mine);
          //   Vue.set(this.addresses, this.modalStealthMetaAddress.item.address, this.addresses[this.modalStealthMetaAddress.item.address]);
          //   Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
          //   localStorage.magicalInternetMoneyAddresses = JSON.stringify(this.addresses);
          // },

          toggleContractRead(item) {
            if (this.modalContract.item && this.modalContract.item.chainId && this.modalContract.item.contract) {
              Vue.set(this.contracts[this.modalContract.item.chainId][this.modalContract.item.contract], 'read', !this.modalContract.read);
              Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
              localStorage.magicalInternetMoneyContracts = JSON.stringify(this.contracts);
            }
          },
          toggleContractWrite(item) {
            if (this.modalContract.item && this.modalContract.item.chainId && this.modalContract.item.contract) {
              Vue.set(this.contracts[this.modalContract.item.chainId][this.modalContract.item.contract], 'write', !this.modalContract.write);
              Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
              localStorage.magicalInternetMoneyContracts = JSON.stringify(this.contracts);
            }
          },
          toggleTokenContractActive(item) {
            if (item && item.contract) {
              Vue.set(this.tokenContracts[this.chainId][item.contract], 'active', !this.tokenContracts[this.chainId][item.contract].active);
              Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
              localStorage.magicalInternetMoneyTokenContracts = JSON.stringify(this.tokenContracts);
            }
          },
          newTransfer(stealthMetaAddress) {
            console.log(moment().format("HH:mm:ss") + " newTransfer: " + stealthMetaAddress);
            this.modalNewTransfer.stealthMetaAddress = stealthMetaAddress;
            this.modalNewTransfer.amount = null;
            this.$bvModal.show('modal-newtransfer');
          },
          addTokensForTransfer() {
            console.log(moment().format("HH:mm:ss") + " addTokensForTransfer");
            this.$bvModal.show('modal-addtokensfortransfer');
          },

          newStealthMetaAddress() {
            console.log(moment().format("HH:mm:ss") + " newStealthMetaAddress");
            this.modalNewStealthMetaAddress.name = null;
            this.modalNewStealthMetaAddress.linkedTo = this.coinbase;
            this.modalNewStealthMetaAddress.phrase = this.defaultPhrase;
            this.modalNewStealthMetaAddress.viewingPrivateKey = null;
            this.modalNewStealthMetaAddress.spendingPublicKey = null;
            this.modalNewStealthMetaAddress.viewingPublicKey = null;
            this.modalNewStealthMetaAddress.stealthMetaAddress = null;
            this.modalNewStealthMetaAddress.status = null;
            this.$bvModal.show('modal-newstealthmetaaddress');
          },

          async generateNewStealthMetaAddress() {
            console.log(moment().format("HH:mm:ss") + " generateNewStealthMetaAddress - phrase: " + this.modalNewStealthMetaAddress.phrase);
            const phraseInHex = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(this.modalNewStealthMetaAddress.phrase));
            const signature = await ethereum.request({
              method: 'personal_sign',
              params: [phraseInHex, this.coinbase],
            });
            const signature1 = signature.slice(2, 66);
            const signature2 = signature.slice(66, 130);
            // Hash "v" and "r" values using SHA-256
            const hashedV = ethers.utils.sha256("0x" + signature1);
            const hashedR = ethers.utils.sha256("0x" + signature2);
            const n = ethers.BigNumber.from(SECP256K1_N);
            // Calculate the private keys by taking the hash values modulo the curve order
            const privateKey1 = ethers.BigNumber.from(hashedV).mod(n);
            const privateKey2 = ethers.BigNumber.from(hashedR).mod(n);
            const keyPair1 = new ethers.Wallet(privateKey1.toHexString());
            const keyPair2 = new ethers.Wallet(privateKey2.toHexString());
            Vue.set(this.modalNewStealthMetaAddress, 'viewingPrivateKey', keyPair2.privateKey);
            const spendingPublicKey = ethers.utils.computePublicKey(keyPair1.privateKey, true);
            const viewingPublicKey = ethers.utils.computePublicKey(keyPair2.privateKey, true);
            const stealthMetaAddress = "st:eth:" + spendingPublicKey + viewingPublicKey.substring(2);
            Vue.set(this.modalNewStealthMetaAddress, 'spendingPublicKey', spendingPublicKey);
            Vue.set(this.modalNewStealthMetaAddress, 'viewingPublicKey', viewingPublicKey);
            Vue.set(this.modalNewStealthMetaAddress, 'stealthMetaAddress', stealthMetaAddress);
            Vue.set(this.modalNewStealthMetaAddress, 'linkedTo', { address: this.coinbase });
            let status;
            if (stealthMetaAddress in this.addresses) {
              status = this.addresses[stealthMetaAddress].mine ? "mine" : "notmine";
            } else {
              status = "doesnotexist";
            }
            Vue.set(this.modalNewStealthMetaAddress, 'status', status);
            console.log("this.modalNewStealthMetaAddress: " + JSON.stringify(this.modalNewStealthMetaAddress, null, 2));
          },

          async revealModalTransferSpendingPrivateKey() {
            function computeStealthKey(ephemeralPublicKey, viewingPrivateKey, spendingPrivateKey) {
              const result = {};
              result.sharedSecret = nobleCurves.secp256k1.getSharedSecret(viewingPrivateKey.substring(2), ephemeralPublicKey.substring(2), false);
              result.hashedSharedSecret = ethers.utils.keccak256(result.sharedSecret.slice(1));
              const stealthPrivateKeyNumber = (BigInt(spendingPrivateKey) + BigInt(result.hashedSharedSecret)) % BigInt(SECP256K1_N);
              const stealthPrivateKeyString = stealthPrivateKeyNumber.toString(16);
              result.stealthPrivateKey = "0x" + stealthPrivateKeyString.padStart(64, '0');
              result.stealthPublicKey = "0x" +  nobleCurves.secp256k1.ProjectivePoint.fromPrivateKey(stealthPrivateKeyNumber).toHex(false);
              result.stealthAddress = ethers.utils.computeAddress(result.stealthPublicKey);
              return result;
            }

            console.log(moment().format("HH:mm:ss") + " revealModalTransferSpendingPrivateKey - modalTransfer: " + JSON.stringify(this.modalTransfer, null, 2));
            const stealthMetaAddressData = this.addresses[this.modalTransfer.item.linkedTo.stealthMetaAddress];
            console.log(moment().format("HH:mm:ss") + " revealModalTransferSpendingPrivateKey - stealthMetaAddressData: " + JSON.stringify(stealthMetaAddressData, null, 2));
            const phraseInHex = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(stealthMetaAddressData.phrase));
            const signature = await ethereum.request({
              method: 'personal_sign',
              params: [phraseInHex, this.coinbase],
            });
            const signature1 = signature.slice(2, 66);
            const signature2 = signature.slice(66, 130);
            // Hash "v" and "r" values using SHA-256
            const hashedV = ethers.utils.sha256("0x" + signature1);
            const hashedR = ethers.utils.sha256("0x" + signature2);
            const n = ethers.BigNumber.from(SECP256K1_N);
            // Calculate the private keys by taking the hash values modulo the curve order
            const privateKey1 = ethers.BigNumber.from(hashedV).mod(n);
            const privateKey2 = ethers.BigNumber.from(hashedR).mod(n);
            const keyPair1 = new ethers.Wallet(privateKey1.toHexString());
            const keyPair2 = new ethers.Wallet(privateKey2.toHexString());
            const spendingPrivateKey = keyPair1.privateKey;
            const viewingPrivateKey = keyPair2.privateKey;
            const spendingPublicKey = ethers.utils.computePublicKey(keyPair1.privateKey, true);
            const viewingPublicKey = ethers.utils.computePublicKey(keyPair2.privateKey, true);
            // const stealthMetaAddress = "st:eth:" + spendingPublicKey + viewingPublicKey.substring(2);
            console.log(moment().format("HH:mm:ss") + " revealModalTransferSpendingPrivateKey - spendingPrivateKey: " + spendingPrivateKey);
            const computedStealthKey = computeStealthKey(this.modalTransfer.item.ephemeralPublicKey, viewingPrivateKey, spendingPrivateKey);
            const stealthPrivateKey = computedStealthKey.stealthPrivateKey;
            Vue.set(this.modalTransfer, 'stealthPrivateKey', stealthPrivateKey);
            console.log("this.modalTransfer: " + JSON.stringify(this.modalTransfer, null, 2));
          },

          async revealModalAddressSpendingPrivateKey() {
            console.log(moment().format("HH:mm:ss") + " revealModalAddressSpendingPrivateKey - phrase: " + this.modalStealthMetaAddress.item.phrase);
            const phraseInHex = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(this.modalStealthMetaAddress.item.phrase));
            const signature = await ethereum.request({
              method: 'personal_sign',
              params: [phraseInHex, this.coinbase],
            });
            const signature1 = signature.slice(2, 66);
            const signature2 = signature.slice(66, 130);
            // Hash "v" and "r" values using SHA-256
            const hashedV = ethers.utils.sha256("0x" + signature1);
            const hashedR = ethers.utils.sha256("0x" + signature2);
            const n = ethers.BigNumber.from(SECP256K1_N);
            // Calculate the private keys by taking the hash values modulo the curve order
            const privateKey1 = ethers.BigNumber.from(hashedV).mod(n);
            const privateKey2 = ethers.BigNumber.from(hashedR).mod(n);
            const keyPair1 = new ethers.Wallet(privateKey1.toHexString());
            const keyPair2 = new ethers.Wallet(privateKey2.toHexString());
            Vue.set(this.modalStealthMetaAddress, 'spendingPrivateKey', keyPair1.privateKey);
            const spendingPublicKey = ethers.utils.computePublicKey(keyPair1.privateKey, true);
            const viewingPublicKey = ethers.utils.computePublicKey(keyPair2.privateKey, true);
            const stealthMetaAddress = "st:eth:" + spendingPublicKey + viewingPublicKey.substring(2);
          },

          addStealthMetaAddressToAddresses() {
            console.log(moment().format("HH:mm:ss") + " addStealthMetaAddressToAddresses");
            const address = this.addresses[this.modalNewStealthMetaAddress.stealthMetaAddress];
            if (address) {
              address.type = "stealthMetaAddress";
              address.name = this.modalNewStealthMetaAddress.name;
              address.linkedTo = this.modalNewStealthMetaAddress.linkedTo;
              address.phrase = this.modalNewStealthMetaAddress.phrase;
              address.viewingPrivateKey = this.modalNewStealthMetaAddress.viewingPrivateKey;
              address.spendingPublicKey = this.modalNewStealthMetaAddress.spendingPublicKey;
              address.viewingPublicKey = this.modalNewStealthMetaAddress.viewingPublicKey;
              address.mine = true;
              Vue.set(this.addresses, this.modalNewStealthMetaAddress.stealthMetaAddress, address);
            } else {
              if (!(this.modalNewStealthMetaAddress.linkedTo in this.addresses)) {
                Vue.set(this.addresses, this.modalNewStealthMetaAddress.linkedTo.address, {
                  type: "address",
                  name: null,
                  mine: true,
                  source: "attached.signed",
                });
              }
              Vue.set(this.addresses, this.modalNewStealthMetaAddress.stealthMetaAddress, {
                type: "stealthMetaAddress",
                name: this.modalNewStealthMetaAddress.name,
                linkedTo: this.modalNewStealthMetaAddress.linkedTo,
                phrase: this.modalNewStealthMetaAddress.phrase,
                viewingPrivateKey: this.modalNewStealthMetaAddress.viewingPrivateKey,
                spendingPublicKey: this.modalNewStealthMetaAddress.spendingPublicKey,
                viewingPublicKey: this.modalNewStealthMetaAddress.viewingPublicKey,
                mine: true,
                source: "attached.signed",
              });
            }
            Vue.set(this.addresses, this.modalNewStealthMetaAddress.stealthMetaAddress, this.addresses[this.modalNewStealthMetaAddress.stealthMetaAddress]);
            Vue.set(this, 'forceRefresh', parseInt(this.forceRefresh) + 1);
            localStorage.magicalInternetMoneyAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " addStealthMetaAddressToAddresses - addresses: " + JSON.stringify(this.addresses, null, 2));
          },

          async updateApproval() {
            console.log(moment().format("HH:mm:ss") + " updateApproval BEGIN: " + JSON.stringify(this.modalAddTokensToNewTransfer, null, 2));
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            if (this.modalAddTokensToNewTransfer.type == "erc20") {
              const contract = new ethers.Contract(this.modalAddTokensToNewTransfer.token, ERC20ABI, provider);
              const contractWithSigner = contract.connect(provider.getSigner());
              try {
                const tx = await contractWithSigner.approve(STEALTHCHADADDRESS_SEPOLIA, ethers.utils.parseUnits(this.modalAddTokensToNewTransfer.approvedInput, this.modalNewTransfer.decimals));
                console.log("tx: " + JSON.stringify(tx));
              } catch (e) {
                console.log("updateApproval - ERC20.approve(...) error: " + JSON.stringify(e));
              }
            } else if (this.modalAddTokensToNewTransfer.type == "erc721") {
              const contract = new ethers.Contract(this.modalAddTokensToNewTransfer.token, ERC721ABI, provider);
              const contractWithSigner = contract.connect(provider.getSigner());
              try {
                const tx = await contractWithSigner.setApprovalForAll(STEALTHCHADADDRESS_SEPOLIA, this.modalAddTokensToNewTransfer.isApprovedForAllInput);
                console.log("tx: " + JSON.stringify(tx));
              } catch (e) {
                console.log("updateApproval - ERC721.setApprovalForAll(...) error: " + JSON.stringify(e));
              }
            }
            console.log(moment().format("HH:mm:ss") + " updateApproval END");
          },

          async addStealthMetaAddressToRegistry(stealthMetaAddress) {
            console.log(moment().format("HH:mm:ss") + " addStealthMetaAddressToRegistry BEGIN: " + stealthMetaAddress);
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const contract = new ethers.Contract(ERC5564REGISTRYADDRESS_SEPOLIA, ERC5564REGISTRYABI_SEPOLIA, provider);
            const contractWithSigner = contract.connect(provider.getSigner());
            const schemeId = 0;
            try {
              const stealthMetaAddressInBytes = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(stealthMetaAddress));
              const tx = await contractWithSigner.registerKeys(schemeId, stealthMetaAddressInBytes);
              console.log("tx: " + JSON.stringify(tx));
            } catch (e) {
              console.log("addStealthMetaAddressToRegistry - ERC5564Registry.registerKeys(...) error: " + JSON.stringify(e));
            }
            console.log(moment().format("HH:mm:ss") + " addStealthMetaAddressToRegistry END");
          },

          async executeNewTransfer() {
            function generateStealthAddress(stealthMetaAddress) {
                const result = {};
                result.stealthMetaAddress = stealthMetaAddress;
                result.receiverSpendingPublicKey = stealthMetaAddress.slice(9, 75);
                result.receiverViewingPublicKey = stealthMetaAddress.slice(75);
                result.ephemeralPrivateKey = nobleCurves.secp256k1.utils.randomPrivateKey();
                // // TODO: Remove after testing
                // result.ephemeralPrivateKey = 26997109008263982877621605952415166666118239613620770339187915977330619367704n;
                result.ephemeralPublicKey = nobleCurves.secp256k1.getPublicKey(result.ephemeralPrivateKey, isCompressed=true);
                result.sharedSecret = nobleCurves.secp256k1.getSharedSecret(result.ephemeralPrivateKey, result.receiverViewingPublicKey, false);
                result.hashedSharedSecret = ethers.utils.keccak256(result.sharedSecret.slice(1));
                result.viewTag = "0x" + result.hashedSharedSecret.substring(2, 4);
                result.hashedSharedSecretPoint = nobleCurves.secp256k1.ProjectivePoint.fromPrivateKey(result.hashedSharedSecret.substring(2));
                result.stealthPublicKey = nobleCurves.secp256k1.ProjectivePoint.fromHex(result.receiverSpendingPublicKey).add(result.hashedSharedSecretPoint);
                result.stealthAddress = ethers.utils.computeAddress("0x" + result.stealthPublicKey.toHex(false));
                return result;
            }
            console.log(moment().format("HH:mm:ss") + " executeNewTransfer BEGIN - this.modalNewTransfer: " + JSON.stringify(this.modalNewTransfer, null, 2));
            const result = generateStealthAddress(this.modalNewTransfer.stealthMetaAddress);
            for (const [k, v] of Object.entries(result)) {
              console.log("    ", k, "=>", v);
            }

            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const contract = new ethers.Contract(STEALTHCHADADDRESS_SEPOLIA, STEALTHCHADABI_SEPOLIA, provider);
            const contractWithSigner = contract.connect(provider.getSigner());
            const schemeId = 0;
            const value = ethers.utils.parseEther(this.modalNewTransfer.amount);
            const tokens = [];
            const values = [];
            for (const item of this.modalNewTransfer.items) {
              console.log(JSON.stringify(item));
              tokens.push(item.token);
              if (item.type == "erc20") {
                values.push(ethers.utils.parseUnits(item.amount, item.decimals).toString());
              } else {
                values.push(item.tokenId.toString());
              }
            }
            console.log("tokens: " + JSON.stringify(tokens));
            console.log("values: " + JSON.stringify(values));
            try {
              // const tx = await contractWithSigner.transferEthAndAnnounce(schemeId, result.stealthAddress, result.ephemeralPublicKey, result.viewTag, { value });
              const tx = await contractWithSigner.transferAndAnnounce(schemeId, result.stealthAddress, result.ephemeralPublicKey, result.viewTag, tokens, values, { value });
              console.log("tx: " + JSON.stringify(tx));
            } catch (e) {
              console.log("executeNewTransfer StealthChad.transferEthAndAnnounce(...) error: " + JSON.stringify(e));
            }
            console.log(moment().format("HH:mm:ss") + " executeNewTransfer END");
          },

          transferRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " transferRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              this.modalTransfer.item = item[0];
              this.modalTransfer.stealthPrivateKey = null;
              this.$bvModal.show('modal-transfer');
              this.$refs.transfersTable.clearSelected();
            }
          },

          registrationRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " registrationRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              this.modalRegistration.item = item[0];
              this.$bvModal.show('modal-registration');
              this.$refs.registrationsTable.clearSelected();
            }
          },

          addressesRowSelected(item) {
            // console.log(moment().format("HH:mm:ss") + " addressesRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              const address = item[0].address;
              const addressData = this.addresses[address];
              const linkedAddress = addressData.linkedTo && addressData.linkedTo.address || null;
              const linkedAddressData = this.addresses[linkedAddress] || {};
              if (address.substring(0, 3) == "st:") {
                this.modalStealthMetaAddress.item = { address, ...addressData, linkedAddressType: linkedAddressData.type };
                this.modalStealthMetaAddress.name = addressData.name;
                this.modalStealthMetaAddress.spendingPrivateKey = null;
                this.$bvModal.show('modal-stealthmetaaddress');
              } else {
                const linkedStealthMetaAddress = addressData.linkedTo && addressData.linkedTo.stealthMetaAddress || null;
                const linkedStealthMetaAddressData = this.addresses[linkedStealthMetaAddress] || {};
                this.modalAddress.item = { address, ...addressData, linkedAddressType: linkedAddressData.type, linkedStealthMetaAddressType: linkedStealthMetaAddressData.type };
                this.modalAddress.name = addressData.name;
                this.$bvModal.show('modal-address');
              }
              this.$refs.addressesTable.clearSelected();
            }
          },

          viewAddress(address) {
            // console.log(moment().format("HH:mm:ss") + " viewAddress: " + JSON.stringify(address, null, 2));
            if (address && address.length > 0) {
              const addressData = this.addresses[address];
              const linkedAddress = addressData.linkedTo && addressData.linkedTo.address || null;
              const linkedAddressData = this.addresses[linkedAddress] || {};
              if (address.substring(0, 3) == "st:") {
                this.modalStealthMetaAddress.item = { address, ...addressData, linkedAddressType: linkedAddressData.type };
                this.modalStealthMetaAddress.name = addressData.name;
                this.$bvModal.show('modal-stealthmetaaddress');
              } else {
                const linkedStealthMetaAddress = addressData.linkedTo && addressData.linkedTo.stealthMetaAddress || null;
                const linkedStealthMetaAddressData = this.addresses[linkedStealthMetaAddress] || {};
                this.modalAddress.item = { address, ...addressData, linkedAddressType: linkedAddressData.type, linkedStealthMetaAddressType: linkedStealthMetaAddressData.type };
                this.modalAddress.name = addressData.name;
                this.$bvModal.show('modal-address');
              }
            }
          },

          contractRowSelected(item) {
            console.log(moment().format("HH:mm:ss") + " contractRowSelected: " + JSON.stringify(item, null, 2));
            if (item && item.length > 0) {
              this.modalContract.item = item[0];
              this.modalContract.name = item[0] && item[0].name || null;
              this.modalContract.read = item[0] && item[0].read || false;
              this.modalContract.write = item[0] && item[0].write || false;
              this.$bvModal.show('modal-contract');
              this.$refs.contractsTable.clearSelected();
            }
          },

          viewModalSyncOptions() {
            // console.log(moment().format("HH:mm:ss") + " viewModalSyncOptions - settings: " + JSON.stringify(this.settings, null, 2));
            this.$bvModal.show('modal-sync');
          },

          async syncIt(devMode) {
            this.$refs['modalsync'].hide();
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const signer = provider.getSigner();
            this.coinbase = await signer.getAddress();
            localStorage.magicalInternetMoneyCoinbase = this.coinbase;
            const network = await provider.getNetwork();
            localStorage.magicalInternetMoneyChainId = network.chainId;
            if (!(this.coinbase in this.addresses)) {
              Vue.set(this.addresses, this.coinbase, { type: "address", source: "attached", mine: true, name: null });
              localStorage.magicalInternetMoneyAddresses = JSON.stringify(this.addresses);
            }
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            console.log(moment().format("HH:mm:ss") + " syncIt - latestBlockNumber: " + latestBlockNumber + ", chainId: " + this.chainId);
            if (this.settings.sync.transfers && !devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncAnnouncements(db, provider, latestBlockNumber);
            }
            if (this.settings.sync.directory && !devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncRegistrations(db, provider, latestBlockNumber);
            }
            if (this.settings.sync.transfers && !devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncAnnouncementsData(db, provider, latestBlockNumber);
            }
            if (this.settings.sync.directory && !devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncRegistrationsData(db, provider, latestBlockNumber);
            }
            if (!devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.collateAddresses(db, provider, latestBlockNumber);
            }
            if (this.settings.sync.ens && !devMode && network.chainId == CHAINID_MAINNET) {
              await this.syncENSNames(provider);
            }
            if (network.chainId == CHAINID_SEPOLIA) {
              await this.processData(db, provider, latestBlockNumber);
            }
            if (this.settings.sync.tokens && !devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.syncTokenEvents(db, provider, latestBlockNumber);
            }
            if (this.settings.sync.tokens && !devMode && network.chainId == CHAINID_SEPOLIA) {
              await this.collateTokens(db, provider, latestBlockNumber);
            }
            if (this.settings.sync.exchangeRates && network.chainId == CHAINID_SEPOLIA) {
              await this.syncExchangeRates(db, provider, latestBlockNumber);
            }
            await this.loadCurrentData();
            this.forceRefresh++; // UI refresh workaround
            this.sync.section = null;
            this.sync.halt = false;
            db.close();
          },

          async syncAnnouncements(db, provider, latestBlockNumber) {
            // Announcement (index_topic_1 uint256 schemeId, index_topic_2 address stealthAddress, index_topic_3 address caller, bytes ephemeralPublicKey, bytes metadata)
            // 0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7
            const erc5564AnnouncerContract = new ethers.Contract(ERC5564ANNOUNCERADDRESS_SEPOLIA, ERC5564ANNOUNCERABI_SEPOLIA, provider);
            let total = 0;
            let t = this;
            async function processLogs(fromBlock, toBlock, selectedContracts, selectedCallers, logs) {
              total = parseInt(total) + logs.length;
              console.log(moment().format("HH:mm:ss") + " syncAnnouncements.processLogs: " + fromBlock + " - " + toBlock + " " + logs.length + " " + total);
              const records = [];
              for (const log of logs) {
                if (!log.removed) {
                  const logData = erc5564AnnouncerContract.interface.parseLog(log);
                  const contract = log.address;
                  const caller = logData.args[2];
                  if (selectedContracts.includes(contract) && selectedCallers.includes(caller)) {
                    const transfers = [];
                    const metadata = logData.args[4];
                    let segment = 0;
                    let part;
                    do {
                      part = metadata.substring(4 + (segment * 112), 4 + (segment * 112) + 112);
                      if (part.length == 112) {
                        const functionSelector = "0x" + part.substring(0, 8);
                        const token = ethers.utils.getAddress("0x" + part.substring(8, 48));
                        const valueString = part.substring(48, 112)
                        const value = ethers.BigNumber.from("0x" + valueString).toString();
                        transfers.push({ functionSelector, token, value });
                      }
                      segment++;
                    } while (part.length == 112);
                    records.push( {
                      chainId: t.chainId,
                      blockNumber: parseInt(log.blockNumber),
                      logIndex: parseInt(log.logIndex),
                      txIndex: parseInt(log.transactionIndex),
                      txHash: log.transactionHash,
                      contract,
                      name: logData.name,
                      schemeId: parseInt(logData.args[0]),
                      stealthAddress: logData.args[1],
                      linkedTo: {
                        stealthMetaAddress: null,
                        address: null,
                      },
                      mine: false,
                      caller,
                      ephemeralPublicKey: logData.args[3],
                      metadata: logData.args[4],
                      transfers,
                      confirmations: latestBlockNumber - log.blockNumber,
                      timestamp: null,
                      tx: null,
                    });
                  }
                }
              }
              // console.log("records: " + JSON.stringify(records, null, 2));
              if (records.length) {
                await db.announcements.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncAnnouncements.bulkPut error: " + error);
                });
              }
            }
            async function getLogs(fromBlock, toBlock, selectedContracts, selectedCallers, processLogs) {
              console.log(moment().format("HH:mm:ss") + " syncAnnouncements.getLogs: " + fromBlock + " - " + toBlock);
              try {
                const filter = {
                  address: null,
                  fromBlock,
                  toBlock,
                  topics: [
                    '0x5f0eab8057630ba7676c49b4f21a0231414e79474595be8e4c432fbf6bf0f4e7',
                    null,
                    null
                  ]
                };
                const eventLogs = await provider.getLogs(filter);
                await processLogs(fromBlock, toBlock, selectedContracts, selectedCallers, eventLogs);
              } catch (e) {
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogs(fromBlock, mid, selectedContracts, selectedCallers, processLogs);
                await getLogs(parseInt(mid) + 1, toBlock, selectedContracts, selectedCallers, processLogs);
              }
            }
            console.log(moment().format("HH:mm:ss") + " syncAnnouncements BEGIN");
            this.sync.completed = 0;
            this.sync.total = 0;
            this.sync.section = 'Stealth Address Announcements';
            const selectedContracts = [];
            const selectedCallers = [];
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                if (contractData.type == "announcer" && contractData.read) {
                  selectedContracts.push(contract);
                }
                if (contractData.type == "caller" && contractData.read) {
                  selectedCallers.push(contract);
                }
              }
            }
            if (selectedContracts.length > 0) {
              const deleteCall = await db.announcements.where("confirmations").below(this.CONFIRMATIONS).delete();
              const latest = await db.announcements.where('[chainId+blockNumber+logIndex]').between([this.chainId, Dexie.minKey, Dexie.minKey],[this.chainId, Dexie.maxKey, Dexie.maxKey]).last();
              const startBlock = latest ? parseInt(latest.blockNumber) + 1: 0;
              // TODO Dev const startBlock = 0;
              await getLogs(startBlock, latestBlockNumber, selectedContracts, selectedCallers, processLogs);
            }
            console.log(moment().format("HH:mm:ss") + " syncAnnouncements END");
          },

          async syncRegistrations(db, provider, latestBlockNumber) {
            // Note: Following is ERC-6538: Stealth Meta-Address Registry with registrant being bytes32 instead of bytes
            // OLD StealthMetaAddressSet (index_topic_1 bytes32 registrant, index_topic_2 uint256 scheme, bytes stealthMetaAddress)
            // OLD 0x0bb4b5456abb9a4e7e0624d821e95e2fcc8a761c9227b5d761ae0da4a3fda233
            // StealthMetaAddressSet (index_topic_1 address registrant, index_topic_2 uint256 scheme, bytes stealthMetaAddress)
            // 0x4e739a47dfa4fd3cfa92f8fe760cebe125565927e5c422cb28e7aa388a067af9
            const erc5564RegistryContract = new ethers.Contract(ERC5564REGISTRYADDRESS_SEPOLIA, ERC5564REGISTRYABI_SEPOLIA, provider);
            let total = 0;
            let t = this;
            async function processLogs(fromBlock, toBlock, selectedContracts, logs) {
              total = parseInt(total) + logs.length;
              console.log(moment().format("HH:mm:ss") + " syncRegistrations.processLogs: " + fromBlock + " - " + toBlock + " " + logs.length + " " + total);
              const records = [];
              for (const log of logs) {
                if (!log.removed) {
                  const logData = erc5564RegistryContract.interface.parseLog(log);
                  const contract = log.address;
                  if (selectedContracts.includes(contract)) {
                    records.push( {
                      chainId: t.chainId,
                      blockNumber: parseInt(log.blockNumber),
                      logIndex: parseInt(log.logIndex),
                      txIndex: parseInt(log.transactionIndex),
                      txHash: log.transactionHash,
                      contract,
                      name: logData.name,
                      registrant: ethers.utils.getAddress(logData.args[0]),
                      schemeId: parseInt(logData.args[1]),
                      stealthMetaAddress: ethers.utils.toUtf8String(logData.args[2]),
                      mine: false,
                      confirmations: latestBlockNumber - log.blockNumber,
                      timestamp: null,
                      tx: null,
                    });
                  }
                }
              }
              if (records.length) {
                await db.registrations.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncRegistrations.bulkPut error: " + error);
                });
              }
            }
            async function getLogs(fromBlock, toBlock, selectedContracts, processLogs) {
              console.log(moment().format("HH:mm:ss") + " syncRegistrations.getLogs: " + fromBlock + " - " + toBlock);
              try {
                const filter = {
                  address: null,
                  fromBlock,
                  toBlock,
                  topics: [
                    '0x4e739a47dfa4fd3cfa92f8fe760cebe125565927e5c422cb28e7aa388a067af9',
                    null,
                    null
                  ]
                };
                const eventLogs = await provider.getLogs(filter);
                await processLogs(fromBlock, toBlock, selectedContracts, eventLogs);
              } catch (e) {
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogs(fromBlock, mid, selectedContracts, processLogs);
                await getLogs(parseInt(mid) + 1, toBlock, selectedContracts, processLogs);
              }
            }
            console.log(moment().format("HH:mm:ss") + " syncRegistrations BEGIN");
            this.sync.completed = 0;
            this.sync.total = 0;
            this.sync.section = 'Stealth Address Registry';
            const selectedContracts = [];
            for (const [chainId, chainData] of Object.entries(this.contracts)) {
              for (const [contract, contractData] of Object.entries(chainData)) {
                if (contractData.type == "registry" && contractData.read) {
                  selectedContracts.push(contract);
                }
              }
            }
            if (selectedContracts.length > 0) {
              const deleteCall = await db.registrations.where("confirmations").below(this.CONFIRMATIONS).delete();
              const latest = await db.registrations.where('[chainId+blockNumber+logIndex]').between([this.chainId, Dexie.minKey, Dexie.minKey],[this.chainId, Dexie.maxKey, Dexie.maxKey]).last();
              const startBlock = latest ? parseInt(latest.blockNumber) + 1: 0;
              await getLogs(startBlock, latestBlockNumber, selectedContracts, processLogs);
            }
            console.log(moment().format("HH:mm:ss") + " syncRegistrations END");
          },

          async syncAnnouncementsData(db, provider, latestBlockNumber) {
            console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData BEGIN");
            let rows = 0;
            let done = false;
            do {
              let data = await db.announcements.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            // console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData - total: " + total);
            this.sync.completed = 0;
            this.sync.total = rows;
            this.sync.section = 'Announcements Tx Data';
            rows = 0;
            do {
              let data = await db.announcements.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              const records = [];
              for (const item of data) {
                // console.log(moment().format("HH:mm:ss") + " syncAnnouncementsData: " + JSON.stringify(item));
                if (item.timestamp == null && item.chainId == this.chainId) {
                  const block = await provider.getBlock(item.blockNumber);
                  item.timestamp = block.timestamp;
                  const tx = await provider.getTransaction(item.txHash);
                  const txReceipt = await provider.getTransactionReceipt(item.txHash);
                  item.tx = {
                    type: tx.type,
                    blockHash: tx.blockHash,
                    from: tx.from,
                    gasPrice: ethers.BigNumber.from(tx.gasPrice).toString(),
                    gasLimit: ethers.BigNumber.from(tx.gasLimit).toString(),
                    to: tx.to,
                    value: ethers.BigNumber.from(tx.value).toString(),
                    nonce: tx.nonce,
                    data: tx.to && tx.data || null, // Remove contract creation data to reduce memory footprint
                    chainId: tx.chainId,
                    contractAddress: txReceipt.contractAddress,
                    transactionIndex: txReceipt.transactionIndex,
                    gasUsed: ethers.BigNumber.from(txReceipt.gasUsed).toString(),
                    blockHash: txReceipt.blockHash,
                    logs: txReceipt.logs,
                    cumulativeGasUsed: ethers.BigNumber.from(txReceipt.cumulativeGasUsed).toString(),
                    effectiveGasPrice: ethers.BigNumber.from(txReceipt.effectiveGasPrice).toString(),
                    status: txReceipt.status,
                    type: txReceipt.type,
                  };
                  records.push(item);
                }
              }
              if (records.length > 0) {
                await db.announcements.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncAnnouncementsData.bulkPut error: " + error);
                });
              }
              rows = parseInt(rows) + data.length;
              this.sync.completed = rows;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
          },

          async syncRegistrationsData(db, provider, latestBlockNumber) {
            console.log(moment().format("HH:mm:ss") + " syncRegistrationsData BEGIN");
            let rows = 0;
            let done = false;
            do {
              let data = await db.registrations.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncRegistrationsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            // console.log(moment().format("HH:mm:ss") + " syncRegistrationsData - total: " + total);
            this.sync.completed = 0;
            this.sync.total = rows;
            this.sync.section = 'Registrations Tx Data';
            rows = 0;
            do {
              let data = await db.registrations.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " syncRegistrationsData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              const records = [];
              for (const item of data) {
                // console.log(moment().format("HH:mm:ss") + " syncRegistrationsData: " + JSON.stringify(item));
                if (item.timestamp == null && item.chainId == this.chainId) {
                  const block = await provider.getBlock(item.blockNumber);
                  item.timestamp = block.timestamp;
                  const tx = await provider.getTransaction(item.txHash);
                  const txReceipt = await provider.getTransactionReceipt(item.txHash);
                  item.tx = {
                    type: tx.type,
                    blockHash: tx.blockHash,
                    from: tx.from,
                    gasPrice: ethers.BigNumber.from(tx.gasPrice).toString(),
                    gasLimit: ethers.BigNumber.from(tx.gasLimit).toString(),
                    to: tx.to,
                    value: ethers.BigNumber.from(tx.value).toString(),
                    nonce: tx.nonce,
                    data: tx.to && tx.data || null, // Remove contract creation data to reduce memory footprint
                    chainId: tx.chainId,
                    contractAddress: txReceipt.contractAddress,
                    transactionIndex: txReceipt.transactionIndex,
                    gasUsed: ethers.BigNumber.from(txReceipt.gasUsed).toString(),
                    blockHash: txReceipt.blockHash,
                    logs: txReceipt.logs,
                    cumulativeGasUsed: ethers.BigNumber.from(txReceipt.cumulativeGasUsed).toString(),
                    effectiveGasPrice: ethers.BigNumber.from(txReceipt.effectiveGasPrice).toString(),
                    status: txReceipt.status,
                    type: txReceipt.type,
                  };
                  records.push(item);
                }
              }
              if (records.length > 0) {
                await db.registrations.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncRegistrationsData.bulkPut error: " + error);
                });
              }
              rows = parseInt(rows) + data.length;
              this.sync.completed = rows;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
          },

          async collateAddresses(db, provider, latestBlockNumber) {
            console.log(moment().format("HH:mm:ss") + " collateAddresses BEGIN");
            const addresses = this.addresses;
            if (!(this.coinbase in addresses)) {
              addresses[this.coinbase] = { type: "address", source: "attached", mine: true, name: null };
            }
            let rows = 0;
            let done = false;
            do {
              let data = await db.announcements.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " collateAddresses - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              for (const item of data) {
                if (!(item.contract in addresses)) {
                  const name = CUSTOMNAMES[item.contract] && CUSTOMNAMES[item.contract].name || null;
                  addresses[item.contract] = { type: "address", source: "announcer.contract", mine: false, name };
                }
                if (!(item.stealthAddress in addresses)) {
                  addresses[item.stealthAddress] = { type: "stealthAddress", source: "announcer.stealthAddress", mine: false, name: null };
                }
                if (!(item.caller in addresses)) {
                  const name = CUSTOMNAMES[item.caller] && CUSTOMNAMES[item.caller].name || null;
                  addresses[item.caller] = { type: "address", source: "announcer.caller", mine: false, name };
                }
                if (!(item.tx.from in addresses)) {
                  addresses[item.tx.from] = { type: "address", source: "announcer.sender", mine: item.tx.from == this.coinbase, name: null };
                }
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            rows = 0;

            done = false;
            do {
              let data = await db.registrations.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " collateAddresses - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              for (const item of data) {
                if (!(item.contract in addresses)) {
                  const name = CUSTOMNAMES[item.contract] && CUSTOMNAMES[item.contract].name || null;
                  addresses[item.contract] = { type: "address", source: "registry.contract", mine: false, name };
                }
                if (!(item.registrant in addresses)) {
                  addresses[item.registrant] = { type: "address", source: "registry.registrant", mine: false, name: null };
                }
                if (!(item.stealthMetaAddress in addresses)) {
                  addresses[item.stealthMetaAddress] = { type: "stealthMetaAddress", source: "registry.stealthMetaAddress", linkedTo: { address: item.registrant }, mine: false };
                }
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);

            for (const [address, addressData] of Object.entries(addresses)) {
              if (addressData.type == "stealthMetaAddress") {
                const linkedToData = addressData.linkedTo && addressData.linkedTo.address && addresses[addressData.linkedTo.address] || null;
                if (linkedToData && linkedToData.mine) {
                  addresses[address].mine = true;
                }
              }
            }

            Vue.set(this, 'addresses', addresses);
            localStorage.magicalInternetMoneyAddresses = JSON.stringify(this.addresses);
            // console.log(moment().format("HH:mm:ss") + " collateAddresses - addresses: " + JSON.stringify(accounts, null, 2));
            console.log(moment().format("HH:mm:ss") + " collateAddresses END");
          },

          async syncTokenEvents(db, provider, latestBlockNumber) {
            // ERC-20 & ERC-721 Transfer (index_topic_1 address from, index_topic_2 address to, index_topic_3 uint256 id)
            // [ '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', accountAs32Bytes, null ],
            // [ '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef', null, accountAs32Bytes ],

            // WETH Deposit (index_topic_1 address dst, uint256 wad)
            // 0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c
            // WETH Withdrawal (index_topic_1 address src, uint256 wad)
            // 0x7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65

            // // ERC-20 Approval (index_topic_1 address owner, index_topic_2 address spender, uint256 value)
            // // 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
            // // ERC-721 Approval (index_topic_1 address owner, index_topic_2 address approved, index_topic_3 uint256 tokenId)
            // // 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
            // // ERC-721 ApprovalForAll (index_topic_1 address owner, index_topic_2 address operator, bool approved)
            // // 0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31
            let total = 0;
            let t = this;
            async function processLogs(fromBlock, toBlock, section, logs) {
              total = parseInt(total) + logs.length;
              console.log(moment().format("HH:mm:ss") + " syncTokenEvents.processLogs: " + fromBlock + " - " + toBlock + " " + section + " " + logs.length + " " + total);
              const records = [];
              for (const log of logs) {
                if (!log.removed) {
                  const contract = log.address;
                  let eventRecord = null;
                  if (log.topics[0] == "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef") {
                    let from = null;
                    let to = null;
                    let tokensOrTokenId = null;
                    let tokens = null;
                    let tokenId = null;
                    if (log.topics.length == 4) {
                      from = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                      to = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                      tokensOrTokenId = ethers.BigNumber.from(log.topics[3]).toString();
                    } else if (log.topics.length == 3) {
                      from = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                      to = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                      tokensOrTokenId = ethers.BigNumber.from(log.data).toString();
                    // TODO: Handle 2
                    } else if (log.topics.length == 1) {
                      from = ethers.utils.getAddress('0x' + log.data.substring(26, 66));
                      to = ethers.utils.getAddress('0x' + log.data.substring(90, 130));
                      tokensOrTokenId = ethers.BigNumber.from('0x' + log.data.substring(130, 193)).toString();
                    }
                    if (from) {
                      if (log.topics.length == 4) {
                        eventRecord = { type: "Transfer", from, to, tokenId: tokensOrTokenId, eventType: "erc721" };
                      } else {
                        eventRecord = { type: "Transfer", from, to, tokens: tokensOrTokenId, eventType: "erc20" };
                      }
                    }
                  } else if (log.topics[0] == "0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c") {
                    const to = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                    tokens = ethers.BigNumber.from(log.data).toString();
                    eventRecord = { type: "Transfer", from: ADDRESS0, to, tokens, eventType: "erc20" };
                  } else if (log.topics[0] == "0x7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65") {
                    const from = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                    tokens = ethers.BigNumber.from(log.data).toString();
                    eventRecord = { type: "Transfer", from, to: ADDRESS0, tokens, eventType: "erc20" };
                  } else if (log.topics[0] == "0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925") {
                    if (log.topics.length == 4) {
                      const owner = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                      const approved = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                      tokenId = ethers.BigNumber.from(log.topics[3]).toString();
                      eventRecord = { type: "Approval", owner, approved, tokenId, eventType: "erc721" };
                    } else {
                      const owner = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                      const spender = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                      tokens = ethers.BigNumber.from(log.data).toString();
                      eventRecord = { type: "Approval", owner, spender, tokens, eventType: "erc20" };
                    }
                  } else if (log.topics[0] == "0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31") {
                    const owner = ethers.utils.getAddress('0x' + log.topics[1].substring(26));
                    const operator = ethers.utils.getAddress('0x' + log.topics[2].substring(26));
                    approved = ethers.BigNumber.from(log.data).toString();
                    eventRecord = { type: "ApprovalForAll", owner, operator, approved, eventType: "erc721" };
                  } else {
                    console.log("NOT HANDLED: " + JSON.stringify(log));
                  }
                  // TODO: Testing if (eventRecord && contract == "0x7439E9Bb6D8a84dd3A23fe621A30F95403F87fB9") {
                  if (eventRecord) {
                    records.push( {
                      chainId: t.chainId,
                      blockNumber: parseInt(log.blockNumber),
                      logIndex: parseInt(log.logIndex),
                      txIndex: parseInt(log.transactionIndex),
                      txHash: log.transactionHash,
                      contract,
                      ...eventRecord,
                      confirmations: latestBlockNumber - log.blockNumber,
                    });
                  }
                }
              }
              if (records.length) {
                await db.tokenEvents.bulkPut(records).then (function() {
                }).catch(function(error) {
                  console.log("syncTokenEvents.bulkPut error: " + error);
                });
              }
            }
            async function getLogs(fromBlock, toBlock, section, selectedAddresses, processLogs) {
              console.log(moment().format("HH:mm:ss") + " syncTokenEvents.getLogs: " + fromBlock + " - " + toBlock + " " + section);
              try {
                let topics = null;
                if (section == 0) {
                  topics = [[
                      '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',
                      '0xe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c',
                      '0x7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65',
                      '0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925',
                      '0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31',
                    ],
                    selectedAddresses,
                    null
                  ];
                } else if (section == 1) {
                  topics = [ ['0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'], null, selectedAddresses ];
                }
                const logs = await provider.getLogs({ address: null, fromBlock, toBlock, topics });
                await processLogs(fromBlock, toBlock, section, logs);
              } catch (e) {
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogs(fromBlock, mid, section, selectedAddresses, processLogs);
                await getLogs(parseInt(mid) + 1, toBlock, section, selectedAddresses, processLogs);
              }
            }
            console.log(moment().format("HH:mm:ss") + " syncTokenEvents BEGIN");
            this.sync.completed = 0;
            this.sync.total = 0;
            this.sync.section = 'ERC-20 & ERC-721 Tokens';
            const selectedAddresses = [];
            for (const [address, addressData] of Object.entries(this.addresses)) {
              if (address.substring(0, 2) == "0x" && addressData.mine) {
                selectedAddresses.push('0x000000000000000000000000' + address.substring(2, 42).toLowerCase());
              }
            }
            if (selectedAddresses.length > 0) {
              const deleteCall = await db.tokenEvents.where("confirmations").below(this.CONFIRMATIONS).delete();
              const latest = await db.tokenEvents.where('[chainId+blockNumber+logIndex]').between([this.chainId, Dexie.minKey, Dexie.minKey],[this.chainId, Dexie.maxKey, Dexie.maxKey]).last();
              // TODO Dev const startBlock = latest ? parseInt(latest.blockNumber) + 1: 0;
              // TODO Need to rescan when address set changed
              // const startBlock = 0;
              const startBlock = this.settings.sync.rescanTokens ? 0 : (latest ? parseInt(latest.blockNumber) + 1: 0);
              for (let section = 0; section < 2; section++) {
                await getLogs(startBlock, latestBlockNumber, section, selectedAddresses, processLogs);
              }
            }
            console.log(moment().format("HH:mm:ss") + " syncTokenEvents END");
          },

          async collateTokens(db, provider, latestBlockNumber) {
            // TODO: Handle low confirmation events
            console.log(moment().format("HH:mm:ss") + " collateTokens BEGIN");
            const selectedAddressesMap = {};
            for (const [address, addressData] of Object.entries(this.addresses)) {
              if (address.substring(0, 2) == "0x" && addressData.mine) {
                selectedAddressesMap[address] = true;
              }
            }
            // console.log(moment().format("HH:mm:ss") + " collateTokens - selectedAddressesMap: " + JSON.stringify(Object.keys(selectedAddressesMap)));
            const accounts = this.addresses;
            if (!(this.coinbase in accounts)) {
              accounts[this.coinbase] = { type: "address", source: "attached", mine: true, name: null };
            }
            const tokenContracts = this.tokenContracts;
            // const tokenContracts = {};
            if (!(this.chainId in tokenContracts)) {
              tokenContracts[this.chainId] = {};
            }
            // TODO: Incremental Sync. Resetting balance in the meantime
            for (const [contract, contractData] of Object.entries(tokenContracts[this.chainId])) {
              tokenContracts[this.chainId][contract].balances = {};
              tokenContracts[this.chainId][contract].tokenIds = {};
            }
            let rows = 0;
            let done = false;
            const newTokenContractsMap = {};
            do {
              let data = await db.tokenEvents.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " collateTokens - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              for (const item of data) {
                if (item.chainId == this.chainId) {
                  if (!(item.contract in tokenContracts[item.chainId]) && !(item.contract in newTokenContractsMap)) {
                    newTokenContractsMap[item.contract] = true;
                  }
                }
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            this.sync.completed = 0;
            this.sync.total = Object.keys(newTokenContractsMap).length;
            this.sync.section = 'Token Contracts';
            // const erc721Helper = this.chainId == CHAINID_MAINNET ? new ethers.Contract(ERC721HELPERADDRESS, ERC721HELPERABI, provider) : null;
            rows = 0;
            done = false;
            do {
              let data = await db.tokenEvents.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " collateTokens - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              for (const item of data) {
                if (item.chainId == this.chainId) {
                  if (!(item.contract in tokenContracts[item.chainId])) {
                    const contract = new ethers.Contract(item.contract, ERC20ABI, provider);
                    let symbol = null;
                    let name = null;
                    let decimals = null;
                    let totalSupply = null;
                    // if (this.chainId == CHAINID_MAINNET) {
                    //   try {
                    //     const tokenInfos = await erc721Helper.tokenInfo([item.contract], { gasLimit: 1000000 });
                    //     console.log(tokenInfos);
                    //     for (let i = 0; i < tokenInfos[0].length; i++) {
                    //     //   results.mask = tokenInfos[0][i].toNumber();
                    //       symbol = tokenInfos[1][i];
                    //       name = tokenInfos[2][i];
                    //     }
                    //   } catch (e) {
                    //     console.log("getAccountInfo ERROR - account: " + item.contract + ", message: " + e.message);
                    //     // results.mask = 0;
                    //     // results.symbol = null;
                    //     // results.name = null;
                    //   }
                    // } else {
                      try {
                        symbol = await contract.symbol();
                      } catch (e) {
                      }
                      try {
                        name = await contract.name();
                      } catch (e) {
                      }
                      if (item.eventType == "erc20") {
                        try {
                          decimals = await contract.decimals();
                        } catch (e) {
                        }
                      }
                      try {
                        totalSupply = await contract.totalSupply();
                      } catch (e) {
                      }
                    // }

                    tokenContracts[item.chainId][item.contract] = {
                      active: false,
                      symbol: symbol && symbol.trim() || null,
                      name: name && name.trim() || null,
                      decimals: parseInt(decimals || 0),
                      totalSupply: totalSupply && totalSupply.toString() || null,
                      type: item.eventType,
                      firstEventBlockNumber: item.blockNumber,
                      lastEventBlockNumber: null,
                      events: {},
                      balances: {},
                      tokenIds: {},
                    };
                    this.sync.completed++;
                  }
                  const lastEventBlockNumber = tokenContracts[item.chainId][item.contract].lastEventBlockNumber || 0;
                  // console.log("item: " + JSON.stringify(item));
                  if (item.eventType == "erc20" && item.type == "Transfer") {
                    // console.log("ERC-20.Transfer from: " + item.from + ", to: " + item.to + ", tokens: " + item.tokens + ", item.blockNumber: " + item.blockNumber + "; lastEventBlockNumber: " + lastEventBlockNumber);
                    // if (item.blockNumber > lastEventBlockNumber) {
                      const balances = tokenContracts[item.chainId][item.contract].balances || 0;
                      if (item.from in selectedAddressesMap) {
                        if (!(item.from in balances)) {
                          balances[item.from] = "0";
                        }
                        balances[item.from] = ethers.BigNumber.from(balances[item.from]).sub(item.tokens).toString();
                        // console.log("from included: " + item.from + ", balances[item.from]: " + balances[item.from] + ", tokens: " + item.tokens);
                      }
                      if (item.to in selectedAddressesMap) {
                        if (!(item.to in balances)) {
                          balances[item.to] = "0";
                        }
                        balances[item.to] = ethers.BigNumber.from(balances[item.to]).add(item.tokens).toString();
                        // console.log("to included: " + item.to + ", balances[item.to]: " + balances[item.to] + ", tokens: " + item.tokens);
                      }
                      tokenContracts[item.chainId][item.contract].balances = balances;
                      tokenContracts[item.chainId][item.contract].lastEventBlockNumber = item.blockNumber;
                    // }
                    // console.log("tokenContracts[item.chainId][item.contract]: " + JSON.stringify(tokenContracts[item.chainId][item.contract]));
                  } else if (item.eventType == "erc721" && item.type == "Transfer") {
                    const tokenIds = tokenContracts[item.chainId][item.contract].tokenIds || {};
                    if (item.from in selectedAddressesMap) {
                      if (!(item.from in tokenIds)) {
                        delete tokenIds[item.tokenId];
                      }
                    }
                    if (item.to in selectedAddressesMap) {
                      if (!(item.to in tokenIds)) {
                        tokenIds[item.tokenId] = { owner: item.to, blockNumber: item.blockNumber, logIndex: item.logIndex };
                      }
                    }
                    tokenContracts[item.chainId][item.contract].tokenIds = tokenIds;
                    tokenContracts[item.chainId][item.contract].lastEventBlockNumber = item.blockNumber;
                  }

                  // const tokenContract = tokenContracts[item.chainId][item.contract];
                  // console.log("tokenContract: " + item.contract + " => " + JSON.stringify(tokenContract));
                  // const events = tokenContracts[item.chainId][item.contract].events;
                  // if (!(item.blockNumber in events)) {
                  //   events[item.blockNumber] = { timestamp: item.timestamp, logIndexes: {} };
                  // }
                  // if (!(item.logIndex in events[item.blockNumber].logIndexes)) {
                  //   events[item.blockNumber].logIndexes[item.logIndex] = {
                  //     txHash: item.txHash,
                  //     type: item.type,
                  //     eventType: item.eventType,
                  //     from: item.from || undefined,
                  //     to: item.to || undefined,
                  //     tokens: item.tokens || undefined,
                  //     tokenId: item.tokenId || undefined,
                  //     owner: item.owner || undefined,
                  //     operator: item.operator || undefined,
                  //     approved: item.approved || undefined,
                  //   };
                  // }

                  // if (item.active) {
                  //   console.log("tokenContract: " + item.contract + " => " + JSON.stringify(tokenContract));
                  // }
                }
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            rows = 0;

            // done = false;
            // do {
            //   let data = await db.registrations.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
            //   console.log(moment().format("HH:mm:ss") + " collateTokens - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
            //   for (const item of data) {
            //     if (!(item.contract in accounts)) {
            //       const name = CUSTOMNAMES[item.contract] && CUSTOMNAMES[item.contract].name || null;
            //       accounts[item.contract] = { type: "address", source: "registry.contract", mine: false, name };
            //     }
            //     if (!(item.registrant in accounts)) {
            //       accounts[item.registrant] = { type: "address", source: "registry.registrant", mine: false, name: null };
            //     }
            //     if (!(item.stealthMetaAddress in accounts)) {
            //       accounts[item.stealthMetaAddress] = { type: "stealthMetaAddress", source: "registry.stealthMetaAddress", linkedTo: item.registrant, mine: false };
            //     }
            //   }
            //   rows = parseInt(rows) + data.length;
            //   done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            // } while (!done);
            //
            // for (const [address, addressData] of Object.entries(accounts)) {
            //   if (addressData.type == "stealthMetaAddress") {
            //     const linkedToData = addressData.linkedTo && accounts[addressData.linkedTo] || null;
            //     if (linkedToData && linkedToData.mine) {
            //       accounts[address].mine = true;
            //     }
            //   }
            // }
            //
            Vue.set(this, 'tokenContracts', tokenContracts);
            localStorage.magicalInternetMoneyTokenContracts = JSON.stringify(this.tokenContracts);
            // console.log(moment().format("HH:mm:ss") + " collateTokens - tokenContracts: " + JSON.stringify(tokenContracts, null, 2));
            console.log(moment().format("HH:mm:ss") + " collateTokens END");
          },

          async syncExchangeRates(db, provider, latestBlockNumber) {
            console.log(moment().format("HH:mm:ss") + " syncExchangeRates - reportingCurrency: " + this.settings.reportingCurrency);
            if (this.settings.reportingCurrency) {
              const MAXDAYS = 2000;
              const MINDATE = moment("2017-06-09");
              let toTs = moment();
              const exchangeRates = {};
              while (toTs.year() >= 2017) {
                let days = toTs.diff(MINDATE, 'days');
                if (days > MAXDAYS) {
                  days = MAXDAYS;
                }
                let url = "https://min-api.cryptocompare.com/data/v2/histoday?fsym=ETH&tsym=" + this.settings.reportingCurrency + "&toTs=" + toTs.unix() + "&limit=" + days;
                if (this.settings.cryptoCompareAPIKey) {
                  url = url + "&api_key=" + this.settings.cryptoCompareAPIKey;
                }
                console.log(moment().format("HH:mm:ss") + " syncExchangeRates - url: " + url);
                const data = await fetch(url)
                  .then(response => response.json())
                  .catch(function(e) {
                    console.log("error: " + e);
                  });
                for (day of data.Data.Data) {
                  exchangeRates[moment.unix(day.time).format("YYYYMMDD")] = day.close;
                }
                toTs = moment(toTs).subtract(MAXDAYS, 'days');
              }
              // console.log(moment().format("HH:mm:ss") + " syncExchangeRates - exchangeRates: " + JSON.stringify(exchangeRates));
              Vue.set(this, 'exchangeRates', exchangeRates);
              localStorage.magicalInternetMoneyExchangeRates = JSON.stringify(this.exchangeRates);
            }
            console.log(moment().format("HH:mm:ss") + " syncExchangeRates END");
          },

          async syncENSNames(provider) {
            console.log(moment().format("HH:mm:ss") + " syncENSNames BEGIN");
            const ensReverseRecordsContract = new ethers.Contract(ENSREVERSERECORDSADDRESS, ENSREVERSERECORDSABI, provider);
            for (const [account, addressData] of Object.entries(this.addresses)) {
              if (addressData.type == "address") {
                try {
                  const allnames = await ensReverseRecordsContract.getNames([account]);
                  const name = allnames.length >= 0 && allnames[0] && ethers.utils.isValidName(allnames[0]) && allnames[0] || null;
                  Vue.set(this.addresses[account], 'ensName', name);
                } catch (e) {
                  console.log("syncENSNames - ENS reverse lookup failed: " + e.toString());
                }
              }
            }
            localStorage.magicalInternetMoneyAddresses = JSON.stringify(this.addresses);
            console.log(moment().format("HH:mm:ss") + " syncENSNames END");
          },

          // TODO: Rename - identifyMyStealthPayments
          async processData(db, provider, latestBlockNumber) {
            function checkStealthAddress(stealthAddress, ephemeralPublicKey, viewingPrivateKey, spendingPublicKey) {
              const result = {};
              // console.log(moment().format("HH:mm:ss") + " processDataOld - checkStealthAddress - stealthAddress: " + stealthAddress + ", ephemeralPublicKey: " + ephemeralPublicKey + ", viewingPrivateKey: " + viewingPrivateKey + ", spendingPublicKey: " + spendingPublicKey);
              // console.log("    Check stealthAddress: " + stealthAddress + ", ephemeralPublicKey: " + ephemeralPublicKey + ", viewingPrivateKey: " + viewingPrivateKey + ", spendingPublicKey: " + spendingPublicKey);
              result.sharedSecret = nobleCurves.secp256k1.getSharedSecret(viewingPrivateKey.substring(2), ephemeralPublicKey.substring(2), false);
              result.hashedSharedSecret = ethers.utils.keccak256(result.sharedSecret.slice(1));
              result.hashedSharedSecretPoint = nobleCurves.secp256k1.ProjectivePoint.fromPrivateKey(result.hashedSharedSecret.substring(2));
              result.stealthPublicKey = nobleCurves.secp256k1.ProjectivePoint.fromHex(spendingPublicKey.substring(2)).add(result.hashedSharedSecretPoint);
              result.stealthAddress = ethers.utils.computeAddress("0x" + result.stealthPublicKey.toHex(false));
              result.match = result.stealthAddress == stealthAddress;
              return result;
            }

            console.log(moment().format("HH:mm:ss") + " processData BEGIN");
            const checkAddresses = [];
            for (const [address, addressData] of Object.entries(this.addresses)) {
              if (addressData.type == "stealthMetaAddress" && addressData.mine && addressData.viewingPrivateKey) {
                checkAddresses.push({ address, ...addressData });
              }
            }
            // console.log(moment().format("HH:mm:ss") + " processData - checkAddresses: " + JSON.stringify(checkAddresses.map(e => e.address)));

            let rows = 0;
            let done = false;
            do {
              let data = await db.announcements.offset(rows).limit(this.DB_PROCESSING_BATCH_SIZE).toArray();
              console.log(moment().format("HH:mm:ss") + " processData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              const writeRecords = [];
              for (const item of data) {
                const sender = item.tx && item.tx.from || null;
                const senderData = sender && this.addresses[sender] || {};
                item.iSent = senderData.mine;
                item.iReceived = false;
                delete item.linkedTo;
                const stealthAddress = item.stealthAddress;
                const stealthAddressData = this.addresses[stealthAddress];
                const ephemeralPublicKey = item.ephemeralPublicKey;
                for (const address of checkAddresses) {
                  const viewingPrivateKey = address.viewingPrivateKey;
                  const viewingPublicKey = address.viewingPublicKey;
                  const spendingPublicKey = address.spendingPublicKey;
                  const status = checkStealthAddress(stealthAddress, ephemeralPublicKey, viewingPrivateKey, spendingPublicKey);
                  if (status && status.match) {
                    item.linkedTo = { stealthMetaAddress: address.address, address: address.linkedTo.address };
                    item.iReceived = true;
                    Vue.set(this.addresses[stealthAddress], 'linkedTo', { stealthMetaAddress: address.address, address: address.linkedTo.address });
                    Vue.set(this.addresses[stealthAddress], 'mine', true);
                    break;
                  }
                }
                writeRecords.push(item);
              }
              if (writeRecords.length > 0) {
                await db.announcements.bulkPut(writeRecords).then (function() {
                }).catch(function(error) {
                  console.log("processData.bulkPut error: " + error);
                });
              }
              rows = parseInt(rows) + data.length;
              done = data.length < this.DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            rows = 0;
            localStorage.magicalInternetMoneyAddresses = JSON.stringify(this.addresses);
            // console.log(moment().format("HH:mm:ss") + " processData - addresses: " + JSON.stringify(this.addresses, null, 2));
            console.log(moment().format("HH:mm:ss") + " processData END");
          },

          async loadCurrentData() {
            console.log(moment().format("HH:mm:ss") + " loadCurrentData BEGIN");
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            const announcements = await db.announcements.toArray();
            Vue.set(this, 'announcements', announcements);
            const registrations = await db.registrations.toArray();
            Vue.set(this, 'registrations', registrations);
            const tokenEvents = await db.tokenEvents.toArray();
            Vue.set(this, 'tokenEvents', tokenEvents);
            // console.log(moment().format("HH:mm:ss") + " loadCurrentData - tokenEvents[0..1]: " + JSON.stringify(tokenEvents.slice(0, 2), null, 2));
            db.close();
            console.log(moment().format("HH:mm:ss") + " loadCurrentData END");
          },

          saveSettings() {
            // console.log(moment().format("HH:mm:ss") + " saveSettings: " + JSON.stringify(this.settings));
            localStorage.magicalInternetMoneySettings = JSON.stringify(this.settings);
          },
          async processNewBlock(blockNumber) {
            console.log(moment().format("HH:mm:ss") + " processNewBlock[" + this.chainId + "] #" + this.commify0(blockNumber) + ", latest #" + this.commify0(this.blockNumber) + " @ " + moment.unix(this.timestamp).format("YYYY-MM-DD HH:mm:ss") + " " + moment.unix(this.timestamp).fromNow());
          },
          async halt() {
            this.sync.halt = true;
            console.log(moment().format("HH:mm:ss") + " halt()");
          },
          commify0(n) {
            if (n != null) {
              return Number(n).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
            return null;
          },
          formatETH(e, precision = 0) {
            try {
              if (precision == 0) {
                return e ? ethers.utils.formatEther(e).replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",") : null;
              } else {
                return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(precision) : null;
              }
            } catch (err) {
            }
            return e.toFixed(precision);
          },
          formatDecimals(e, decimals = 18) {
            return e ? ethers.utils.formatUnits(e, decimals).replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",") : null;
          },
          formatTimestamp(ts) {
            if (ts != null) {
              if (this.settings.reportingDateTime == 1) {
                return moment.unix(ts).utc().format("YYYY-MM-DD HH:mm:ss");
              } else {
                return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
              }
            }
            return null;
          },
          formatTimeDiff(unixtime) {
            if (!unixtime) {
              return "";
            } else {
              return moment.unix(unixtime).fromNow();
            }
          },
          formatTxHash(txHash) {
            return txHash && txHash.substring(0, this.TXHASH_SEGMENT_LENGTH + 2) + '...' + txHash.slice(-this.TXHASH_SEGMENT_LENGTH) || null;
          },
          formatAddress(address) {
            if (address) {
              if (address.substring(0, 3) == "st:") {
                return address.substring(0, this.STEALTHMETAADDRESS_SEGMENT_LENGTH + 9) + '...' + address.slice(-this.STEALTHMETAADDRESS_SEGMENT_LENGTH);
              } else {
                return address.substring(0, this.ADDRESS_SEGMENT_LENGTH + 2) + '...' + address.slice(-this.ADDRESS_SEGMENT_LENGTH);
              }
            }
            return null;
          },
          ensName(address) {
            const account = this.addresses[address];
            return account && account.ensName || null;
          },
          ensNameOrAddress(address, length = 0) {
            let result = null;
            const account = address && this.addresses[address] || null;
            if (account && account.ensName) {
              if (length > 0 && account.ensName.length > length) {
                result = account.ensName.substring(0, (length-7)/2) + '...' + account.ensName.slice(-((length-7)/2 + 4));
              } else {
                result = account.ensName;
              }
            } else if (address) {
              result =  address.substring(0, this.ADDRESS_SEGMENT_LENGTH + 2) + '...' + address.slice(-this.ADDRESS_SEGMENT_LENGTH);
            }
            return result;
          },
          formatAddressNamePrimary(address) {
            if (address) {
              const account = this.addresses[address];
              if (account && account.name) {
                return account.name;
              } else if (account && account.ensName) {
                  return account.ensName;
              } else {
                if (address.substring(0, 3) == "st:") {
                  return address.substring(0, this.STEALTHMETAADDRESS_SEGMENT_LENGTH + 9) + '...' + address.slice(-this.STEALTHMETAADDRESS_SEGMENT_LENGTH);
                } else {
                  return address.substring(0, this.ADDRESS_SEGMENT_LENGTH + 2) + '...' + address.slice(-this.ADDRESS_SEGMENT_LENGTH);
                }
              }
            }
            return null;
          },
          formatAddressNameSecondary(address) {
            if (address) {
              const account = this.addresses[address];
              if (account && account.name) {
                if (account.ensName) {
                  if (address.substring(0, 3) == "st:") {
                    return account.ensName + ', ' + address.substring(0, this.STEALTHMETAADDRESS_SEGMENT_LENGTH + 9) + '...' + address.slice(-this.STEALTHMETAADDRESS_SEGMENT_LENGTH);
                  } else {
                    return account.ensName + ', ' + address.substring(0, this.ADDRESS_SEGMENT_LENGTH + 2) + '...' + address.slice(-this.ADDRESS_SEGMENT_LENGTH);
                  }
                } else {
                  if (address.substring(0, 3) == "st:") {
                    return address.substring(0, this.STEALTHMETAADDRESS_SEGMENT_LENGTH + 9) + '...' + address.slice(-this.STEALTHMETAADDRESS_SEGMENT_LENGTH);
                  } else {
                    return address.substring(0, this.ADDRESS_SEGMENT_LENGTH + 2) + '...' + address.slice(-this.ADDRESS_SEGMENT_LENGTH);
                  }
                }
              } else if (account && account.ensName) {
                if (address.substring(0, 3) == "st:") {
                  return address.substring(0, this.STEALTHMETAADDRESS_SEGMENT_LENGTH + 9) + '...' + address.slice(-this.STEALTHMETAADDRESS_SEGMENT_LENGTH);
                } else {
                  return address.substring(0, this.ADDRESS_SEGMENT_LENGTH + 2) + '...' + address.slice(-this.ADDRESS_SEGMENT_LENGTH);
                }
              } else {
                return null;
              }
            }
            return null;
          },
          nameOrAddress(address, length = 0) {
            let result = null;
            const account = this.addresses[address];
            if (account) {
              if (account.ensName) {
                if (account.name) {
                  result = account.name + '; ' + account.ensName;
                } else {
                  result = account.ensName;
                }
              } else {
                if (account.name) {
                  result = account.name;
                } else {
                  result = address;
                }
              }
            } else {
              result = address;
            }
            if (result && length > 0) {
              result = result.substring(0, length);
            }
            return result;
          },
          nameOrNull(address) {
            let result = null;
            const addressData = address && this.addresses[address];
            if (addressData) {
              if (addressData.ensName) {
                if (addressData.name) {
                  result = addressData.name + '; ' + addressData.ensName;
                } else {
                  result = addressData.ensName;
                }
              } else {
                result = addressData.name || null;
              }
            }
            return result;
          },
          addressDescription(address) {
            const account = this.addresses[address];
            if (account) {
              result = address;
              for (let key of [ 'linkedTo.address', 'linkedTo.stealthMetaAddress', 'ensName', 'name', 'source', 'stealthMetaAddress' ]) {
                if (key in account) {
                  result = result + "; " + key + "=" + account[key];
                }
              }
            } else {
              result = address;
            }
            return result;
          },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
          },
          downloadTransfers() {
            console.log(moment().format("HH:mm:ss") + " downloadTransfers");
            const rows = [
                ["Chain Id", "Block Number", "Tx Index", "Log Index", "Tx Hash", "When", "I Sent", "Sender", "I Received", "Receiver Stealth Address", "Ephemeral Public Key", "Linked To Address", "Via Stealth Meta-Address", "Token", "Value" ],
            ];
            for (const item of this.filteredSortedTransfers) {
              for (const transfer of item.transfers) {
                rows.push([
                  item.chainId,
                  item.blockNumber,
                  item.txIndex,
                  item.logIndex,
                  item.txHash,
                  this.formatTimestamp(item.timestamp),
                  item.iSent,
                  item.tx.from,
                  item.iReceived,
                  item.stealthAddress,
                  item.ephemeralPublicKey,
                  item.linkedTo && item.linkedTo.address,
                  item.linkedTo && item.linkedTo.stealthMetaAddress,
                  transfer.token == ADDRESS_ETHEREUMS ? "ETH" : transfer.token,
                  transfer.value, // TODO: handle token decimals etc
                ]);
              }
            }
            let tsvContent = "data:text/tsv;charset=utf-8," + rows.map(e => e.join("\t")).join("\n");
            // console.log("tsvContent: " + tsvContent);
            var encodedUri = encodeURI(tsvContent);
            var link = document.createElement("a");
            link.setAttribute("href", encodedUri.replaceAll('#', '%23'));
            link.setAttribute("download", "stealthchad_transfers-" + moment().format("YYYY-MM-DD-HH-mm-ss") + ".tsv");
            document.body.appendChild(link); // Required for FF
            link.click(); // This will download the data with the specified file name
          },
          downloadAddresses() {
            console.log(moment().format("HH:mm:ss") + " downloadAddresses");
            const rows = [
                ["Address", "Type", "Mine", "Name", "ENS Name", "Phrase", "Linked To Stealth Meta-Address", "Linked To Address" ],
            ];
            for (const item of this.filteredSortedAddresses) {
              rows.push([ item.address, item.type, item.mine, item.name, item.ensName, item.phrase, item.linkedTo && item.linkedTo.stealthMetaAddress, item.linkedTo && item.linkedTo.address ]);
            }
            let tsvContent = "data:text/tsv;charset=utf-8," + rows.map(e => e.join("\t")).join("\n");
            var encodedUri = encodeURI(tsvContent);
            var link = document.createElement("a");
            link.setAttribute("href", encodedUri.replaceAll('#', '%23'));
            link.setAttribute("download", "stealthchad_addresses-" + moment().format("YYYY-MM-DD-HH-mm-ss") + ".tsv");
            document.body.appendChild(link); // Required for FF
            link.click(); // This will download the data with the specified file name
          },
          async connectToWeb3() {
            if (!window.ethereum) {
              this.connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                this.connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("connectToWeb3 - window.ethereum.request error: " + e.message);
                this.connected = false;
              }
            }
            if (!this.connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const t = this;
              function handleChainChanged(_chainId) {
                t.chainId = parseInt(_chainId);
                console.log(moment().format("HH:mm:ss") + " connectToWeb3.handleChainChanged - this.chainId: " + t.chainId.toString());
                // alert('Ethereum chain has changed - reloading this page.')
                // window.location.reload();
              }
              window.ethereum.on('chainChanged', handleChainChanged);
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              async function handleAccountsChanged(accounts) {
                const signer = provider.getSigner();
                t.coinbase = await signer.getAddress();
                console.log(moment().format("HH:mm:ss") + " connectToWeb3.handleAccountsChanged: " + t.coinbase);
                if (!(t.coinbase in t.addresses)) {
                  Vue.set(t.addresses, t.coinbase, { type: "address", source: "attached", mine: true, name: null });
                  localStorage.magicalInternetMoneyAddresses = JSON.stringify(t.addresses);
                } if (!t.addresses[t.coinbase].mine) {
                  Vue.set(t.addresses[t.coinbase], 'mine', true);
                  localStorage.magicalInternetMoneyAddresses = JSON.stringify(t.addresses);
                }
                console.log(moment().format("HH:mm:ss") + " connectToWeb3.handleAccountsChanged - address: " + JSON.stringify(t.addresses[t.coinbase]));
              }
              window.ethereum.on('accountsChanged', handleAccountsChanged);
              async function handleNewBlock(blockNumber) {
                if (!t.blockNumber || blockNumber > t.blockNumber) {
                  const block = await provider.getBlock("latest");
                  t.blockNumber = block.number;
                  t.timestamp = block.timestamp;
                  await t.processNewBlock(blockNumber);
                }
              }
              provider.on("block", handleNewBlock);
              const signer = provider.getSigner();
              this.coinbase = await signer.getAddress();
              const network = await provider.getNetwork();
              this.chainId = network.chainId;
              console.log(moment().format("HH:mm:ss") + " connectToWeb3[" + this.chainId + "]");
            }
          },
        },

        // --- MOUNTED ---
        mounted() {
          (async() => {
            await this.connectToWeb3();
          })();
          if ('magicalInternetMoneyChainId' in localStorage) {
            this.chainId = localStorage.magicalInternetMoneyChainId;
          }
          if ('magicalInternetMoneyCoinbase' in localStorage) {
            this.coinbase = localStorage.magicalInternetMoneyCoinbase;
          }
          if ('magicalInternetMoneySettings' in localStorage) {
            const tempSettings = JSON.parse(localStorage.magicalInternetMoneySettings);
            if ('version' in tempSettings && tempSettings.version == this.settings.version) {
              this.settings = tempSettings;
              for (let table of ['transfersTable', 'registrationsTable', 'addressesTable', 'tokenContractsTable', 'contractsTable']) {
                if (this.settings[table].currentPage > 1) {
                  this.settings[table].currentPage = 1;
                }
              }
              // Restore other settings for the same version
              for (const name of ['contracts', 'addresses', 'tokenContracts', 'exchangeRates']) {
                const keyName = 'magicalInternetMoney' + name.substring(0, 1).toUpperCase() + name.substring(1);
                if (keyName in localStorage) {
                  Vue.set(this, name, JSON.parse(localStorage[keyName]));
                }
              }
              // TODO: TESTING
              // (async() => {
              //   await delay(1500);
              //   await this.transfer("st:eth:0x039441d882d0cf33565dda9c752910f9bb13186555495c081e9d33e391518456c403ea8baab0486a7b4b6056d77e35a8f0b5534550fdfe53a69180885ea10fbecb96");
              // })();
            }
            (async() => {
              await this.loadCurrentData();
            })();
          }
        },
      })
    </script>
  </body>
</html>
